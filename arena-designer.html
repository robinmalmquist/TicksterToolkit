<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="UTF-8" />
  <title>Arena Designer</title>
  <style>
    * { box-sizing: border-box; }

    :root {
      --tick-blue-light: #7cd0ff;
      --tick-blue:       #14a0f4;
      --tick-blue-dark:  #0c6ba5;

      --tick-turq-light: #6ee0db;
      --tick-turq:       #19bab5;
      --tick-turq-dark:  #117c79;

      --tick-yellow-light: #ffe479;
      --tick-yellow:       #e6c229;
      --tick-yellow-dark:  #99811c;

      --tick-grey-light: #dbe0e4;
      --tick-grey:       #849099;
      --tick-grey-dark:  #4f5d68;

      --tick-red-light: #e57c8c;
      --tick-red:       #c12e44;
      --tick-red-dark:  #801f2e;

      --tick-green-light: #5cae8f;
      --tick-green:       #007347;
      --tick-green-dark:  #004d2f;

      --app-bg: #f3f6f9;
      --card-bg: #ffffff;
      --card-border: #dbe0e4;
      --card-shadow: 0 2px 8px rgba(0,0,0,0.04);
      --radius-card: 10px;
      --radius-pill: 999px;
      --transition-fast: 0.15s ease-out;
      --font-main: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      --font-mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
    }

    body {
      font-family: var(--font-main);
      background: radial-gradient(circle at top left, #7cd0ff 0, #f3f6f9 40%, #f3f6f9 100%);
      color: var(--tick-grey-dark);
      overflow: hidden;
    }

    /* Layout-root */
    #app {
      display: grid;
      grid-template-columns: 240px 1fr 260px;
      grid-template-rows: 1fr;
      gap: 0.75rem;
      height: 100vh;
      padding: 0.75rem;
    }

    /* ---------- Tickster-komponenter ---------- */

    .c-card {
      background: var(--card-bg);
      border-radius: var(--radius-card);
      border: 1px solid var(--card-border);
      box-shadow: var(--card-shadow);
      padding: 0.75rem;
      display: flex;
      flex-direction: column;
    }

    .c-card__header {
      margin-bottom: 0.5rem;
    }

    .c-card__title {
      font-size: 0.9rem;
      font-weight: 600;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--tick-grey-dark);
      display: flex;
      align-items: center;
      gap: 0.35rem;
    }

    .c-card__subtitle {
      font-size: 0.8rem;
      color: var(--tick-grey);
      margin-top: 0.1rem;
    }

    .c-toolbar {
      display: flex;
      flex-direction: column;
      gap: 0.4rem;
      margin-bottom: 0.5rem;
    }

    .c-toolbar--horizontal {
      flex-direction: row;
      align-items: center;
    }

    .c-button {
      border-radius: var(--radius-pill);
      border: 1px solid transparent;
      background: #f7f9fc;
      padding: 0.4rem 0.9rem;
      font-size: 0.85rem;
      cursor: pointer;
      color: var(--tick-grey-dark);
      transition: background var(--transition-fast), border-color var(--transition-fast), transform var(--transition-fast), box-shadow var(--transition-fast);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.3rem;
      white-space: nowrap;
    }

    .c-button:hover:not(:disabled) {
      background: #edf5ff;
      transform: translateY(-1px);
      box-shadow: 0 2px 4px rgba(0,0,0,0.07);
    }

    .c-button:disabled {
      opacity: 0.5;
      cursor: default;
      box-shadow: none;
      transform: none;
    }

    .c-button--primary {
      background: var(--tick-blue);
      border-color: var(--tick-blue-dark);
      color: #fff;
    }

    .c-button--primary:hover:not(:disabled) {
      background: var(--tick-blue-dark);
    }

    .c-button--secondary {
      background: var(--tick-turq-light);
      border-color: var(--tick-turq);
      color: var(--tick-turq-dark);
    }

    .c-button--ghost {
      background: transparent;
      border-color: var(--tick-grey-light);
      color: var(--tick-grey-dark);
    }

    .c-button--small {
      padding: 0.25rem 0.7rem;
      font-size: 0.78rem;
    }

    .c-button--icon-left::before {
      content: attr(data-icon);
      font-size: 0.9rem;
    }

    .c-button--active {
      box-shadow: 0 0 0 1px rgba(20,160,244,0.6);
      border-color: var(--tick-blue);
      background: rgba(124,208,255,0.15);
      color: var(--tick-blue-dark);
    }

    .c-pill {
      display: inline-flex;
      align-items: center;
      padding: 0.15rem 0.55rem;
      border-radius: var(--radius-pill);
      font-size: 0.75rem;
      background: var(--tick-grey-light);
      color: var(--tick-grey-dark);
      gap: 0.25rem;
    }

    .c-pill__code {
      font-family: var(--font-mono);
      background: #fff;
      padding: 0.05rem 0.4rem;
      border-radius: var(--radius-pill);
      border: 1px solid rgba(0,0,0,0.06);
      font-size: 0.72rem;
    }

    .u-font--small   { font-size: 0.8rem; }
    .u-font--smaller { font-size: 0.75rem; }
    .u-font--mono    { font-family: var(--font-mono); }

    /* Sektion-manager modal */
    #sectionManagerOverlay {
      position: fixed;
      inset: 0;
      background: rgba(12, 28, 48, 0.65);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 30;
      padding: 1rem;
    }

    .section-manager {
      width: min(1440px, 98vw);
      height: min(90vh, 960px);
      background: #fff;
      border-radius: 12px;
      box-shadow: 0 20px 50px rgba(0,0,0,0.25);
      border: 1px solid #dbe0e4;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .section-manager__header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.85rem 1rem;
      border-bottom: 1px solid #e5e9ef;
    }

    .section-manager__title {
      font-weight: 700;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      color: #243743;
      font-size: 0.95rem;
    }

    .section-manager__body {
      flex: 1;
      display: grid;
      grid-template-columns: 260px 1fr;
      gap: 0.75rem;
      padding: 0.75rem;
      background: #f7f9fc;
    }

    .section-list {
      background: #fff;
      border: 1px solid #e1e6ef;
      border-radius: 10px;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      box-shadow: 0 4px 16px rgba(0,0,0,0.04);
    }

    .section-list__header {
      padding: 0.7rem 0.75rem;
      border-bottom: 1px solid #e6ebf3;
      display: flex;
      gap: 0.45rem;
      align-items: center;
    }

    .section-list__search {
      flex: 1;
      max-width: 180px;
      padding: 0.4rem 0.55rem;
      border-radius: 8px;
      border: 1px solid #d3dae5;
      font-size: 0.9rem;
    }

    .section-cards {
      flex: 1;
      overflow: auto;
      padding: 0.4rem;
      display: flex;
      flex-direction: column;
      gap: 0.4rem;
      background: #f9fbff;
    }

    .section-card {
      border: 1px solid #e1e6ef;
      border-radius: 10px;
      background: #fff;
      padding: 0.55rem 0.65rem;
      display: flex;
      align-items: center;
      gap: 0.55rem;
      cursor: pointer;
      transition: border-color var(--transition-fast), box-shadow var(--transition-fast), transform var(--transition-fast);
    }

    .section-card:hover {
      border-color: var(--tick-blue);
      box-shadow: 0 2px 6px rgba(0,0,0,0.05);
    }

    .section-card--active {
      border-color: var(--tick-blue);
      box-shadow: 0 0 0 1px rgba(20,160,244,0.4);
      background: #f0f8ff;
    }

    .section-card__color {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      border: 1px solid #cbd4df;
      flex: 0 0 auto;
    }

    .section-card__body {
      display: flex;
      flex-direction: column;
      flex: 1;
      min-width: 0;
      gap: 0.1rem;
    }

    .section-card__name {
      font-weight: 600;
      font-size: 0.9rem;
      color: #243743;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .section-card__meta {
      display: flex;
      gap: 0.5rem;
      font-size: 0.78rem;
      color: #5b6673;
    }

    .section-editor {
      background: #fff;
      border: 1px solid #e1e6ef;
      border-radius: 10px;
      padding: 0.85rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      box-shadow: 0 4px 16px rgba(0,0,0,0.04);
      overflow: hidden;
    }

    .section-editor__grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 0.6rem;
    }

    .section-editor__field input,
    .section-editor__field select {
      width: 100%;
      padding: 0.45rem 0.6rem;
      border-radius: 8px;
      border: 1px solid #cdd3e0;
      font-size: 0.9rem;
    }

    .section-editor__rows {
      flex: 1;
      background: #f8fbff;
      border: 1px dashed #d0d9e8;
      border-radius: 10px;
      padding: 0.6rem;
      overflow: auto;
      display: none;
      flex-direction: column;
      gap: 0.5rem;
      height: 0;
      padding: 0;
      border: 0;
    }

    .section-preview {
      background: #f8fbff;
      border: 1px solid #d0d9e8;
      border-radius: 10px;
      padding: 0.6rem 0.8rem;
      display: flex;
      flex-direction: column;
      gap: 0.4rem;
      flex: 0 0 auto;
      min-height: 260px;
      max-height: 320px;
    }

    .section-preview__header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      font-size: 0.9rem;
      font-weight: 600;
      color: #2e3c47;
    }

    .section-preview__canvas {
      width: 100%;
      height: 100%;
      min-height: 240px;
      max-height: 320px;
      border-radius: 8px;
      background: linear-gradient(180deg, #ffffff, #f0f5fb);
      border: 1px solid #d8e1ed;
      box-shadow: inset 0 1px 2px rgba(0,0,0,0.04);
    }

    /* Ny layout-modal */
    #newLayoutOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.35);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }
    #newLayoutModal {
      background: #fff;
      border-radius: 12px;
      padding: 1rem;
      width: min(520px, 92vw);
      box-shadow: 0 10px 30px rgba(0,0,0,0.12);
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }
    #newLayoutModal h3 {
      margin: 0;
      font-size: 1.1rem;
      color: #1f2b35;
    }
    .new-layout-field {
      display: flex;
      flex-direction: column;
      gap: 0.2rem;
      font-size: 0.9rem;
    }
    .new-layout-field input {
      padding: 0.55rem 0.65rem;
      border-radius: 8px;
      border: 1px solid #cdd3e0;
      font-size: 0.95rem;
    }
    .new-layout-actions {
      display: flex;
      justify-content: flex-end;
      gap: 0.5rem;
    }

    .row-card {
      background: #fff;
      border: 1px solid #e1e6ef;
      border-radius: 10px;
      padding: 0.55rem 0.6rem;
      display: flex;
      flex-direction: column;
      gap: 0.4rem;
      box-shadow: 0 1px 4px rgba(0,0,0,0.03);
    }

    .row-card__header {
      display: flex;
      align-items: center;
      gap: 0.4rem;
    }

    .row-card__name {
      flex: 1;
      padding: 0.35rem 0.5rem;
      border-radius: 8px;
      border: 1px solid #d3dae5;
      font-size: 0.88rem;
    }

    .row-card__actions {
      display: flex;
      gap: 0.35rem;
      align-items: center;
    }

    .row-card__controls {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.35rem;
      flex-wrap: wrap;
    }

    .row-card__counter {
      display: flex;
      align-items: center;
      gap: 0.35rem;
      font-size: 0.84rem;
      color: #243743;
    }

    .row-card__index {
      width: 48px;
      padding: 0.3rem 0.4rem;
      border-radius: 8px;
      border: 1px solid #d3dae5;
      text-align: center;
      font-size: 0.9rem;
    }

    .row-card__line {
      display: flex;
      align-items: center;
      gap: 0.35rem;
      flex-wrap: wrap;
    }

    .row-card__chips {
      display: flex;
      flex-wrap: wrap;
      gap: 0.25rem;
    }

    .seat-chip {
      background: #f1f5fb;
      border: 1px solid #d6deed;
      border-radius: 50%;
      width: 30px;
      height: 30px;
      font-size: 0.82rem;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.2rem;
      cursor: default;
      padding: 0;
    }

    .seat-chip input {
      border: none;
      background: transparent;
      width: 20px;
      font-size: 0.82rem;
      text-align: center;
      color: #243743;
    }

    .seat-chip input:focus {
      outline: none;
    }

    .seat-chip__remove {
      border: none;
      background: transparent;
      color: #c12e44;
      cursor: pointer;
      font-size: 0.85rem;
      padding: 0;
    }

    .seat-chip--gap {
      background: #fff7e6;
      border-style: dashed;
      color: #c27c2c;
      width: 28px;
      height: 28px;
      justify-content: center;
      font-weight: 700;
    }

    .section-editor__footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.5rem;
    }

    .section-hint {
      font-size: 0.8rem;
      color: #5b6673;
    }

    .row-textarea {
      width: 100%;
      min-height: 160px;
      border: 1px solid #cdd3e0;
      border-radius: 10px;
      padding: 0.55rem;
      font-family: var(--font-mono);
      font-size: 0.9rem;
      resize: vertical;
      background: #f8fbff;
    }

    .section-errors {
      color: #c12e44;
      font-size: 0.82rem;
      margin-top: 0.35rem;
      white-space: pre-line;
    }

    /* ---------- Vänster verktygspalett ---------- */

    #left-toolbar {
      border: none;
      background: transparent;
      padding: 0;
      display: flex;
      flex-direction: column;
    }

    #left-toolbar .c-card {
      flex: 1;
      gap: 0.75rem;
    }

    #toolButtons {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
    }

    .tool-button {
      width: 100%;
      text-align: left;
    }

    .tool-button.active {
      /* kopplad till JS .active-klassen */
      background: rgba(124,208,255,0.20);
      border-color: var(--tick-blue);
      color: var(--tick-blue-dark);
      box-shadow: 0 0 0 1px rgba(20,160,244,0.5);
    }

    #selectionModeGroup {
      margin-top: 0.25rem;
    }

    .help-text {
      font-size: 0.78rem;
      color: var(--tick-grey-dark);
      line-height: 1.5;
      padding: 0.6rem 0.7rem;
      border-radius: 8px;
      background: rgba(219,224,228,0.4);
    }

    .help-text strong {
      font-family: var(--font-mono);
      font-size: 0.76rem;
      background: rgba(255,255,255,0.6);
      padding: 0 0.25rem;
      border-radius: 4px;
    }

    /* ---------- Höger panel ---------- */

    #right-panels {
      padding: 0;
      border: none;
    }

    #right-panels .c-card {
      gap: 0.5rem;
    }

    #info-panel {
      font-size: 0.85rem;
      line-height: 1.4;
      color: var(--tick-grey-dark);
    }

    #info-panel div {
      margin-bottom: 0.25rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    #info-panel strong {
      font-weight: 500;
    }

    #info-panel span {
      font-family: var(--font-mono);
      font-size: 0.8rem;
      background: rgba(219,224,228,0.6);
      padding: 0.1rem 0.35rem;
      border-radius: 999px;
    }

    /* Bakgrundsreglage */
    .bg-control {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .bg-control input[type="range"] {
      flex: 1;
    }

    /* Kod-modal */
    #codeModalOverlay {
      position: fixed;
      inset: 0;
      background: rgba(18, 32, 53, 0.65);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 20;
    }

    #codeModal {
      background: #fff;
      border-radius: 12px;
      width: min(1080px, 95vw);
      max-height: 85vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      box-shadow: 0 20px 50px rgba(0,0,0,0.25);
      border: 1px solid #dbe0e4;
    }

    #codeModal header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.9rem 1rem;
      border-bottom: 1px solid #e5e9ef;
    }

    #codeModal main {
      padding: 1rem;
      flex: 1;
      background: #f8f9fb;
      display: flex;
    }

    #codeModal textarea {
      width: 100%;
      height: 60vh;
      border-radius: 8px;
      border: 1px solid #cdd3e0;
      font-family: var(--font-mono);
      font-size: 11px;
      padding: 0.45rem;
      background: #fff;
      resize: vertical;
      white-space: pre;
      color: #27313b;
    }

    #codeModal footer {
      padding: 0.8rem 1rem;
      border-top: 1px solid #e5e9ef;
      background: #f7f9fc;
      display: flex;
      justify-content: flex-end;
      gap: 0.5rem;
    }

    /* ---------- Mitten: canvas + topp-bar + kod ---------- */

    #center-area {
      display: flex;
      flex-direction: column;
      min-width: 0;
      gap: 0.5rem;
    }

    #top-bar {
      padding: 0.45rem 0.75rem;
      border-radius: var(--radius-card);
      border: 1px solid var(--card-border);
      background: var(--card-bg);
      box-shadow: var(--card-shadow);
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      flex: 0 0 auto;
    }

    .top-bar__row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.75rem;
      flex-wrap: wrap;
    }

    #top-bar-left {
      display: flex;
      gap: 0.45rem;
      align-items: center;
    }

    #top-bar .file-info {
      font-size: 0.8rem;
      color: var(--tick-grey-dark);
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
    }

    #top-bar .file-info::before {
      content: "●";
      font-size: 0.6rem;
      color: var(--tick-green);
    }

    #top-bar button {
      /* overrida gamla knappar – nu Tickster-knappar */
      border: none;
    }

    #openFileBtnTop {
      /* primär handling */
      color: #fff;
    }

    #saveBtn {
      /* sekundär visuell – men fortfarande .c-button--primary i HTML om du vill */
      color: #243743;
    }

    #top-bar input[type="file"] {
      display: none;
    }

    #alignBar {
      width: 100%;
      flex-wrap: wrap;
      gap: 0.35rem;
    }

    #canvas-container {
      flex: 1 1 auto;
      background: #e2e7f0;
      border-radius: var(--radius-card);
      border: 1px solid var(--card-border);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0.75rem;
      cursor: default;
      overflow: hidden;
      box-shadow: var(--card-shadow);
    }

    #canvas-container.panning {
      cursor: grabbing;
    }

    #layoutCanvas {
      background: #f8f9fb;
      border-radius: 8px;
      border: 1px solid #cdd3e0;
      box-shadow: 0 0 0 1px #fff, 0 8px 18px rgba(0,0,0,0.07);
      display: block;
    }

    /* Kodruta nedtill */


    /* Tooltip */

    #tooltip {
      position: fixed;
      pointer-events: none;
      background: rgba(12, 28, 48, 0.96);
      color: #fff;
      padding: 6px 8px;
      border-radius: 6px;
      font-size: 11px;
      line-height: 1.4;
      box-shadow: 0 4px 10px rgba(0,0,0,0.35);
      display: none;
      z-index: 10;
      max-width: 260px;
      border: 1px solid rgba(124,208,255,0.4);
    }

    #tooltip strong {
      font-weight: 600;
      color: var(--tick-yellow-light);
    }
  </style>
</head>
<body>
  <div id="app">
    <!-- Vänster: verktyg -->
    <aside id="left-toolbar">
      <div class="c-card">
        <div class="c-card__header">
          <div class="c-card__title">Verktyg</div>
          <div class="c-card__subtitle u-font--small">Markera, flytta och panorera din arenalayout.</div>
        </div>

        <div id="toolButtons" class="c-toolbar">
          <button id="selectToolBtn" class="tool-button c-button c-button--ghost c-button--small c-button--active">
            Select (C)
          </button>
          <button id="moveToolBtn" class="tool-button c-button c-button--ghost c-button--small" disabled>
            Move (V)
          </button>
          <button id="rotateToolBtn" class="tool-button c-button c-button--ghost c-button--small" disabled>
            Rotate (R)
          </button>
          <button id="resizeToolBtn" class="tool-button c-button c-button--ghost c-button--small" disabled>
            Resize (Z)
          </button>
          <button id="bendToolBtn" class="tool-button c-button c-button--ghost c-button--small" disabled>
            Bend (B)
          </button>
          <button id="reshapeRowBtn" class="tool-button c-button c-button--ghost c-button--small" disabled>
            Reshape row (E)
          </button>
          <button id="resetRowBtn" class="tool-button c-button c-button--ghost c-button--small" disabled>
            Reset row (Q)
          </button>
          <button id="makeTableBtn" class="tool-button c-button c-button--ghost c-button--small" disabled>
            Make table (T)
          </button>
          <button id="deselectToolBtn" class="tool-button c-button c-button--ghost c-button--small">
            Deselect (CTRL+D)
          </button>
        </div>

        <div id="selectionModeGroup">
          <div class="u-font--small" style="text-transform:uppercase; letter-spacing:0.08em; color:#555; margin-bottom:0.3rem;">
            Markeringsnivå
          </div>
          <div class="c-toolbar">
            <button id="modeSectionBtn" class="tool-button c-button c-button--ghost c-button--small c-button--active">
              Section (S)
            </button>
            <button id="modeRowBtn" class="tool-button c-button c-button--ghost c-button--small">
              Row (D)
            </button>
            <button id="modeSeatBtn" class="tool-button c-button c-button--ghost c-button--small">
              Seat (F)
            </button>
          </div>
        </div>

        <div class="help-text">
          <div class="u-font--small" style="margin-bottom:0.25rem; font-weight:600;">Genvägar</div>
          Panna: <strong>CTRL + dra</strong><br/>
          Zoom: <strong>CTRL + scroll</strong><br/>
          Multi-select: <strong>SHIFT + klick</strong><br/>
          Ruta-markering: <strong>Dra utan CTRL</strong><br/>
          Ångra: <strong>CTRL + Z</strong>
        </div>
      </div>
    </aside>

    <!-- Mitten: canvas + kod -->
    <section id="center-area">
      <div id="top-bar">

        <div class="top-bar__row">
          <div id="top-bar-left" class="c-toolbar c-toolbar--horizontal">

            <button id="newLayoutBtn" class="c-button c-button--secondary c-button--icon-left" data-icon="">

              Skapa ny layout

            </button>

            <button id="openFileBtnTop" class="c-button c-button--primary c-button--icon-left" data-icon="">

              Öppna layout

            </button>

            <button id="saveBtn" class="c-button c-button--secondary c-button--icon-left" data-icon="" disabled>

              Spara layout

            </button>

            <button id="openSectionManagerBtn" class="c-button c-button--ghost c-button--small c-button--icon-left" data-icon="◎">

              Skapa sektioner

            </button>

            <input type="file" id="fileInput" accept=".tlt,.txt" />

          </div>

          <div class="file-info u-font--small" id="fileInfo">

            Ingen fil läst ännu.

          </div>
        </div>

        <div id="alignBar" class="c-toolbar c-toolbar--horizontal">
          <button id="alignTopBtn" class="c-button c-button--ghost c-button--small" title="Align top">Align Up</button>
          <button id="alignBottomBtn" class="c-button c-button--ghost c-button--small" title="Align bottom">Align Down</button>
          <button id="alignLeftBtn" class="c-button c-button--ghost c-button--small" title="Align left">Align Left</button>
          <button id="alignRightBtn" class="c-button c-button--ghost c-button--small" title="Align right">Align Right</button>
          <button id="alignCenterHBtn" class="c-button c-button--ghost c-button--small" title="Center horizontally">Center H</button>
          <button id="alignCenterVBtn" class="c-button c-button--ghost c-button--small" title="Center vertically">Center V</button>
        </div>

      </div>


      <div id="canvas-container">
        <canvas id="layoutCanvas"></canvas>
      </div>
    </section>

    <!-- Höger: paneler -->
    <aside id="right-panels">
      <div class="c-card">
        <div class="c-card__header">
          <div class="c-card__title">Paneler</div>
          <div class="c-card__subtitle u-font--small">Snabb överblick över layoutens omfattning.</div>
        </div>
        <div id="info-panel">
          <div>
            <strong>Platser:</strong>
            <span id="seatCount">0</span>
          </div>
          <div>
            <strong>Sektioner:</strong>
            <span id="sectionCount">0</span>
          </div>
          <div>
            <strong>Rader:</strong>
            <span id="rowCount">0</span>
          </div>
        </div>
      </div>

      <div class="c-card">
        <div class="c-card__header">
          <div class="c-card__title">Referensbakgrund</div>
          <div class="c-card__subtitle u-font--small">Visa en bild bakom platserna.</div>
        </div>
        <div class="c-toolbar">
          <button id="bgLoadBtn" class="c-button c-button--ghost c-button--small">Lägg till referensbakgrund</button>
          <label class="bg-control u-font--small">
            <input type="checkbox" id="bgEnabledToggle" />
            Aktivera bild
          </label>
          <label class="bg-control u-font--small">
            Opacitet
            <input type="range" id="bgOpacityRange" min="0" max="1" step="0.05" value="0.4" />
            <span id="bgOpacityValue" class="u-font--mono">0.40</span>
          </label>
          <label class="bg-control u-font--small">
            Skala
            <input type="range" id="bgScaleRange" min="0.1" max="10" step="0.1" value="1" />
            <span id="bgScaleValue" class="u-font--mono">1.0x</span>
          </label>
        </div>
      </div>

      <div class="c-card">
        <div class="c-card__header">
          <div class="c-card__title">Visning</div>
          <div class="c-card__subtitle u-font--small">Snabbt sätt att ändra hur platser visas.</div>
        </div>
        <div class="c-toolbar">
          <label class="bg-control u-font--small">
            <input type="checkbox" id="viewGrayToggle" />
            Gråskala (platser)
          </label>
          <label class="bg-control u-font--small">
            <input type="checkbox" id="viewHoverToggle" checked />
            Hover-info för platser
          </label>
          <label class="bg-control u-font--small">
            <input type="checkbox" id="viewSectionNamesToggle" />
            Visa sektionsnamn
          </label>
          <div class="u-font--small" style="display:flex; flex-direction:column; gap:0.35rem;">
            <div>Platsinfo (I)</div>
            <label class="bg-control">
              <input type="radio" name="seatLabelMode" id="viewSeatLabelNone" value="none" checked />
              Ingen platsinfo (standard)
            </label>
            <label class="bg-control">
              <input type="radio" name="seatLabelMode" id="viewSeatLabelRow" value="row" />
              Visa radnummer
            </label>
            <label class="bg-control">
              <input type="radio" name="seatLabelMode" id="viewSeatLabelSeat" value="seat" />
              Visa platsnummer
            </label>
          </div>
          <button id="openCodeModalBtn" class="c-button c-button--ghost c-button--small">Visa källkod</button>
        </div>
      </div>
    </aside>
  </div>

    <div id="tooltip"></div>
  <input type="file" id="bgFileInput" accept="image/*" style="display:none" />
  <div id="sectionManagerOverlay">
    <div class="section-manager">
      <header class="section-manager__header">
        <div class="section-manager__title">Sektioner</div>
        <div class="c-toolbar c-toolbar--horizontal" style="gap:0.35rem;">
          <span id="sectionDirtyFlag" class="section-hint">Ej sparade ändringar</span>
        </div>
      </header>
      <div class="section-manager__body">
        <aside class="section-list">
          <div class="section-list__header">
            <input id="sectionSearchInput" class="section-list__search" placeholder="Sök sektion..." />
            <button id="sectionCreateBtn" class="c-button c-button--primary c-button--small" title="Ny sektion">+ Ny</button>
          </div>
          <div id="sectionCards" class="section-cards"></div>
        </aside>
        <div class="section-editor">
        <div class="section-editor__grid">
          <label class="section-editor__field">
            <div class="u-font--small" style="margin-bottom:0.25rem;">Sektion-ID</div>
            <input id="sectionEditId" type="text" placeholder="1.1" />
          </label>
            <label class="section-editor__field">
              <div class="u-font--small" style="margin-bottom:0.25rem;">Namn</div>
              <input id="sectionEditName" type="text" placeholder="T ex Sektion A" />
            </label>
            <label class="section-editor__field">
              <div class="u-font--small" style="margin-bottom:0.25rem;">Färg</div>
              <input id="sectionEditColor" type="color" value="#14a0f4" />
            </label>
          </div>

          <div>
            <div class="u-font--small" style="margin-bottom:0.25rem;">Rader (format: Radnamn: 1,10|20,30)</div>
            <textarea id="sectionRowText" class="row-textarea" placeholder="Rad A: 1,10&#10;Rad B: 20,30"></textarea>
            <div class="c-toolbar c-toolbar--horizontal" style="margin-top:0.35rem; gap:0.35rem;">
              <button id="parseRowsBtn" class="c-button c-button--ghost c-button--small">Uppdatera rader</button>
              <span class="section-hint">Varje rad per radbrytning. Intervall separeras med | och använder start,slut.</span>
            </div>
            <div id="sectionRowErrors" class="section-errors"></div>

          </div>



          <div class="section-preview">

            <div class="section-preview__header">

              <span>WYSIWYG-förhandsvisning</span>

              <span class="section-hint">Speglas av inmatningen ovan.</span>

            </div>

            <canvas id="sectionPreviewCanvas" class="section-preview__canvas"></canvas>

          </div>



          <div class="section-editor__rows" id="sectionRowsEditor"></div>

          <div class="section-editor__footer">
            <div class="section-hint" id="sectionEditHint">Ny sektion – du kan lägga till rader och platser.</div>
            <div class="c-toolbar c-toolbar--horizontal">
              <button id="sectionManagerClose" class="c-button c-button--ghost c-button--small">Stäng</button>
              <button id="sectionSaveBtn" class="c-button c-button--primary c-button--small">Spara sektion</button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div id="newLayoutOverlay">
    <div id="newLayoutModal">
      <h3>Skapa ny layout</h3>
      <div class="new-layout-field">
        <label for="newProjectName">Projektnamn</label>
        <input id="newProjectName" type="text" placeholder="T ex ArenaLayout2026" />
      </div>
      <div class="new-layout-field">
        <label for="newVenueId">VenueId</label>
        <input id="newVenueId" type="text" placeholder="Ange VenueId" />
      </div>
      <div class="section-hint">Skapar .tlt, .tlc och .tpr (prisregioner läggs till senare).</div>
      <div class="new-layout-actions">
        <button id="newLayoutCancel" class="c-button c-button--ghost c-button--small">Avbryt</button>
        <button id="newLayoutStart" class="c-button c-button--primary c-button--small">Börja skapa</button>
      </div>
    </div>
  </div>

  <div id="codeModalOverlay">
    <div id="codeModal">
      <header>
        <h3>Källkod (.tlt)</h3>
        <button id="codeModalClose" class="c-button c-button--ghost c-button--small">Stäng</button>
      </header>
      <main>
        <textarea
          id="code-pane"
          class="u-font--mono u-font--smaller"
          placeholder="Här visas och kan du ändra din .tlt-källkod"
        ></textarea>
      </main>
      <footer>
        <button id="codeModalApply" class="c-button c-button--primary c-button--small" disabled>Uppdatera och stäng</button>
      </footer>
    </div>
  </div>


<script>
  // --- Globala variabler ---
  const canvas = document.getElementById("layoutCanvas");
  const canvasContainer = document.getElementById("canvas-container");
  const ctx = canvas.getContext("2d");

  const codePane = document.getElementById("code-pane");
  const alignTopBtn = document.getElementById("alignTopBtn");
  const alignBottomBtn = document.getElementById("alignBottomBtn");
  const alignLeftBtn = document.getElementById("alignLeftBtn");
  const alignRightBtn = document.getElementById("alignRightBtn");
  const alignCenterHBtn = document.getElementById("alignCenterHBtn");
  const alignCenterVBtn = document.getElementById("alignCenterVBtn");

  const openFileBtnTop = document.getElementById("openFileBtnTop");
  const openSectionManagerBtn = document.getElementById("openSectionManagerBtn");
  const saveBtn = document.getElementById("saveBtn");
  const fileInput = document.getElementById("fileInput");
  const fileInfo = document.getElementById("fileInfo");

  const selectToolBtn = document.getElementById("selectToolBtn");
  const moveToolBtn = document.getElementById("moveToolBtn");
  const rotateToolBtn = document.getElementById("rotateToolBtn");
  const resizeToolBtn = document.getElementById("resizeToolBtn");
  const bendToolBtn = document.getElementById("bendToolBtn");
  const reshapeRowBtn = document.getElementById("reshapeRowBtn");
  const resetRowBtn = document.getElementById("resetRowBtn");
  const makeTableBtn = document.getElementById("makeTableBtn");
  const deselectToolBtn = document.getElementById("deselectToolBtn");

  const modeSectionBtn = document.getElementById("modeSectionBtn");
  const modeRowBtn = document.getElementById("modeRowBtn");
  const modeSeatBtn = document.getElementById("modeSeatBtn");

  const seatCountEl = document.getElementById("seatCount");
  const sectionCountEl = document.getElementById("sectionCount");
  const rowCountEl = document.getElementById("rowCount");

  const tooltipEl = document.getElementById("tooltip");

  const bgFileInput = document.getElementById("bgFileInput");
  const bgLoadBtn = document.getElementById("bgLoadBtn");
  const bgEnabledToggle = document.getElementById("bgEnabledToggle");
  const bgOpacityRange = document.getElementById("bgOpacityRange");
  const bgOpacityValue = document.getElementById("bgOpacityValue");
  const bgScaleRange = document.getElementById("bgScaleRange");
  const bgScaleValue = document.getElementById("bgScaleValue");
  const viewGrayToggle = document.getElementById("viewGrayToggle");
  const viewHoverToggle = document.getElementById("viewHoverToggle");
  const viewSectionNamesToggle = document.getElementById("viewSectionNamesToggle");
  const viewSeatLabelNone = document.getElementById("viewSeatLabelNone");
  const viewSeatLabelRow = document.getElementById("viewSeatLabelRow");
  const viewSeatLabelSeat = document.getElementById("viewSeatLabelSeat");
  const openCodeModalBtn = document.getElementById("openCodeModalBtn");
  const codeModalOverlay = document.getElementById("codeModalOverlay");
  const codeModalClose = document.getElementById("codeModalClose");
  const codeModalApply = document.getElementById("codeModalApply");
  const codeModalTextarea = document.getElementById("code-pane");
  const newLayoutBtn = document.getElementById("newLayoutBtn");
  const newLayoutOverlay = document.getElementById("newLayoutOverlay");
  const newLayoutStart = document.getElementById("newLayoutStart");
  const newLayoutCancel = document.getElementById("newLayoutCancel");
  const newProjectName = document.getElementById("newProjectName");
  const newVenueId = document.getElementById("newVenueId");
  const sectionManagerOverlay = document.getElementById("sectionManagerOverlay");
  const sectionManagerClose = document.getElementById("sectionManagerClose");
  const sectionCardsEl = document.getElementById("sectionCards");
  const sectionSearchInput = document.getElementById("sectionSearchInput");
  const sectionCreateBtn = document.getElementById("sectionCreateBtn");
  const sectionEditId = document.getElementById("sectionEditId");
  const sectionEditName = document.getElementById("sectionEditName");
  const sectionEditColor = document.getElementById("sectionEditColor");
  const sectionRowsEditor = document.getElementById("sectionRowsEditor");
  const addRowInlineBtn = document.getElementById("addRowInlineBtn");
  const sectionSaveBtn = document.getElementById("sectionSaveBtn");
  const sectionEditHint = document.getElementById("sectionEditHint");
  const sectionDuplicateBtn = document.getElementById("sectionDuplicateBtn");
  const sectionDirtyFlag = document.getElementById("sectionDirtyFlag");
  const sectionRowText = document.getElementById("sectionRowText");
  const parseRowsBtn = document.getElementById("parseRowsBtn");
  const sectionRowErrors = document.getElementById("sectionRowErrors");
  const sectionPreviewCanvas = document.getElementById("sectionPreviewCanvas");
  const sectionRawText = new Map();

  let seats = [];
  let outlines = [];
  let sectionNames = new Map();
  let layoutBounds = null;
  let backgroundState = {
    dataUrl: "",
    img: null,
    enabled: false,
    opacity: 0.4,
    scale: 1,
    originX: 0,
    originY: 0
  };
  let seatLabelMode = "none";
  let lastDirectoryHandle = null;

  function setSeatLabelMode(mode, syncUI = true) {
    seatLabelMode = mode || "none";
    if (syncUI) {
      if (mode === "none" && viewSeatLabelNone) viewSeatLabelNone.checked = true;
      if (mode === "row" && viewSeatLabelRow) viewSeatLabelRow.checked = true;
      if (mode === "seat" && viewSeatLabelSeat) viewSeatLabelSeat.checked = true;
    }
    renderCanvas();
  }

  async function tryGetDirectoryHandle(handle) {
    if (!handle) return null;
    if (handle.kind === "directory") return handle;
    if (typeof handle.getParent === "function") {
      try {
        const dir = await handle.getParent();
        if (dir?.kind === "directory") return dir;
      } catch (_) {}
    }
    return null;
  }
  let renderGrayscale = false;
  let showHoverInfo = true;
  let showSectionNames = false;
  let sectionColors = new Map();
  let sectionDrafts = [];
  let activeSectionDraftId = null;
  let sectionDirty = false;

  // Kamera/transform
  let translateX = 0;
  let translateY = 0;
  let scale = 1;

  // Pan
  let isPanning = false;
  let panStartX = 0;
  let panStartY = 0;
  let panStartTranslateX = 0;
  let panStartTranslateY = 0;

  // Drag-flytt av markerade
  let isDraggingSelection = false;
  let dragStartWorldX = 0;
  let dragStartWorldY = 0;
  let dragStartSnapshot = null; // startpositioner för alla seats vid move

  // Rotation av markerade
  let isRotatingSelection = false;
  let rotateStartSnapshot = null;
  let rotateSnapshotById = null;
  let rotatePivot = null;
  let rotateStartAngle = 0;
  let hasRotatedDuringDrag = false;

  // Resize av markerade
  let isResizingSelection = false;
  let resizeStartSnapshot = null;
  let resizeSnapshotById = null;
  let resizePivot = null;
  let resizeStartBounds = null;
  let resizeHandleId = null;
  let resizeStartVector = null;
  let hasResizedDuringDrag = false;

  // Bend av rader
  let isBendingSelection = false;
  let bendStartSnapshot = null;
  let bendControlPoint = null; // anchor for quadratic bend
  let bendRowsData = null;
  let hasBentDuringDrag = false;
  let bendDragTarget = null;     // "anchor" | "start" | "end"
  let bendActiveRowId = null;

  // Reshape row
  let isReshapingRow = false;
  let reshapeDragTarget = null; // "start" | "end"
  let reshapeStartSnapshot = null;
  let reshapeSnapshotById = null;
  let reshapeRowSeats = null;
  let reshapePivotSeatId = null;

  // Ruta-markering
  let selectionRectActive = false;
  let rectStartCanvasX = 0;
  let rectStartCanvasY = 0;
  let rectEndCanvasX = 0;
  let rectEndCanvasY = 0;

  // Verktyg & markeringsläge
  let currentTool = "select";   // "select" | "move" | "rotate" | "resize" | "bend" | "reshape"
  let selectionMode = "section";   // "section" | "row" | "seat"

  // Smart rendering / prestanda
  let lastVisibleSeatCount = 0;
  const RECT_DOT_THRESHOLD = 2500; // över detta: små fyrkanter
  const HOVER_VISIBLE_LIMIT = 4000; // över detta: ingen tooltip/hover-info

  let hoverSeat = null;

  // Historik (undo, inkl. markering)
  let history = [];
  let historyIndex = -1;

  // Filhantering / kodsynk
  let currentFileHandle = null;
  let currentFileName = "";
  let hasUnsavedChanges = false;

  let originalLines = [];
  let seatIdToLineIndex = new Map();

  const MIN_SEAT_SCREEN_RADIUS = 3;  // px vid långt utzoomat
  const BASE_WORLD_RADIUS = 50;      // i "layoutvärlden"
  const SESSION_STORAGE_KEY = "arenaEditorSessionV1";

  const DB_NAME = "arenaEditorFileHandles";
  const DB_VERSION = 1;
  const DB_STORE = "handles";

  const supportsOpenPicker = typeof window.showOpenFilePicker === "function";
  const supportsSavePicker = typeof window.showSaveFilePicker === "function";


  // --- Canvas-storlek ---
  function resizeCanvas() {
    const rect = canvasContainer.getBoundingClientRect();
    const padding = 12;
    canvas.width = Math.max(100, rect.width - padding * 2);
    canvas.height = Math.max(100, rect.height - padding * 2);
    renderCanvas();
  }

  window.addEventListener("resize", resizeCanvas);
  resizeCanvas();

  // --- Utilities: world <-> screen ---
  function worldToScreen(wx, wy) {
    return {
      x: wx * scale + translateX,
      y: wy * scale + translateY
    };
  }

  function screenToWorld(sx, sy) {
    return {
      worldX: (sx - translateX) / scale,
      worldY: (sy - translateY) / scale
    };
  }

  // --- Färger per sektion ---
  function rebuildSectionColors() {
    sectionColors.clear();
    const uniqueSections = Array.from(new Set(
      seats.map(s => s.sectionId).filter(Boolean)
    )).sort();

    const goldenAngle = 137.508;
    uniqueSections.forEach((secId, i) => {
      const hue = (i * goldenAngle) % 360;
      const color = `hsl(${hue}, 65%, 55%)`;
      sectionColors.set(secId, color);
    });
  }

  function sectionIdToOutlineCode(sectionId) {
    if (!sectionId) return "0";
    const parts = String(sectionId).split(".");
    const major = parseInt(parts[0], 10);
    const minor = parseInt(parts[1] || "0", 10);
    if (!Number.isFinite(major)) return String(sectionId);
    const minorStr = Number.isFinite(minor) ? String(minor).padStart(2, "0") : "00";
    return `${major}${minorStr}000000000`;
  }

  function outlineCodeToSectionId(code) {
    if (!code) return null;
    const codeStr = String(code);
    const trimmed = codeStr.replace(/0{9}$/, "");
    if (trimmed.length < 2) return codeStr;
    const majorStr = trimmed.slice(0, -2);
    const minorStr = trimmed.slice(-2);
    const major = parseInt(majorStr, 10);
    const minor = parseInt(minorStr, 10);
    if (!Number.isFinite(major) || !Number.isFinite(minor)) return codeStr;
    return `${major}.${minor}`;
  }

  // --- Parse av .tlt ---
  function parseTlt(text) {
    seats = [];
    outlines = [];
    sectionNames = new Map();
    originalLines = text.split(/\r?\n/);
    seatIdToLineIndex = new Map();

    const sections = new Map();
    const rows = new Map();

    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;

    for (let lineIndex = 0; lineIndex < originalLines.length; lineIndex++) {
      const line = originalLines[lineIndex].trim();
      if (!line) continue;

      // Outline
      if (line.includes("<Outline|")) {
        const polyIndex = line.indexOf("[Poly|");
        if (polyIndex >= 0) {
          const beforePoly = line.slice(0, polyIndex);
          const suffix = line.includes("|]>") ? "|]>" : (line.includes("]>") ? "]>" : "]");

          let sectionId = null;
          let sectionNameFromLine = null;
          let prefixTokens = [];
          const outlineStart = line.indexOf("<Outline|");
          if (outlineStart >= 0 && outlineStart < polyIndex) {
            const prefixPart = line.slice(outlineStart + "<Outline|".length, polyIndex);
            prefixTokens = prefixPart.split("|").filter(Boolean);
            if (prefixTokens.length >= 1) sectionId = outlineCodeToSectionId(prefixTokens[0]) || prefixTokens[0];
            if (prefixTokens.length >= 2) sectionNameFromLine = prefixTokens[1];
          }
          if (!sectionId) {
            const sectionMatch = line.match(/SectionId=([^|]+)/i);
            sectionId = sectionMatch ? sectionMatch[1] : null;
          }

          let polyPart = line.slice(polyIndex + 6);
          polyPart = polyPart.replace(/[\]>]/g, "");
          const tokens = polyPart.split("|");
          const coords = [];
          for (let i = 3; i < tokens.length; i++) {
            const t = tokens[i];
            if (!t) continue;
            const [xs, ys] = t.split(",");
            const x = parseFloat(xs);
            const y = parseFloat(ys);
            if (Number.isFinite(x) && Number.isFinite(y)) {
              coords.push({ x, y });
            }
          }
          if (coords.length > 1) {
            outlines.push({
          sectionId,
          sectionName: sectionNameFromLine || sectionNames.get(sectionId) || "",
          coords,
          lineIndex,
          beforePoly,
          suffix,
              headerTokens: tokens.slice(0, 3),
              prefixTokens
            });
          }
        }
        continue;
      }

      const pipeIdx = line.indexOf("|");
      if (pipeIdx < 0) continue;
      const timestamp = line.slice(0, pipeIdx);
      const rest = line.slice(pipeIdx + 1);
      const parts = rest.split("|");
      if (parts.length < 1) continue;
      const cmd = parts[0];

      const kv = {};
      for (let i = 1; i < parts.length; i++) {
        const seg = parts[i];
        const eqIdx = seg.indexOf("=");
        if (eqIdx > -1) {
          const key = seg.slice(0, eqIdx);
          const val = seg.slice(eqIdx + 1);
          kv[key] = val;
        }
      }

      if (cmd === "SectionAdd") {
        const sectionId = kv["SectionId"];
        const name = kv["Name"] || "";
        if (sectionId) {
          sections.set(sectionId, name);
          sectionNames.set(sectionId, name);
        }
      } else if (cmd === "RowAdd") {
        const rowId = kv["RowId"];
        const name = kv["Name"] || "";
        if (rowId) rows.set(rowId, name);
      } else if (cmd === "SeatAdd") {
        const seatId = kv["SeatId"];
        if (!seatId) continue;

        const name = kv["Name"] || "";
        const cx = parseFloat(kv["CenterX"]);
        const cy = parseFloat(kv["CenterY"]);
        if (!Number.isFinite(cx) || !Number.isFinite(cy)) continue;

        const rotation = parseFloat(kv["Rotation"] || "0");
        const width = parseFloat(kv["Width"] || "100");
        const entryVia = kv["EntryVia"] ?? "-";
        const goodness = kv["Goodness"] ?? "0";
        const attribute = kv["Attribute"] || "";

        let sectionId = null;
        let rowId = null;
        const idParts = seatId.split(".");
        if (idParts.length >= 2) {
          sectionId = idParts[0] + "." + idParts[1];
        }
        if (idParts.length >= 3) {
          rowId = idParts[0] + "." + idParts[1] + "." + idParts[2];
        }

        const sectionName = sectionId ? (sections.get(sectionId) || "") : "";
        const rowName = rowId ? (rows.get(rowId) || "") : "";

        const seat = {
          seatId,
          name,
          sectionId,
          rowId,
          sectionName,
          rowName,
          centerX: cx,
          centerY: cy,
          vx: cx,
          vy: cy,
          radius: 10, // grund i world (justeras i render)
          rotation,
          width,
          entryVia,
          goodness,
          attribute,
          timestamp,
          selected: false,
          lineIndex
        };

        seats.push(seat);
        seatIdToLineIndex.set(seatId, lineIndex);

        if (cx < minX) minX = cx;
        if (cx > maxX) maxX = cx;
        if (cy < minY) minY = cy;
        if (cy > maxY) maxY = cy;
      }
    }

    // Info-panel
    seatCountEl.textContent = seats.length.toString();
    const uniqueSections = new Set(seats.map(s => s.sectionId).filter(Boolean));
    const uniqueRows = new Set(seats.map(s => s.rowId).filter(Boolean));
    sectionCountEl.textContent = uniqueSections.size.toString();
    rowCountEl.textContent = uniqueRows.size.toString();

    rebuildSectionColors();
    const outlinesChangedOnLoad = syncOutlinesIntoOriginalLines();
    if (outlinesChangedOnLoad) {
      const newText = originalLines.join("\n");
      if (codePane.value !== newText) {
        codePane.value = newText;
      }
    }

    // Fit to canvas
    if (seats.length > 0 && Number.isFinite(minX) && Number.isFinite(maxX)) {
      const paddingWorld = 50;
      const widthWorld = (maxX - minX) + paddingWorld * 2;
      const heightWorld = (maxY - minY) + paddingWorld * 2;
      const cxWorld = (minX + maxX) / 2;
      const cyWorld = (minY + maxY) / 2;

      const scaleX = canvas.width / widthWorld;
      const scaleY = canvas.height / heightWorld;
      scale = Math.min(scaleX, scaleY);

      translateX = canvas.width / 2 - cxWorld * scale;
      translateY = canvas.height / 2 - cyWorld * scale;
    }

    // Historik: nollställ och lägg första snapshot
    history = [];
    historyIndex = -1;
    pushHistorySnapshot();

    renderCanvas();

    hasUnsavedChanges = outlinesChangedOnLoad;
    updateSaveButton();

    saveSessionToLocalStorage();
    return outlinesChangedOnLoad;
  }

  // --- Historik (undo) – nu inkl. markering ---
  function captureSeatState() {
    return seats.map(s => ({
      seatId: s.seatId,
      vx: s.vx,
      vy: s.vy,
      centerX: s.centerX,
      centerY: s.centerY,
      selected: s.selected
    }));
  }

  function applySeatState(state) {
    const byId = new Map();
    for (const s of seats) byId.set(s.seatId, s);

    let anyPositionChanged = false;
    for (const snap of state) {
      const s = byId.get(snap.seatId);
      if (!s) continue;
      if (s.centerX !== snap.centerX || s.centerY !== snap.centerY) {
        anyPositionChanged = true;
      }
      s.vx = snap.vx;
      s.vy = snap.vy;
      s.centerX = snap.centerX;
      s.centerY = snap.centerY;
      if (typeof snap.selected === "boolean") {
        s.selected = snap.selected;
      }
    }

    renderCanvas();

    // Markera ändringar & kod om positionerna ändrats
    if (anyPositionChanged) {
      hasUnsavedChanges = true;
      updateCodeFromSeats();
    }
    updateSaveButton();
    updateMoveButtonState();
  }

  function pushHistorySnapshot() {
    if (!seats.length) return;
    const snapshot = captureSeatState();
    history = history.slice(0, historyIndex + 1);
    history.push(snapshot);
    historyIndex = history.length - 1;
  }

  function undoLast() {
    if (historyIndex > 0) {
      historyIndex--;
      const state = history[historyIndex];
      applySeatState(state);
    }
  }

  // --- tlt-uppbyggnad vid flyttar ---
  function formatNumber(num) {
    if (!Number.isFinite(num)) return "0";
    if (Math.abs(num - Math.round(num)) < 1e-6) return String(Math.round(num));
    let s = num.toFixed(5);
    s = s.replace(/0+$/, "").replace(/\.$/, "");
    return s;
  }

  function buildTimestamp() {
    const d = new Date();
    const pad = (v, len = 2) => String(v).padStart(len, "0");
    return (
      d.getFullYear().toString() +
      pad(d.getMonth() + 1) +
      pad(d.getDate()) +
      pad(d.getHours()) +
      pad(d.getMinutes()) +
      pad(d.getSeconds()) +
      pad(d.getMilliseconds(), 3)
    );
  }

  function buildSeatLine(seat) {
    const timestamp = seat.timestamp || "";
    const widthStr = seat.width != null ? seat.width : 100;
    const rotationStr = seat.rotation != null ? seat.rotation : 0;
    const entryStr = seat.entryVia != null ? seat.entryVia : "-";
    const goodStr = seat.goodness != null ? seat.goodness : 0;
    const cxStr = formatNumber(seat.centerX);
    const cyStr = formatNumber(seat.centerY);

    let line = `${timestamp}|SeatAdd|SeatId=${seat.seatId}|Name=${seat.name}` +
      `|CenterX=${cxStr}|CenterY=${cyStr}|Width=${widthStr}|Rotation=${rotationStr}` +
      `|EntryVia=${entryStr}|Goodness=${goodStr}`;
    if (seat.attribute) {
      line += `|Attribute=${seat.attribute}`;
    }
    return line;
  }

  function computeSectionOutlinesFromSeats(padding = 0) {
    const boundsBySection = new Map();
    for (const s of seats) {
      if (!s.sectionId) continue;
      let b = boundsBySection.get(s.sectionId);
      if (!b) {
        b = { minX: s.centerX, maxX: s.centerX, minY: s.centerY, maxY: s.centerY };
        boundsBySection.set(s.sectionId, b);
      } else {
        b.minX = Math.min(b.minX, s.centerX);
        b.maxX = Math.max(b.maxX, s.centerX);
        b.minY = Math.min(b.minY, s.centerY);
        b.maxY = Math.max(b.maxY, s.centerY);
      }
    }

    layoutBounds = null;
    for (const b of boundsBySection.values()) {
      if (!layoutBounds) {
        layoutBounds = { ...b };
      } else {
        layoutBounds.minX = Math.min(layoutBounds.minX, b.minX);
        layoutBounds.maxX = Math.max(layoutBounds.maxX, b.maxX);
        layoutBounds.minY = Math.min(layoutBounds.minY, b.minY);
        layoutBounds.maxY = Math.max(layoutBounds.maxY, b.maxY);
      }
    }

    const result = [];
    for (const [sectionId, b] of boundsBySection.entries()) {
      const coords = [
        { x: b.minX - padding, y: b.minY - padding },
        { x: b.maxX + padding, y: b.minY - padding },
        { x: b.maxX + padding, y: b.maxY + padding },
        { x: b.minX - padding, y: b.maxY + padding }
      ];
      result.push({
        sectionId,
        sectionName: sectionNames.get(sectionId) || "",
        coords
      });
    }
    return result;
  }

  function buildOutlineLine(sectionId, sectionName, coords, template) {
    const headerTokens = (template && Array.isArray(template.headerTokens) && template.headerTokens.length)
      ? [...template.headerTokens]
      : ["1", "10", "#FFD3D3D3"];
    while (headerTokens.length < 3) headerTokens.push("0");
    if (headerTokens.length > 3) headerTokens.length = 3;

    const defaultTimestamp = seats[0]?.timestamp || buildTimestamp();
    const timePrefixRaw = template?.beforePoly
      ? template.beforePoly.split("<Outline")[0]
      : `${defaultTimestamp}`;
    const timePrefix = timePrefixRaw.replace(/\|$/, "");

    const sectionCode = sectionIdToOutlineCode(sectionId);
    const typeToken = (template && Array.isArray(template.prefixTokens) && template.prefixTokens.length >= 3)
      ? template.prefixTokens[2]
      : "1";
    const beforePoly = `${timePrefix}<Outline|${sectionCode}|${sectionName || ""}|${typeToken}|`;
    const suffix = template?.suffix || "|]>";
    const coordTokens = coords.map(c => `${Math.round(c.x)},${Math.round(c.y)}`);
    const allTokens = [...headerTokens, ...coordTokens].join("|");
    return `${beforePoly}[Poly|${allTokens}${suffix}`;
  }

  function syncOutlinesIntoOriginalLines() {
    if (!originalLines || !originalLines.length) return false;

    const computed = computeSectionOutlinesFromSeats(20);
    const existingBySection = new Map();
    for (const o of outlines) {
      if (!o.sectionId) continue;
      existingBySection.set(o.sectionId, o);
    }

    const usedLineIndexes = new Set();
    const newOutlines = [];
    let changed = false;

    for (const outline of computed) {
      const template = existingBySection.get(outline.sectionId);
      if (template && typeof template.lineIndex === "number" && template.lineIndex >= 0 && template.lineIndex < originalLines.length) {
        const newLine = buildOutlineLine(outline.sectionId, outline.sectionName, outline.coords, template);
        if (originalLines[template.lineIndex] !== newLine) {
          originalLines[template.lineIndex] = newLine;
          changed = true;
        }
        usedLineIndexes.add(template.lineIndex);
        newOutlines.push({
          ...outline,
          lineIndex: template.lineIndex,
          beforePoly: template.beforePoly,
          suffix: template.suffix,
          headerTokens: template.headerTokens,
          prefixTokens: template.prefixTokens
        });
      } else {
        const newLine = buildOutlineLine(outline.sectionId, outline.sectionName, outline.coords, null);
        originalLines.push(newLine);
        changed = true;
        const newIndex = originalLines.length - 1;
        newOutlines.push({
          ...outline,
          lineIndex: newIndex,
          beforePoly: newLine.slice(0, newLine.indexOf("[Poly|")),
          suffix: newLine.includes("|]>") ? "|]>" : (newLine.includes("]>") ? "]>" : "]"),
          headerTokens: ["1", "10", "#FFD3D3D3"],
          prefixTokens: [sectionIdToOutlineCode(outline.sectionId), outline.sectionName || "", "1"]
        });
      }
    }

    for (const o of outlines) {
      if (!o.sectionId) continue;
      if (typeof o.lineIndex === "number" && !usedLineIndexes.has(o.lineIndex) && o.lineIndex < originalLines.length) {
        if (originalLines[o.lineIndex] !== "") {
          originalLines[o.lineIndex] = "";
          changed = true;
        }
      }
    }

    outlines = newOutlines;
    return changed;
  }

  // --- Bakgrundshantering ---
  function updateBgOpacityDisplay() {
    bgOpacityValue.textContent = backgroundState.opacity.toFixed(2);
  }

  function updateBgScaleDisplay() {
    bgScaleValue.textContent = `${backgroundState.scale.toFixed(1)}x`
  }

  function setBackgroundEnabled(enabled) {
    backgroundState.enabled = enabled;
    bgEnabledToggle.checked = enabled;
    saveSessionToLocalStorage();
    renderCanvas();
  }

  function setBackgroundOpacity(val) {
    const clamped = Math.min(1, Math.max(0, val));
    backgroundState.opacity = clamped;
    bgOpacityRange.value = clamped;
    updateBgOpacityDisplay();
    saveSessionToLocalStorage();
    renderCanvas();
  }

  function setBackgroundScale(val) {
    const clamped = Math.min(10, Math.max(0.1, val));
    backgroundState.scale = clamped;
    bgScaleRange.value = clamped;
    updateBgScaleDisplay();
    saveSessionToLocalStorage();
    renderCanvas();
  }

  function loadBackgroundFromDataUrl(dataUrl) {
    return new Promise((resolve, reject) => {
      if (!dataUrl) {
        backgroundState.dataUrl = "";
        backgroundState.img = null;
        setBackgroundEnabled(false);
        saveSessionToLocalStorage();
        renderCanvas();
        resolve();
        return;
      }
      const img = new Image();
      img.onload = () => {
        backgroundState.dataUrl = dataUrl;
        backgroundState.img = img;
        if (!Number.isFinite(backgroundState.originX) || !Number.isFinite(backgroundState.originY)) {
          if (layoutBounds) {
            backgroundState.originX = layoutBounds.minX;
            backgroundState.originY = layoutBounds.minY;
          } else {
            backgroundState.originX = 0;
            backgroundState.originY = 0;
          }
        }
        setBackgroundEnabled(true);
        saveSessionToLocalStorage();
        renderCanvas();
        resolve();
      };
      img.onerror = reject;
      img.src = dataUrl;
    });
  }

  function updateCodeFromSeats() {
    if (!originalLines || !originalLines.length) return;
    let changed = false;
    for (const s of seats) {
      if (typeof s.lineIndex === "number" && s.lineIndex >= 0 && s.lineIndex < originalLines.length) {
        const newLine = buildSeatLine(s);
        if (originalLines[s.lineIndex] !== newLine) {
          originalLines[s.lineIndex] = newLine;
          changed = true;
        }
      }
    }
    const outlinesChanged = syncOutlinesIntoOriginalLines();
    changed = changed || outlinesChanged;
    if (!changed) return;
    const newText = originalLines.join("\n");
    if (codePane.value !== newText) {
      codePane.value = newText;
    }
    hasUnsavedChanges = true;
    updateSaveButton();
    saveSessionToLocalStorage(); 
  }


  function saveSessionToLocalStorage() {
  try {
    const payload = {
      tltText: codePane.value || "",
      fileName: currentFileName || "",
      translateX,
      translateY,
      scale,
      background: {
        dataUrl: backgroundState.dataUrl || "",
        enabled: !!backgroundState.enabled,
        opacity: backgroundState.opacity,
        scale: backgroundState.scale,
        originX: backgroundState.originX,
        originY: backgroundState.originY
      },
      timestamp: Date.now()
    };
    localStorage.setItem(SESSION_STORAGE_KEY, JSON.stringify(payload));
  } catch (err) {
    console.warn("Kunde inte spara session i localStorage:", err);
  }
}

function openHandleDB() {
  return new Promise((resolve, reject) => {
    if (!("indexedDB" in window)) {
      reject(new Error("IndexedDB saknas"));
      return;
    }

    const req = indexedDB.open(DB_NAME, DB_VERSION);
    req.onupgradeneeded = (e) => {
      const db = e.target.result;
      if (!db.objectStoreNames.contains(DB_STORE)) {
        db.createObjectStore(DB_STORE);
      }
    };
    req.onsuccess = (e) => {
      resolve(e.target.result);
    };
    req.onerror = (e) => {
      reject(e.target.error || new Error("Kunde inte öppna DB"));
    };
  });
}

async function saveCurrentFileHandleToDB(handle) {
  if (!handle || !("indexedDB" in window)) return;
  try {
    const db = await openHandleDB();
    const tx = db.transaction(DB_STORE, "readwrite");
    tx.objectStore(DB_STORE).put(handle, "current");
    tx.oncomplete = () => db.close();
  } catch (err) {
    console.warn("Kunde inte spara fileHandle i IndexedDB:", err);
  }
}

async function loadCurrentFileHandleFromDB() {
  if (!("indexedDB" in window)) return null;
  try {
    const db = await openHandleDB();
    return await new Promise((resolve, reject) => {
      const tx = db.transaction(DB_STORE, "readonly");
      const req = tx.objectStore(DB_STORE).get("current");
      req.onsuccess = () => {
        const handle = req.result || null;
        db.close();
        resolve(handle);
      };
      req.onerror = (e) => {
        db.close();
        reject(e.target.error || new Error("get current failed"));
      };
    });
  } catch (err) {
    console.warn("Kunde inte läsa fileHandle från IndexedDB:", err);
    return null;
  }
}

async function clearCurrentFileHandleInDB() {
  if (!("indexedDB" in window)) return;
  try {
    const db = await openHandleDB();
    const tx = db.transaction(DB_STORE, "readwrite");
    tx.objectStore(DB_STORE).delete("current");
    tx.oncomplete = () => db.close();
  } catch (err) {
    console.warn("Kunde inte rensa fileHandle i IndexedDB:", err);
  }
}


async function tryRestoreSessionFromLocalStorage() {
  try {
    const raw = localStorage.getItem(SESSION_STORAGE_KEY);
    if (!raw) return;

    const data = JSON.parse(raw);
    if (!data || !data.tltText) return;

    const accept = confirm(
      "Det finns en tidigare osparad session.\nVill du återställa den?"
    );
    if (!accept) return;

    // Återställ tlt-texten
    codePane.value = data.tltText;
    parseTlt(data.tltText);

    // Återställ filnamn-info (om vi hade ett)
    currentFileName = data.fileName || "";
    if (currentFileName) {
      fileInfo.textContent = `Återställd session (${currentFileName})`;
    } else {
      fileInfo.textContent = "Återställd session (ej sparad fil)";
    }

    // Återställ zoom/pan om vi har dem
    if (typeof data.translateX === "number") translateX = data.translateX;
    if (typeof data.translateY === "number") translateY = data.translateY;
    if (typeof data.scale === "number")      scale      = data.scale;

    if (data.background) {
      backgroundState.enabled = !!data.background.enabled;
      backgroundState.opacity = typeof data.background.opacity === "number" ? data.background.opacity : backgroundState.opacity;
      backgroundState.scale = typeof data.background.scale === "number" ? data.background.scale : backgroundState.scale;
      backgroundState.originX = typeof data.background.originX === "number" ? data.background.originX : backgroundState.originX;
      backgroundState.originY = typeof data.background.originY === "number" ? data.background.originY : backgroundState.originY;
      updateBgOpacityDisplay();
      updateBgScaleDisplay();
      bgEnabledToggle.checked = backgroundState.enabled;
      if (data.background.dataUrl) {
        await loadBackgroundFromDataUrl(data.background.dataUrl);
      }
    }



    renderCanvas();

    // Vi betraktar detta som osparade ändringar (kan ju vara viktigare än filen)
    hasUnsavedChanges = true;
    updateSaveButton();

    loadCurrentFileHandleFromDB().then((handle) => {
      if (handle) {
        currentFileHandle = handle;
        // fileInfo-texten är redan satt utifrån currentFileName
      }
    });

  } catch (err) {
    console.warn("Kunde inte läsa session från localStorage:", err);
  }
}

codePane.addEventListener("input", () => {
  hasUnsavedChanges = true;
  updateSaveButton();
  saveSessionToLocalStorage();
});


  async function loadTltFromHandle(handle) {
    const file = await handle.getFile();
    const text = await file.text();
    parseTlt(text);
    codePane.value = text;
    currentFileHandle = handle;
    currentFileName = file.name || "";
    lastDirectoryHandle = await tryGetDirectoryHandle(handle) || handle;
    fileInfo.textContent = currentFileName ? `Öppnad fil (${currentFileName})` : "Öppnad fil";
    hasUnsavedChanges = false;
    updateSaveButton();
    saveCurrentFileHandleToDB(handle);
  }

  async function handleOpenViaPicker() {
    try {
      const pickerOpts = {
        types: [
          {
            description: "Tickster Layout (.tlt)",
            accept: { "text/plain": [".tlt", ".txt"] }
          }
        ],
        excludeAcceptAllOption: false,
        multiple: false
      };
      const startDir = lastDirectoryHandle || await tryGetDirectoryHandle(currentFileHandle);
      if (startDir) {
        pickerOpts.startIn = startDir;
      }
      const [handle] = await window.showOpenFilePicker(pickerOpts);
      if (handle) {
        await loadTltFromHandle(handle);
      }
    } catch (err) {
      console.warn("Öppna via picker misslyckades, provar filinput:", err);
      fileInput?.click();
    }
  }

  async function handleSaveViaPicker() {
    const text = codePane.value || "";
    try {
      let handle = currentFileHandle;
      const startDir = lastDirectoryHandle || await tryGetDirectoryHandle(currentFileHandle);
      if (!handle) {
        const pickerOpts = {
          types: [
            {
              description: "Tickster Layout (.tlt)",
              accept: { "text/plain": [".tlt", ".txt"] }
            }
          ],
          suggestedName: currentFileName || "layout.tlt",
          excludeAcceptAllOption: false,
          startIn: startDir || undefined
        };
        handle = await window.showSaveFilePicker(pickerOpts);
      }
      if (!handle) return;
      const writable = await handle.createWritable();
      await writable.write(text);
      await writable.close();
      currentFileHandle = handle;
      lastDirectoryHandle = await tryGetDirectoryHandle(handle) || handle;
      currentFileName = handle.name || currentFileName || "layout.tlt";
      fileInfo.textContent = `Sparad (${currentFileName})`;
      hasUnsavedChanges = false;
      updateSaveButton();
      saveCurrentFileHandleToDB(handle);
    } catch (err) {
      if (err?.name === "AbortError") {
        console.warn("Spara avbrutet av användare.");
        return;
      }
      console.warn("Spara via picker misslyckades, provar nedladdning:", err);
      downloadFallback(text);
    }
  }

  function downloadFallback(text) {
    try {
      const blob = new Blob([text], { type: "text/plain" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = currentFileName || "layout.tlt";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      fileInfo.textContent = `Sparad (${a.download})`;
      hasUnsavedChanges = false;
      updateSaveButton();
    } catch (err) {
      console.warn("Nedladdningsfallback misslyckades:", err);
    }
  }

  async function openFileFromInput(file) {
    if (!file) return;
    const text = await file.text();
    parseTlt(text);
    codePane.value = text;
    currentFileName = file.name || "";
    currentFileHandle = null;
    fileInfo.textContent = currentFileName ? `Öppnad fil (${currentFileName})` : "Öppnad fil";
    hasUnsavedChanges = false;
    updateSaveButton();
    clearCurrentFileHandleInDB();
    fileInput.value = "";
  }

  async function openFile() {
    if (supportsOpenPicker) {
      await handleOpenViaPicker();
    } else {
      fileInput?.click();
    }
  }

  async function saveFile() {
    if (supportsSavePicker) {
      await handleSaveViaPicker();
    } else {
      downloadFallback(codePane.value || "");
    }
  }

  function resetLayoutState(baseName = "", venueId = "") {
    seats = [];
    outlines = [];
    const initTs = buildTimestamp();
    originalLines = [`${initTs}|LayoutInit|VenueId=${venueId}`];
    seatIdToLineIndex = new Map();
    sectionNames = new Map();
    sectionColors = new Map();
    sectionRawText.clear();
    activeSectionDraftId = null;
    layoutBounds = null;
    codePane.value = originalLines.join("\n");
    currentFileHandle = null;
    currentFileName = baseName ? `${baseName}.tlt` : "";
    hasUnsavedChanges = false;
    updateSaveButton();
    seatCountEl.textContent = "0";
    sectionCountEl.textContent = "0";
    rowCountEl.textContent = "0";
    resetSectionDrafts();
    renderSectionCards();
    renderSectionDetail();
    renderCanvas();
  }

  openFileBtnTop?.addEventListener("click", () => {
    openFile();
  });

  saveBtn?.addEventListener("click", () => {
    if (!hasUnsavedChanges && currentFileHandle) {
      fileInfo.textContent = currentFileName ? `Sparad (${currentFileName})` : "Sparad";
      return;
    }
    saveFile();
  });

  fileInput?.addEventListener("change", (e) => {
    const file = e.target.files && e.target.files[0];
    if (file) {
      openFileFromInput(file);
    }
  });

  function openNewLayoutModal() {
    if (newLayoutOverlay) newLayoutOverlay.style.display = "flex";
    if (newProjectName) {
      newProjectName.value = "";
      setTimeout(() => newProjectName.focus(), 50);
    }
    if (newVenueId) newVenueId.value = "";
  }

  function closeNewLayoutModal() {
    if (newLayoutOverlay) newLayoutOverlay.style.display = "none";
  }

  function handleStartNewLayout() {
    const rawName = (newProjectName?.value || "").trim();
    if (!rawName) {
      alert("Ange projektnamn.");
      return;
    }
    const venueIdVal = (newVenueId?.value || "").trim();
    const safeBase = rawName.replace(/[\\/:*?\"<>|]/g, "_");

    resetLayoutState(safeBase, venueIdVal);
    updateCodeFromSeats(); // tom layout -> initline finns

    // Markera som osparad så användaren sparar manuellt
    currentFileName = safeBase ? `${safeBase}.TLT` : "";
    fileInfo.textContent = "Ny layout (ej sparad)";
    hasUnsavedChanges = true;
    updateSaveButton();
    closeNewLayoutModal();
    openSectionManager();
  }

  newLayoutBtn?.addEventListener("click", openNewLayoutModal);
  newLayoutCancel?.addEventListener("click", closeNewLayoutModal);
  newLayoutOverlay?.addEventListener("click", (e) => {
    if (e.target === newLayoutOverlay) closeNewLayoutModal();
  });
  newLayoutStart?.addEventListener("click", handleStartNewLayout);

  // Försök återanvända senaste handle direkt vid start (utan att öppna filen automatiskt)
  loadCurrentFileHandleFromDB().then((handle) => {
    if (handle) {
      currentFileHandle = handle;
      currentFileName = handle.name || currentFileName;
    }
  });

  function updateSaveButton() {
    saveBtn.disabled = !hasUnsavedChanges;
  }

  function updateMoveButtonState() {
    const anySelected = seats.some(s => s.selected);
    const selectedRows = getSelectedRows();
    const selectedRowsCount = selectedRows.size;
    const allowTransform = anySelected;
    const allowResize = anySelected && (selectionMode === "section" || selectionMode === "row");
    const allowBend = selectionMode === "row" && selectedRowsCount === 1;
    const allowReshape = selectionMode === "row" && selectedRowsCount === 1;
    const allowResetRow = selectionMode === "row" && selectedRowsCount >= 1;
    const allowMakeTable = selectionMode === "row" && selectedRowsCount >= 1;

    moveToolBtn.disabled = !allowTransform;
    rotateToolBtn.disabled = !allowTransform;
    resizeToolBtn.disabled = !allowResize;
    bendToolBtn.disabled = !allowBend;
    reshapeRowBtn.disabled = !allowReshape;
    resetRowBtn.disabled = !allowResetRow;
    makeTableBtn.disabled = !allowMakeTable;

    if (
      (!allowTransform && (currentTool === "move" || currentTool === "rotate")) ||
      (!allowResize && currentTool === "resize") ||
      (!allowBend && currentTool === "bend") ||
      (!allowReshape && currentTool === "reshape")
    ) {
      setTool("select");
    }

    updateAlignButtons();
  }

  function updateAlignButtons() {
    const groups = getAlignGroups();
    const enabled = groups.length >= 2;
    alignTopBtn.disabled = !enabled;
    alignBottomBtn.disabled = !enabled;
    alignLeftBtn.disabled = !enabled;
    alignRightBtn.disabled = !enabled;
    alignCenterHBtn.disabled = !enabled;
    alignCenterVBtn.disabled = !enabled;
  }

  // Hjälpfunktioner för färgkontrast på etiketter
  const labelColorCache = new Map();
  function hexToRgb(hex) {
    const h = hex.replace("#", "").trim();
    if (h.length === 3) {
      return {
        r: parseInt(h[0] + h[0], 16),
        g: parseInt(h[1] + h[1], 16),
        b: parseInt(h[2] + h[2], 16)
      };
    }
    return {
      r: parseInt(h.slice(0, 2), 16),
      g: parseInt(h.slice(2, 4), 16),
      b: parseInt(h.slice(4, 6), 16)
    };
  }
  function getLabelTextColor(color) {
    if (!color) return "#fff";
    if (labelColorCache.has(color)) return labelColorCache.get(color);
    const { r, g, b } = hexToRgb(color);
    const lum = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
    const txt = lum > 0.55 ? "#0f1d2a" : "#ffffff";
    labelColorCache.set(color, txt);
    return txt;
  }

  // --- Render ---
  function renderCanvas() {
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const worldMinX = (-translateX) / scale;
    const worldMaxX = (canvas.width - translateX) / scale;
    const worldMinY = (-translateY) / scale;
    const worldMaxY = (canvas.height - translateY) / scale;

    // Först: räkna synliga platser
    let visibleCount = 0;
    for (const s of seats) {
      if (
        s.vx < worldMinX || s.vx > worldMaxX ||
        s.vy < worldMinY || s.vy > worldMaxY
      ) continue;
      visibleCount++;
    }
    lastVisibleSeatCount = visibleCount;

    const useRectDots = visibleCount > RECT_DOT_THRESHOLD;
    const rectScreenSize = 2;
    const rectSizeWorld = rectScreenSize / scale;

    ctx.save();
    ctx.translate(translateX, translateY);
    ctx.scale(scale, scale);

    // Bakgrundsbild
    if (backgroundState.enabled && backgroundState.img) {
      const bgImg = backgroundState.img;
      const drawW = bgImg.naturalWidth * backgroundState.scale;
      const drawH = bgImg.naturalHeight * backgroundState.scale;
      ctx.save();
      ctx.globalAlpha = backgroundState.opacity;
      ctx.drawImage(bgImg, backgroundState.originX, backgroundState.originY, drawW, drawH);
      ctx.restore();
    }

    // Platser
    for (const s of seats) {
      if (
        s.vx < worldMinX || s.vx > worldMaxX ||
        s.vy < worldMinY || s.vy > worldMaxY
      ) continue;

      let baseColor = sectionColors.get(s.sectionId) || "#4a90e2";
      if (s.attribute === "Wheelchair") {
        baseColor = "#2ecc71";
      }
      if (renderGrayscale) {
        baseColor = s.attribute === "Wheelchair" ? "#7c8a98" : "#9ca8b7";
      }

      // Fyrkantsläge (massor av platser)
      if (useRectDots) {
        ctx.fillStyle = baseColor;
        ctx.fillRect(
          s.vx - rectSizeWorld / 2,
          s.vy - rectSizeWorld / 2,
          rectSizeWorld,
          rectSizeWorld
        );

        if (s.selected) {
          ctx.strokeStyle = "#000";
          ctx.lineWidth = 1 / scale;
          ctx.strokeRect(
            s.vx - rectSizeWorld,
            s.vy - rectSizeWorld,
            rectSizeWorld * 2,
            rectSizeWorld * 2
          );
        }
        continue;
      }

        // Cirkel-läge
        let pxRadius = BASE_WORLD_RADIUS * scale;
        if (pxRadius < MIN_SEAT_SCREEN_RADIUS) {
          pxRadius = MIN_SEAT_SCREEN_RADIUS;
        }
        const worldRadius = pxRadius / scale;

      ctx.beginPath();
      ctx.arc(s.vx, s.vy, worldRadius, 0, Math.PI * 2);
      ctx.fillStyle = baseColor;
      ctx.fill();

        if (s.selected) {
          ctx.lineWidth = 3 / scale;
          ctx.strokeStyle = "#000";
          ctx.stroke();
      } else {
          ctx.lineWidth = 1.2 / scale;
          ctx.strokeStyle = "rgba(0,0,0,0.25)";
          ctx.stroke();
        }

        if (seatLabelMode !== "none") {
          const label = seatLabelMode === "seat" ? (s.name || "") : (s.rowName || s.rowId || s.row || "");
          if (label) {
            const fontPx = Math.max(26, Math.min(48, 33 / Math.max(scale, 0.001)));
            const textColor = getLabelTextColor(baseColor);
            ctx.save();
            ctx.fillStyle = textColor;
            ctx.strokeStyle = "rgba(255,255,255,0.7)";
            ctx.lineWidth = 2 / Math.max(scale, 0.001);
            ctx.font = `${fontPx}px "Segoe UI", system-ui, sans-serif`;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.strokeText(label, s.vx, s.vy);
            ctx.fillText(label, s.vx, s.vy);
            ctx.restore();
          }
        }
      }

      // Sektionsnamn (mitt i sektionen)
      if (showSectionNames) {
      const boundsBySection = new Map();
      for (const s of seats) {
        if (!s.sectionId) continue;
        let b = boundsBySection.get(s.sectionId);
        if (!b) {
          b = { minX: s.vx, maxX: s.vx, minY: s.vy, maxY: s.vy };
          boundsBySection.set(s.sectionId, b);
        } else {
          b.minX = Math.min(b.minX, s.vx);
          b.maxX = Math.max(b.maxX, s.vx);
          b.minY = Math.min(b.minY, s.vy);
          b.maxY = Math.max(b.maxY, s.vy);
        }
      }
      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,0.75)";
      ctx.strokeStyle = "rgba(255,255,255,0.8)";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      for (const [sectionId, b] of boundsBySection.entries()) {
        const cx = (b.minX + b.maxX) / 2;
        const cy = (b.minY + b.maxY) / 2;
        if (cx < worldMinX || cx > worldMaxX || cy < worldMinY || cy > worldMaxY) continue;
        const name = sectionNames.get(sectionId) || sectionId || "";
        if (!name) continue;
        const fontSize = 20 / Math.max(scale, 0.001);
        ctx.lineWidth = 3 / Math.max(scale, 0.001);
        ctx.font = `${fontSize}px "Segoe UI", system-ui, sans-serif`;
        ctx.strokeText(name, cx, cy);
        ctx.fillText(name, cx, cy);
      }
      ctx.restore();
    }

    // Reshape-pivot-indikator
    if (currentTool === "reshape" && reshapePivotSeatId) {
      const pivotSeat = seats.find(s => s.seatId === reshapePivotSeatId);
      if (pivotSeat) {
        const r = (BASE_WORLD_RADIUS * 1) / Math.max(scale, 1e-6);
        ctx.save();
        ctx.beginPath();
        ctx.arc(pivotSeat.vx, pivotSeat.vy, r, 0, Math.PI * 2);
        ctx.strokeStyle = "#e67e22";
        ctx.lineWidth = 2 / scale;
        ctx.setLineDash([4 / scale, 3 / scale]);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.fillStyle = "rgba(230,126,34,0.2)";
        ctx.fill();
        ctx.restore();
      }
    }

    if (!seats.length) {
      ctx.restore();
      ctx.fillStyle = "#777";
      ctx.font = "12px system-ui";
      ctx.fillText("Ingen layout laddad eller skapad.", 10, 20);
      lastVisibleSeatCount = 0;
      return;
    }

    // Ruta-markering overlay (i world + transform)
    if (selectionRectActive) {
      const x1 = Math.min(rectStartCanvasX, rectEndCanvasX);
      const y1 = Math.min(rectStartCanvasY, rectEndCanvasY);
      const x2 = Math.max(rectStartCanvasX, rectEndCanvasX);
      const y2 = Math.max(rectStartCanvasY, rectEndCanvasY);

      const w1 = (x1 - translateX) / scale;
      const h1 = (y1 - translateY) / scale;
      const w2 = (x2 - translateX) / scale;
      const h2 = (y2 - translateY) / scale;

      ctx.save();
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.beginPath();
      ctx.rect(x1, y1, x2 - x1, y2 - y1);
      ctx.strokeStyle = "rgba(47,128,237,0.9)";
      ctx.lineWidth = 1;
      ctx.setLineDash([4, 3]);
      ctx.stroke();
      ctx.fillStyle = "rgba(47,128,237,0.15)";
      ctx.fill();
      ctx.restore();
    }

    ctx.restore();

    // Tooltip-hantering utanför transform
    if (showHoverInfo && hoverSeat && lastVisibleSeatCount <= HOVER_VISIBLE_LIMIT) {
      tooltipEl.style.display = "block";
    } else {
      tooltipEl.style.display = "none";
    }

    // Resize-overlay (handtag) ritas ovanpå allt
    if (currentTool === "resize") {
      const selected = getSelectedSeats();
      if (selected.length) {
        const bounds = getSelectionBounds(selected);
        if (bounds) {
          ctx.save();
          ctx.translate(translateX, translateY);
          ctx.scale(scale, scale);

          ctx.lineWidth = 1.5 / scale;
          ctx.strokeStyle = "rgba(0,0,0,0.6)";
          ctx.setLineDash([6 / scale, 4 / scale]);
          ctx.strokeRect(bounds.minX, bounds.minY, bounds.maxX - bounds.minX, bounds.maxY - bounds.minY);

          ctx.setLineDash([]);
          const handleSize = 10 / scale;
          const handles = getResizeHandles(bounds);
          ctx.fillStyle = "#ffffff";
          ctx.strokeStyle = "#14a0f4";
          for (const h of handles) {
            ctx.beginPath();
            ctx.rect(h.x - handleSize / 2, h.y - handleSize / 2, handleSize, handleSize);
            ctx.fill();
            ctx.stroke();
          }

          ctx.restore();
        }
      }
    }

    // Bend-overlay: single anchor quadratic
    if (currentTool === "bend") {
      const rows = getSelectedRows();
      if (rows.size === 1) {
        const firstRow = rows.values().next().value;
        if (firstRow && firstRow.length >= 2) {
          const data = computeRowEndpoints(firstRow);
          const p0 = { x: data.first.vx, y: data.first.vy };
          const p2 = { x: data.last.vx, y: data.last.vy };
          const mid = { x: (p0.x + p2.x) / 2, y: (p0.y + p2.y) / 2 };
          const anchor = bendControlPoint || mid;

          ctx.save();
          ctx.translate(translateX, translateY);
          ctx.scale(scale, scale);

          ctx.strokeStyle = "#c12e44";
          ctx.lineWidth = 2 / scale;
          ctx.setLineDash([6 / scale, 4 / scale]);
          ctx.beginPath();
          ctx.moveTo(p0.x, p0.y);
          if (anchor) {
            ctx.quadraticCurveTo(anchor.x, anchor.y, p2.x, p2.y);
          } else {
            ctx.lineTo(p2.x, p2.y);
          }
          ctx.stroke();

          ctx.setLineDash([]);
          ctx.fillStyle = "#c12e44";
          ctx.strokeStyle = "#fff";
          const r = 6 / scale;

          if (anchor) {
            ctx.beginPath();
            ctx.arc(anchor.x, anchor.y, r, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
          }
          ctx.beginPath();
          ctx.arc(p0.x, p0.y, r * 0.8, 0, Math.PI * 2);
          ctx.arc(p2.x, p2.y, r * 0.8, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();

          ctx.restore();
        }
      }
    }
  }

  function zoomToFitAllSeats() {
  if (!seats || seats.length === 0) return;

  let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
  for (const s of seats) {
    if (s.vx < minX) minX = s.vx;
    if (s.vx > maxX) maxX = s.vx;
    if (s.vy < minY) minY = s.vy;
    if (s.vy > maxY) maxY = s.vy;
  }

  if (!Number.isFinite(minX) || !Number.isFinite(maxX)) return;

  const paddingWorld = 50;
  const widthWorld  = (maxX - minX) + paddingWorld * 2;
  const heightWorld = (maxY - minY) + paddingWorld * 2;
  const cxWorld = (minX + maxX) / 2;
  const cyWorld = (minY + maxY) / 2;

  const scaleX = canvas.width  / widthWorld;
  const scaleY = canvas.height / heightWorld;
  scale = Math.min(scaleX, scaleY);

  translateX = canvas.width  / 2 - cxWorld * scale;
  translateY = canvas.height / 2 - cyWorld * scale;

  renderCanvas();
}

function selectAllSeats() {
  if (!seats || seats.length === 0) return;

  let changed = false;
  for (const s of seats) {
    if (!s.selected) {
      s.selected = true;
      changed = true;
    }
  }
  if (!changed) return;

  // Aktivera Move-verktyget (det är bara knappen som ska bli aktiverbar)
  moveToolBtn.disabled = false;

  // Lägg detta i historiken så att Ctrl+Z även ångrar "markera alla"
  if (typeof pushHistorySnapshot === "function") {
    pushHistorySnapshot();
  }

    renderCanvas();
  }


  // --- Markeringsdata ---
  function getSelectedSeats() {
    return seats.filter(s => s.selected);
  }

  function getSelectionBounds(selectedSeats) {
    if (!selectedSeats || !selectedSeats.length) return null;
    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
    for (const s of selectedSeats) {
      if (s.vx < minX) minX = s.vx;
      if (s.vx > maxX) maxX = s.vx;
      if (s.vy < minY) minY = s.vy;
      if (s.vy > maxY) maxY = s.vy;
    }
    if (!Number.isFinite(minX) || !Number.isFinite(minY) || !Number.isFinite(maxX) || !Number.isFinite(maxY)) {
      return null;
    }
    return {
      minX,
      minY,
      maxX,
      maxY,
      centerX: (minX + maxX) / 2,
      centerY: (minY + maxY) / 2
    };
  }

  function getSelectedRows() {
    const selected = getSelectedSeats();
    const rows = new Map();
    for (const s of selected) {
      if (!s.rowId) continue;
      if (!rows.has(s.rowId)) rows.set(s.rowId, []);
      rows.get(s.rowId).push(s);
    }
    return rows;
  }

  function sortSeatsInRow(rowSeats) {
    // Försök numerisk sort på name, annars seatId-suffix, annars vx/vy
    const parseKey = (seat) => {
      const num = parseFloat(seat.name);
      if (!Number.isNaN(num)) return { kind: "num", value: num };
      const parts = seat.seatId ? seat.seatId.split(".") : [];
      const last = parts[parts.length - 1];
      const lastNum = parseFloat(last);
      if (!Number.isNaN(lastNum)) return { kind: "num", value: lastNum };
      return { kind: "pos", value: seat.vx + seat.vy * 1e-3 };
    };
    return [...rowSeats].sort((a, b) => {
      const ka = parseKey(a);
      const kb = parseKey(b);
      if (ka.kind === "num" && kb.kind === "num") return ka.value - kb.value;
      if (ka.kind === "num") return -1;
      if (kb.kind === "num") return 1;
      return ka.value - kb.value;
    });
  }

  function computeRowEndpoints(rowSeats) {
    const sorted = sortSeatsInRow(rowSeats);
    const first = sorted[0];
    const last = sorted[sorted.length - 1];
    return { first, last, order: sorted };
  }

  function redistributeRowLinear(rowData) {
    const { first, last, order } = rowData;
    const n = order.length;
    if (n <= 1) return;
    const dx = last.vx - first.vx;
    const dy = last.vy - first.vy;
    const denom = Math.max(n - 1, 1);
    for (let i = 0; i < n; i++) {
      const t = denom === 0 ? 0 : i / denom;
      const x = first.vx + dx * t;
      const y = first.vy + dy * t;
      const seat = order[i];
      seat.vx = x;
      seat.vy = y;
      seat.centerX = x;
      seat.centerY = y;
    }
  }

  function applyRowBend(rowData, rowId) {
    if (!bendControlPoint) {
      redistributeRowLinear(rowData);
      return;
    }
    bendRowsWithControl(bendControlPoint, [rowData]);
  }

  function bezierPoint(t, p0, p1, p2) {
    const u = 1 - t;
    const tt = t * t;
    const uu = u * u;
    const x = uu * p0.x + 2 * u * t * p1.x + tt * p2.x;
    const y = uu * p0.y + 2 * u * t * p1.y + tt * p2.y;
    return { x, y };
  }

  function cubicPoint(t, p0, p1, p2, p3) {
    const u = 1 - t;
    const tt = t * t;
    const uu = u * u;
    const uuu = uu * u;
    const ttt = tt * t;
    const x = uuu * p0.x + 3 * uu * t * p1.x + 3 * u * tt * p2.x + ttt * p3.x;
    const y = uuu * p0.y + 3 * uu * t * p1.y + 3 * u * tt * p2.y + ttt * p3.y;
    return { x, y };
  }

  function buildBezierArcTable(p0, p1, p2, steps = 150) {
    const table = [];
    let prev = p0;
    let length = 0;
    table.push({ t: 0, len: 0 });
    for (let i = 1; i <= steps; i++) {
      const t = i / steps;
      const pt = bezierPoint(t, p0, p1, p2);
      const dx = pt.x - prev.x;
      const dy = pt.y - prev.y;
      length += Math.hypot(dx, dy);
      table.push({ t, len: length });
      prev = pt;
    }
    return { table, total: length };
  }

  function buildCubicArcTable(p0, p1, p2, p3, steps = 180) {
    const table = [];
    let prev = p0;
    let length = 0;
    table.push({ t: 0, len: 0 });
    for (let i = 1; i <= steps; i++) {
      const t = i / steps;
      const pt = cubicPoint(t, p0, p1, p2, p3);
      const dx = pt.x - prev.x;
      const dy = pt.y - prev.y;
      length += Math.hypot(dx, dy);
      table.push({ t, len: length });
      prev = pt;
    }
    return { table, total: length };
  }

  function tAtArcLength(targetLen, arcTable) {
    const { table, total } = arcTable;
    if (targetLen <= 0) return 0;
    if (targetLen >= total) return 1;
    // binary search
    let lo = 0, hi = table.length - 1;
    while (lo + 1 < hi) {
      const mid = Math.floor((lo + hi) / 2);
      if (table[mid].len < targetLen) lo = mid;
      else hi = mid;
    }
    const a = table[lo], b = table[hi];
    const span = b.len - a.len || 1e-6;
    const f = (targetLen - a.len) / span;
    return a.t + (b.t - a.t) * f;
  }

  function bendRowsWithControl(controlPoint, rowsData) {
    for (const rowData of rowsData) {
      const { first, last, order } = rowData;
      const n = order.length;
      if (n <= 2) continue;
      if (!controlPoint) {
        redistributeRowLinear(rowData);
        continue;
      }
      // single anchor -> quadratic curve
      const pts = [
        { x: first.vx, y: first.vy },
        { x: controlPoint.x, y: controlPoint.y },
        { x: last.vx, y: last.vy }
      ];
      const arc = buildBezierArcTable(pts[0], pts[1], pts[2]);
      const segmentLen = arc.total / (n - 1);
      for (let i = 0; i < n; i++) {
        const targetLen = segmentLen * i;
        const t = tAtArcLength(targetLen, arc);
        const pt = bezierPoint(t, pts[0], pts[1], pts[2]);
        const seat = order[i];
        seat.vx = pt.x;
        seat.vy = pt.y;
        seat.centerX = pt.x;
        seat.centerY = pt.y;
      }
    }
  }

  function resetSelectedRowsLinear() {
    const rows = getSelectedRows();
    if (!rows.size) return false;
    let changed = false;
    for (const [, rowSeats] of rows) {
      if (rowSeats.length < 2) continue;
      const data = computeRowEndpoints(rowSeats);
      redistributeRowLinear(data);
      changed = true;
    }
    return changed;
  }

  function applyReshapeDrag(target, newX, newY) {
    if (!reshapeRowSeats || !reshapeRowSeats.length || !reshapeSnapshotById) return;
    const sorted = sortSeatsInRow(reshapeRowSeats);
    if (!sorted.length) return;

    const pivotIndex = reshapePivotSeatId
      ? sorted.findIndex(s => s.seatId === reshapePivotSeatId)
      : -1;

    const startSnap = reshapeSnapshotById.get(sorted[0].seatId);
    const endSnap = reshapeSnapshotById.get(sorted[sorted.length - 1].seatId);
    if (!startSnap || !endSnap) return;

    if (target === "start") {
      const anchorSnap = pivotIndex >= 0
        ? reshapeSnapshotById.get(sorted[pivotIndex].seatId) || endSnap
        : endSnap;
      const segLen = pivotIndex >= 0 ? pivotIndex : sorted.length - 1;
      for (let i = 0; i < sorted.length; i++) {
        if (pivotIndex >= 0 && i > pivotIndex) {
          const snap = reshapeSnapshotById.get(sorted[i].seatId);
          if (snap) {
            sorted[i].vx = snap.vx;
            sorted[i].vy = snap.vy;
            sorted[i].centerX = snap.vx;
            sorted[i].centerY = snap.vy;
          }
          continue;
        }
        const t = segLen === 0 ? 0 : i / segLen;
        const x = newX + (anchorSnap.vx - newX) * t;
        const y = newY + (anchorSnap.vy - newY) * t;
        sorted[i].vx = x;
        sorted[i].vy = y;
        sorted[i].centerX = x;
        sorted[i].centerY = y;
      }
    } else if (target === "end") {
      const anchorSnap = pivotIndex >= 0
        ? reshapeSnapshotById.get(sorted[pivotIndex].seatId) || startSnap
        : startSnap;
      const startIndex = pivotIndex >= 0 ? pivotIndex : 0;
      const segLen = pivotIndex >= 0 ? (sorted.length - 1 - pivotIndex) : (sorted.length - 1);
      for (let i = 0; i < sorted.length; i++) {
        if (i < startIndex) {
          const snap = reshapeSnapshotById.get(sorted[i].seatId);
          if (snap) {
            sorted[i].vx = snap.vx;
            sorted[i].vy = snap.vy;
            sorted[i].centerX = snap.vx;
            sorted[i].centerY = snap.vy;
          }
          continue;
        }
        const t = segLen === 0 ? 0 : (i - startIndex) / segLen;
        const x = anchorSnap.vx + (newX - anchorSnap.vx) * t;
        const y = anchorSnap.vy + (newY - anchorSnap.vy) * t;
        sorted[i].vx = x;
        sorted[i].vy = y;
        sorted[i].centerX = x;
        sorted[i].centerY = y;
      }
    }
  }

  function getAlignGroups() {
    const selected = getSelectedSeats();
    if (!selected.length) return [];

    const groups = [];
    if (selectionMode === "section") {
      const bySection = new Map();
      for (const s of selected) {
        if (!s.sectionId) continue;
        if (!bySection.has(s.sectionId)) bySection.set(s.sectionId, []);
        bySection.get(s.sectionId).push(s);
      }
      for (const seatsArr of bySection.values()) {
        const b = getSelectionBounds(seatsArr);
        if (b) groups.push({ seats: seatsArr, bounds: b });
      }
    } else if (selectionMode === "row") {
      const byRow = new Map();
      for (const s of selected) {
        if (!s.rowId) continue;
        if (!byRow.has(s.rowId)) byRow.set(s.rowId, []);
        byRow.get(s.rowId).push(s);
      }
      for (const seatsArr of byRow.values()) {
        const b = getSelectionBounds(seatsArr);
        if (b) groups.push({ seats: seatsArr, bounds: b });
      }
    } else {
      // Seat-läge: behandla varje plats som egen grupp
      for (const s of selected) {
        groups.push({ seats: [s], bounds: { minX: s.vx, maxX: s.vx, minY: s.vy, maxY: s.vy, centerX: s.vx, centerY: s.vy } });
      }
    }
    return groups;
  }

  function alignSelectedSeats(mode) {
    const groups = getAlignGroups();
    if (!groups.length) return false;
    // Kräver minst 2 grupper för meningsfull align
    if (groups.length < 2) return false;

    // Samla övergripande bounds från gruppers bounding box
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    for (const g of groups) {
      minX = Math.min(minX, g.bounds.minX);
      minY = Math.min(minY, g.bounds.minY);
      maxX = Math.max(maxX, g.bounds.maxX);
      maxY = Math.max(maxY, g.bounds.maxY);
    }
    const overall = {
      minX,
      minY,
      maxX,
      maxY,
      centerX: (minX + maxX) / 2,
      centerY: (minY + maxY) / 2
    };

    let changed = false;
    for (const g of groups) {
      let deltaX = 0;
      let deltaY = 0;
      switch (mode) {
        case "top":
          deltaY = overall.minY - g.bounds.minY;
          break;
        case "bottom":
          deltaY = overall.maxY - g.bounds.maxY;
          break;
        case "left":
          deltaX = overall.minX - g.bounds.minX;
          break;
        case "right":
          deltaX = overall.maxX - g.bounds.maxX;
          break;
        case "centerH":
          deltaX = overall.centerX - g.bounds.centerX;
          break;
        case "centerV":
          deltaY = overall.centerY - g.bounds.centerY;
          break;
        default:
          break;
      }
      if (deltaX !== 0 || deltaY !== 0) {
        changed = true;
        for (const s of g.seats) {
          s.vx += deltaX;
          s.vy += deltaY;
          s.centerX += deltaX;
          s.centerY += deltaY;
        }
      }
    }
    return changed;
  }

  function nudgeSelection(dxScreen, dyScreen) {
    const selected = getSelectedSeats();
    if (!selected.length) return false;
    const dxWorld = dxScreen / scale;
    const dyWorld = dyScreen / scale;
    let moved = false;
    for (const s of selected) {
      const newX = s.vx + dxWorld;
      const newY = s.vy + dyWorld;
      if (newX !== s.vx || newY !== s.vy) {
        s.vx = newX;
        s.vy = newY;
        s.centerX = newX;
        s.centerY = newY;
        moved = true;
      }
    }
    return moved;
  }

  function makeTableFromSelectedRows() {
    const rows = getSelectedRows();
    if (!rows.size) return false;
    let changed = false;
    for (const [, rowSeats] of rows) {
      if (rowSeats.length < 2) continue;
      const sorted = sortSeatsInRow(rowSeats);
      const first = sorted[0];
      let dirX = 1, dirY = 0, spacing = 50;
      if (sorted.length > 1) {
        const second = sorted[1];
        const dx = second.vx - first.vx;
        const dy = second.vy - first.vy;
        const dist = Math.hypot(dx, dy);
        if (dist > 1e-3) {
          dirX = dx / dist;
          dirY = dy / dist;
          spacing = dist;
        }
      }
      const perpX = -dirY;
      const perpY = dirX;
      const stepDown = spacing * 1.2;

      for (let i = 0; i < sorted.length; i++) {
        const col = i % 2;
        const row = Math.floor(i / 2);
        const x = first.vx + dirX * spacing * col + perpX * stepDown * row;
        const y = first.vy + dirY * spacing * col + perpY * stepDown * row;
        const seat = sorted[i];
        seat.vx = x;
        seat.vy = y;
        seat.centerX = x;
        seat.centerY = y;
      }
      changed = true;
    }
    return changed;
  }

  function ensureBendDefaults() {
    if (currentTool !== "bend") return;
    const rows = getSelectedRows();
    if (rows.size !== 1) return;
    const rowSeats = rows.values().next().value;
    if (!rowSeats || rowSeats.length < 2) return;
    const data = computeRowEndpoints(rowSeats);
    const rowId = rowSeats[0].rowId || null;
    const mid = { x: (data.first.vx + data.last.vx) / 2, y: (data.first.vy + data.last.vy) / 2 };

    if (bendActiveRowId !== rowId) {
      bendControlPoint = mid;
      bendActiveRowId = rowId;
    } else {
      if (!bendControlPoint) bendControlPoint = mid;
    }
  }

  function getResizeHandles(bounds) {
    const { minX, maxX, minY, maxY, centerX, centerY } = bounds;
    return [
      { id: "nw", x: minX, y: minY },
      { id: "n",  x: centerX, y: minY },
      { id: "ne", x: maxX, y: minY },
      { id: "e",  x: maxX, y: centerY },
      { id: "se", x: maxX, y: maxY },
      { id: "s",  x: centerX, y: maxY },
      { id: "sw", x: minX, y: maxY },
      { id: "w",  x: minX, y: centerY }
    ];
  }



  // --- Hit-test ---
  function hitTestSeat(worldX, worldY) {
    if (!seats.length) return null;
    const baseR = BASE_WORLD_RADIUS;
    const maxDist = baseR * 1.5;
    let best = null;
    let bestDist2 = Infinity;

    for (const s of seats) {
      const dx = worldX - s.vx;
      const dy = worldY - s.vy;
      const d2 = dx * dx + dy * dy;
      if (d2 < maxDist * maxDist && d2 < bestDist2) {
        bestDist2 = d2;
        best = s;
      }
    }
    return best;
  }

  // --- Markerings-läge: vilken grupp hör en klickad plats till? ---
  function getGroupForSeat(seat) {
    if (!seat) return [];
    if (selectionMode === "seat") {
      return [seat];
    } else if (selectionMode === "row") {
      return seats.filter(s => s.rowId && s.rowId === seat.rowId);
    } else if (selectionMode === "section") {
      return seats.filter(s => s.sectionId && s.sectionId === seat.sectionId);
    }
    return [seat];
  }

  // --- Markerings-ruta beroende på läge ---
  function selectByRect(rectWorld, additive) {
    const { minX, maxX, minY, maxY } = rectWorld;

    if (!additive) {
      for (const s of seats) s.selected = false;
    }

    let selectionChanged = false;

    if (selectionMode === "seat") {
      for (const s of seats) {
        if (
          s.vx >= minX && s.vx <= maxX &&
          s.vy >= minY && s.vy <= maxY
        ) {
          if (!s.selected) {
            s.selected = true;
            selectionChanged = true;
          }
        }
      }
    } else if (selectionMode === "row") {
      const rowsInside = new Set();
      for (const s of seats) {
        if (
          s.vx >= minX && s.vx <= maxX &&
          s.vy >= minY && s.vy <= maxY &&
          s.rowId
        ) {
          rowsInside.add(s.rowId);
        }
      }
      for (const s of seats) {
        if (rowsInside.has(s.rowId)) {
          if (!s.selected) {
            s.selected = true;
            selectionChanged = true;
          }
        }
      }
    } else if (selectionMode === "section") {
      const sectInside = new Set();
      for (const s of seats) {
        if (
          s.vx >= minX && s.vx <= maxX &&
          s.vy >= minY && s.vy <= maxY &&
          s.sectionId
        ) {
          sectInside.add(s.sectionId);
        }
      }
      for (const s of seats) {
        if (sectInside.has(s.sectionId)) {
          if (!s.selected) {
            s.selected = true;
            selectionChanged = true;
          }
        }
      }
    }

    if (selectionChanged) {
      pushHistorySnapshot();     // <-- nu ångrar Ctrl+Z även detta
      updateMoveButtonState();
      renderCanvas();
    }
  }

  // --- Zoom ---
  canvas.addEventListener("wheel", (e) => {
    if (!e.ctrlKey) return;
    e.preventDefault();

    const rect = canvas.getBoundingClientRect();
    const canvasX = e.clientX - rect.left;
    const canvasY = e.clientY - rect.top;

    const zoomIntensity = 1.1;
    const wheel = e.deltaY < 0 ? 1 : -1;
    const oldScale = scale;
    const newScale = wheel > 0 ? scale * zoomIntensity : scale / zoomIntensity;

    const { worldX, worldY } = screenToWorld(canvasX, canvasY);

    scale = Math.max(0.01, Math.min(20, newScale));

    translateX = canvasX - worldX * scale;
    translateY = canvasY - worldY * scale;

    renderCanvas();
  }, { passive: false });

  // --- Musinteraktion ---
  canvas.addEventListener("mousedown", (e) => {
    if (e.button !== 0) return;

    const rect = canvas.getBoundingClientRect();
    const canvasX = e.clientX - rect.left;
    const canvasY = e.clientY - rect.top;

    // CTRL = pan
    if (e.ctrlKey && currentTool !== "rotate") {
      isPanning = true;
      panStartX = e.clientX;
      panStartY = e.clientY;
      panStartTranslateX = translateX;
      panStartTranslateY = translateY;
      canvasContainer.classList.add("panning");
      return;
    }

    const { worldX, worldY } = screenToWorld(canvasX, canvasY);

    if (currentTool === "rotate") {
      const selectedSeats = getSelectedSeats();
      if (!selectedSeats.length) return;

      hasRotatedDuringDrag = false;
      rotateStartSnapshot = captureSeatState();
      rotateSnapshotById = new Map();
      for (const snap of rotateStartSnapshot) {
        rotateSnapshotById.set(snap.seatId, snap);
      }

      const bounds = getSelectionBounds(selectedSeats);
      if (!bounds) return;
      rotatePivot = { x: bounds.centerX, y: bounds.centerY };
      rotateStartAngle = Math.atan2(worldY - rotatePivot.y, worldX - rotatePivot.x);
      isRotatingSelection = true;
      return;
    }

    if (currentTool === "bend") {
      const rows = getSelectedRows();
      if (rows.size !== 1) return; // endast en rad åt gången för stabil riktning

      const [, rowSeats] = rows.entries().next().value || [];
      const thisRowId = rowSeats && rowSeats.length ? rowSeats[0].rowId : null;

      bendStartSnapshot = captureSeatState();
      bendRowsData = [];
      for (const [, rowSeats] of rows) {
        if (rowSeats.length < 2) continue;
        bendRowsData.push(computeRowEndpoints(rowSeats));
        break; // bara första (enda) raden
      }
      if (!bendRowsData.length) return;

      ensureBendDefaults();
      const rowData = bendRowsData[0];
      const startSeat = rowData.first;
      const endSeat = rowData.last;
      const hitRadius = 10;
      const startScreen = worldToScreen(startSeat.vx, startSeat.vy);
      const endScreen = worldToScreen(endSeat.vx, endSeat.vy);
      const distStart = Math.hypot(startScreen.x - canvasX, startScreen.y - canvasY);
      const distEnd = Math.hypot(endScreen.x - canvasX, endScreen.y - canvasY);

      bendDragTarget = null;
      if (distStart <= hitRadius) {
        bendDragTarget = "start";
      } else if (distEnd <= hitRadius) {
        bendDragTarget = "end";
      } else {
        bendDragTarget = "anchor";
        bendControlPoint = { x: worldX, y: worldY };
      }

      if (!bendDragTarget) return;
      hasBentDuringDrag = true;
      isBendingSelection = true;

      // Initial böjning direkt vid klick
      applyRowBend(rowData, thisRowId);
      renderCanvas();
      return;
    }

    if (currentTool === "reshape") {
      const rows = getSelectedRows();
      if (rows.size !== 1) return;
      const [, rowSeats] = rows.entries().next().value || [];
      if (!rowSeats || rowSeats.length < 2) return;

      const sorted = sortSeatsInRow(rowSeats);
      const startSeat = sorted[0];
      const endSeat = sorted[sorted.length - 1];
      const hitRadius = 12;
      const startScreen = worldToScreen(startSeat.vx, startSeat.vy);
      const endScreen = worldToScreen(endSeat.vx, endSeat.vy);
      const distStart = Math.hypot(startScreen.x - canvasX, startScreen.y - canvasY);
      const distEnd = Math.hypot(endScreen.x - canvasX, endScreen.y - canvasY);

      reshapeDragTarget = null;
      if (distStart <= hitRadius) {
        reshapeDragTarget = "start";
      } else if (distEnd <= hitRadius) {
        reshapeDragTarget = "end";
      }
      if (!reshapeDragTarget) return;

      reshapeStartSnapshot = captureSeatState();
      reshapeSnapshotById = new Map(reshapeStartSnapshot.map(s => [s.seatId, s]));
      reshapeRowSeats = rowSeats;
      isReshapingRow = true;
      applyReshapeDrag(reshapeDragTarget, worldX, worldY);
      renderCanvas();
      return;
    }

    if (currentTool === "resize") {
      const selectedSeats = getSelectedSeats();
      if (!selectedSeats.length) return;
      const bounds = getSelectionBounds(selectedSeats);
      if (!bounds) return;
      const handles = getResizeHandles(bounds);

      const handleSizePx = 12;
      const hitHandle = handles.find(h => {
        const screen = worldToScreen(h.x, h.y);
        return Math.abs(screen.x - canvasX) <= handleSizePx / 2 && Math.abs(screen.y - canvasY) <= handleSizePx / 2;
      });
      if (!hitHandle) return;

      isResizingSelection = true;
      hasResizedDuringDrag = false;
      resizeHandleId = hitHandle.id;
      resizeStartBounds = bounds;
      resizeStartSnapshot = captureSeatState();
      resizeSnapshotById = new Map();
      for (const snap of resizeStartSnapshot) resizeSnapshotById.set(snap.seatId, snap);

      // pivot beror pГҐ vilket handtag vi drar
      const { minX, maxX, minY, maxY, centerX, centerY } = bounds;
      const pivotMap = {
        nw: { x: maxX, y: maxY },
        n:  { x: centerX, y: maxY },
        ne: { x: minX, y: maxY },
        e:  { x: minX, y: centerY },
        se: { x: minX, y: minY },
        s:  { x: centerX, y: minY },
        sw: { x: maxX, y: minY },
        w:  { x: maxX, y: centerY }
      };
      resizePivot = pivotMap[hitHandle.id];

      const handlePoint = { x: hitHandle.x, y: hitHandle.y };
      resizeStartVector = { x: handlePoint.x - resizePivot.x, y: handlePoint.y - resizePivot.y };
      return;
    }

    if (currentTool === "select") {
      const hit = hitTestSeat(worldX, worldY);
      const additiveClick = e.metaKey || e.shiftKey || e.altKey; // enkel: ctrl används för pan, så låt t.ex. Shift/Alt/Cmd bli additive

      let selectionChanged = false;

      if (hit) {
        const group = getGroupForSeat(hit);

        if (!additiveClick) {
          // ersätt markering
          for (const s of seats) {
            if (s.selected) {
              s.selected = false;
              selectionChanged = true;
            }
          }
          for (const s of group) {
            if (!s.selected) {
              s.selected = true;
              selectionChanged = true;
            }
          }
        } else {
          // toggla grupp
          const groupSelected = group.every(s => s.selected);
          if (groupSelected) {
            for (const s of group) {
              if (s.selected) {
                s.selected = false;
                selectionChanged = true;
              }
            }
          } else {
            for (const s of group) {
              if (!s.selected) {
                s.selected = true;
                selectionChanged = true;
              }
            }
          }
        }

        if (selectionChanged) {
          pushHistorySnapshot();   // markering i historiken
          updateMoveButtonState();
          renderCanvas();
        }

        return;
      }

      // Ingen träff: starta ruta-markering
      selectionRectActive = true;
      rectStartCanvasX = canvasX;
      rectStartCanvasY = canvasY;
      rectEndCanvasX = canvasX;
      rectEndCanvasY = canvasY;

      // additive rect: om shift/meta/alt = lägg till
      selectionRectAdditive = !!(e.metaKey || e.shiftKey || e.altKey);
      return;
    }

    if (currentTool === "move") {
      // Starta drag om det finns markerade platser
      const anySelected = seats.some(s => s.selected);
      if (!anySelected) return;

      isDraggingSelection = true;
      dragStartWorldX = worldX;
      dragStartWorldY = worldY;
      dragStartSnapshot = captureSeatState(); // för relativ flytt
      return;
    }
  });

  canvas.addEventListener("contextmenu", (e) => {
    if (currentTool !== "reshape") return;
    const rect = canvas.getBoundingClientRect();
    const canvasX = e.clientX - rect.left;
    const canvasY = e.clientY - rect.top;
    const { worldX, worldY } = screenToWorld(canvasX, canvasY);
    const hit = hitTestSeat(worldX, worldY);
    if (!hit || !hit.rowId) return;
    const rows = getSelectedRows();
    if (rows.size !== 1 || !rows.has(hit.rowId)) return;
    reshapePivotSeatId = hit.seatId;
    e.preventDefault();
  });

  let selectionRectAdditive = false;

  canvas.addEventListener("mousemove", (e) => {
    const rect = canvas.getBoundingClientRect();
    const canvasX = e.clientX - rect.left;
    const canvasY = e.clientY - rect.top;
    const { worldX, worldY } = screenToWorld(canvasX, canvasY);

    // Pan
    if (isPanning) {
      const dx = e.clientX - panStartX;
      const dy = e.clientY - panStartY;
      translateX = panStartTranslateX + dx;
      translateY = panStartTranslateY + dy;
      renderCanvas();
      return;
    }

    // Rotation-drag
    if (isRotatingSelection && rotateStartSnapshot && rotatePivot) {
      const snapshotMap = rotateSnapshotById || new Map(rotateStartSnapshot.map(s => [s.seatId, s]));
      if (!rotateSnapshotById) {
        rotateSnapshotById = snapshotMap;
      }
      const currentAngle = Math.atan2(worldY - rotatePivot.y, worldX - rotatePivot.x);
      const snapStep = (5 * Math.PI) / 180;
      let delta = currentAngle - rotateStartAngle;
      if (e.ctrlKey) {
        delta = Math.round(delta / snapStep) * snapStep;
      }
      if (Math.abs(delta) > 1e-6) {
        hasRotatedDuringDrag = true;
      }
      const cosA = Math.cos(delta);
      const sinA = Math.sin(delta);

      for (const s of seats) {
        if (!s.selected) continue;
        const start = snapshotMap.get(s.seatId);
        if (!start) continue;
        const dx = start.vx - rotatePivot.x;
        const dy = start.vy - rotatePivot.y;
        const rotatedX = rotatePivot.x + dx * cosA - dy * sinA;
        const rotatedY = rotatePivot.y + dx * sinA + dy * cosA;
        s.vx = rotatedX;
        s.vy = rotatedY;
        s.centerX = rotatedX;
        s.centerY = rotatedY;
      }

      renderCanvas();
      return;
    }

    // Bend-drag
    if (isBendingSelection && bendRowsData && bendRowsData.length) {
      const rowData = bendRowsData[0];
      const rowId = bendActiveRowId || rowData.first.rowId || rowData.last.rowId || "";

      if (bendDragTarget === "start") {
        rowData.first.vx = worldX;
        rowData.first.vy = worldY;
        rowData.first.centerX = worldX;
        rowData.first.centerY = worldY;
      } else if (bendDragTarget === "end") {
        rowData.last.vx = worldX;
        rowData.last.vy = worldY;
        rowData.last.centerX = worldX;
        rowData.last.centerY = worldY;
      } else if (bendDragTarget === "anchor") {
        bendControlPoint = { x: worldX, y: worldY };
      }

      hasBentDuringDrag = true;
      applyRowBend(rowData, rowId);
      renderCanvas();
      return;
    }

    // Reshape-drag
    if (isReshapingRow && reshapeRowSeats && reshapeDragTarget && reshapeSnapshotById) {
      applyReshapeDrag(reshapeDragTarget, worldX, worldY);
      renderCanvas();
      return;
    }

    // Resize-drag
    if (isResizingSelection && resizeStartSnapshot && resizePivot && resizeStartVector) {
      const snapshotMap = resizeSnapshotById || new Map(resizeStartSnapshot.map(s => [s.seatId, s]));
      if (!resizeSnapshotById) resizeSnapshotById = snapshotMap;

      const dx = worldX - resizePivot.x;
      const dy = worldY - resizePivot.y;
      let scaleX = resizeStartVector.x === 0 ? 1 : dx / resizeStartVector.x;
      let scaleY = resizeStartVector.y === 0 ? 1 : dy / resizeStartVector.y;

      // LСҖs axlar fСЧr kant-handtag
      if (resizeHandleId === "n" || resizeHandleId === "s") {
        scaleX = 1;
      } else if (resizeHandleId === "e" || resizeHandleId === "w") {
        scaleY = 1;
      }

      // Skydda mot 0/NaN
      if (!Number.isFinite(scaleX) || Math.abs(scaleX) < 0.0001) scaleX = 0.0001 * Math.sign(scaleX || 1);
      if (!Number.isFinite(scaleY) || Math.abs(scaleY) < 0.0001) scaleY = 0.0001 * Math.sign(scaleY || 1);

      if (Math.abs(scaleX - 1) > 1e-6 || Math.abs(scaleY - 1) > 1e-6) {
        hasResizedDuringDrag = true;
      }

      for (const s of seats) {
        if (!s.selected) continue;
        const start = snapshotMap.get(s.seatId);
        if (!start) continue;
        const relX = start.vx - resizePivot.x;
        const relY = start.vy - resizePivot.y;
        const newX = resizePivot.x + relX * scaleX;
        const newY = resizePivot.y + relY * scaleY;
        s.vx = newX;
        s.vy = newY;
        s.centerX = newX;
        s.centerY = newY;
      }

      renderCanvas();
      return;
    }

    // Move-drag
    if (isDraggingSelection && dragStartSnapshot) {
      const dxWorld = worldX - dragStartWorldX;
      const dyWorld = worldY - dragStartWorldY;

      const snapshotById = new Map();
      for (const snap of dragStartSnapshot) {
        snapshotById.set(snap.seatId, snap);
      }

      for (const s of seats) {
        if (!s.selected) continue;
        const start = snapshotById.get(s.seatId);
        if (!start) continue;
        s.vx = start.vx + dxWorld;
        s.vy = start.vy + dyWorld;
        s.centerX = start.centerX + dxWorld;
        s.centerY = start.centerY + dyWorld;
      }

      renderCanvas();
      return;
    }

    // Ruta-markering live
    if (selectionRectActive) {
      rectEndCanvasX = canvasX;
      rectEndCanvasY = canvasY;
      renderCanvas();
      return;
    }

    // Hover-seat
    if (showHoverInfo && lastVisibleSeatCount <= HOVER_VISIBLE_LIMIT) {
      const hit = hitTestSeat(worldX, worldY);
      hoverSeat = hit || null;

      if (hoverSeat) {
        const screenPos = worldToScreen(hoverSeat.vx, hoverSeat.vy);
        const tooltipLines = [];
        if (hoverSeat.sectionId || hoverSeat.sectionName) {
          tooltipLines.push(
            `<strong>Sektion:</strong> ${hoverSeat.sectionName || hoverSeat.sectionId}`
          );
        }
        if (hoverSeat.rowName || hoverSeat.rowId) {
          tooltipLines.push(
            `<strong>Rad:</strong> ${hoverSeat.rowName || hoverSeat.rowId}`
          );
        }
        tooltipLines.push(
          `<strong>Plats:</strong> ${hoverSeat.name}`
        );
        if (hoverSeat.entryVia && hoverSeat.entryVia !== "-") {
          tooltipLines.push(`<strong>Entry via:</strong> ${hoverSeat.entryVia}`);
        }

        tooltipEl.innerHTML = tooltipLines.join("<br/>");
        tooltipEl.style.left = (screenPos.x + 12) + "px";
        tooltipEl.style.top = (screenPos.y + 12) + "px";
      }

      renderCanvas();
    } else {
      hoverSeat = null;
    }
  });

  canvas.addEventListener("mouseup", (e) => {
    if (isPanning) {
      isPanning = false;
      canvasContainer.classList.remove("panning");
    }

    if (isRotatingSelection) {
      const didRotate = hasRotatedDuringDrag;
      isRotatingSelection = false;
      hasRotatedDuringDrag = false;
      rotateStartSnapshot = null;
      rotateSnapshotById = null;
      rotatePivot = null;
      rotateStartAngle = 0;

      if (didRotate) {
        // Rotation klar -> historik + kod + save-knapp
        pushHistorySnapshot();
        hasUnsavedChanges = true;
        updateCodeFromSeats();
        updateSaveButton();
      }
    }

    if (isBendingSelection) {
      const didBend = hasBentDuringDrag;
      isBendingSelection = false;
      hasBentDuringDrag = false;
      bendStartSnapshot = null;
      // Behåll anchor/handle mellan interaktioner; nollställ bara drag-target
      bendDragTarget = null;

      if (didBend) {
        pushHistorySnapshot();
        hasUnsavedChanges = true;
        updateCodeFromSeats();
        updateSaveButton();
      }
    }

    if (isReshapingRow) {
      const didReshape = !!reshapeDragTarget;
      isReshapingRow = false;
      reshapeDragTarget = null;
      reshapeStartSnapshot = null;
      reshapeSnapshotById = null;
      reshapeRowSeats = null;

      if (didReshape) {
        pushHistorySnapshot();
        hasUnsavedChanges = true;
        updateCodeFromSeats();
        updateSaveButton();
      }
    }

    if (isResizingSelection) {
      const didResize = hasResizedDuringDrag;
      isResizingSelection = false;
      hasResizedDuringDrag = false;
      resizeStartSnapshot = null;
      resizeSnapshotById = null;
      resizePivot = null;
      resizeStartBounds = null;
      resizeHandleId = null;
      resizeStartVector = null;

      if (didResize) {
        pushHistorySnapshot();
        hasUnsavedChanges = true;
        updateCodeFromSeats();
        updateSaveButton();
      }
    }

    if (isDraggingSelection) {
      isDraggingSelection = false;
      dragStartSnapshot = null;

      // Flytten är klar -> historik + kod + save-knapp
      pushHistorySnapshot();
      hasUnsavedChanges = true;
      updateCodeFromSeats();
      updateSaveButton();
      return;
    }

    if (selectionRectActive) {
      selectionRectActive = false;

      const x1 = Math.min(rectStartCanvasX, rectEndCanvasX);
      const y1 = Math.min(rectStartCanvasY, rectEndCanvasY);
      const x2 = Math.max(rectStartCanvasX, rectEndCanvasX);
      const y2 = Math.max(rectStartCanvasY, rectEndCanvasY);

      const worldMinX = (x1 - translateX) / scale;
      const worldMaxX = (x2 - translateX) / scale;
      const worldMinY = (y1 - translateY) / scale;
      const worldMaxY = (y2 - translateY) / scale;

      selectByRect(
        { minX: worldMinX, maxX: worldMaxX, minY: worldMinY, maxY: worldMaxY },
        selectionRectAdditive
      );
      selectionRectAdditive = false;
    }
  });

  canvas.addEventListener("mouseleave", () => {
    hoverSeat = null;
    if (isPanning) {
      isPanning = false;
      canvasContainer.classList.remove("panning");
    }
    if (isRotatingSelection) {
      const didRotate = hasRotatedDuringDrag;
      isRotatingSelection = false;
      hasRotatedDuringDrag = false;
      rotateStartSnapshot = null;
      rotateSnapshotById = null;
      rotatePivot = null;
      rotateStartAngle = 0;

      if (didRotate) {
        pushHistorySnapshot();
        hasUnsavedChanges = true;
        updateCodeFromSeats();
        updateSaveButton();
      }
    }
    if (isBendingSelection) {
      const didBend = hasBentDuringDrag;
      isBendingSelection = false;
      hasBentDuringDrag = false;
      bendStartSnapshot = null;
      bendDragTarget = null;

      if (didBend) {
        pushHistorySnapshot();
        hasUnsavedChanges = true;
        updateCodeFromSeats();
        updateSaveButton();
      }
    }
    if (isReshapingRow) {
      const didReshape = !!reshapeDragTarget;
      isReshapingRow = false;
      reshapeDragTarget = null;
      reshapeStartSnapshot = null;
      reshapeSnapshotById = null;
      reshapeRowSeats = null;

      if (didReshape) {
        pushHistorySnapshot();
        hasUnsavedChanges = true;
        updateCodeFromSeats();
        updateSaveButton();
      }
    }
    if (isResizingSelection) {
      const didResize = hasResizedDuringDrag;
      isResizingSelection = false;
      hasResizedDuringDrag = false;
      resizeStartSnapshot = null;
      resizeSnapshotById = null;
      resizePivot = null;
      resizeStartBounds = null;
      resizeHandleId = null;
      resizeStartVector = null;

      if (didResize) {
        pushHistorySnapshot();
        hasUnsavedChanges = true;
        updateCodeFromSeats();
        updateSaveButton();
      }
    }
    if (isDraggingSelection) {
      isDraggingSelection = false;
      dragStartSnapshot = null;

      pushHistorySnapshot();
      hasUnsavedChanges = true;
      updateCodeFromSeats();
      updateSaveButton();
    }
    if (selectionRectActive) {
      selectionRectActive = false;
    }
    renderCanvas();
  });

  canvas.addEventListener("dblclick", (e) => {
    if (currentTool !== "bend") return;
    const rows = getSelectedRows();
    if (rows.size !== 1) return;

    const rowSeats = rows.values().next().value;
    if (!rowSeats || rowSeats.length < 2) return;

    const rect = canvas.getBoundingClientRect();
    const canvasX = e.clientX - rect.left;
    const canvasY = e.clientY - rect.top;
    const { worldX, worldY } = screenToWorld(canvasX, canvasY);

    const anchor = bendControlPoint;
    if (!anchor) return;
    const screenAnchor = worldToScreen(anchor.x, anchor.y);
    const hitRadius = 10;
    const dist = Math.hypot(screenAnchor.x - canvasX, screenAnchor.y - canvasY);
    if (dist > hitRadius) return;

    bendControlPoint = null;
    const rowData = computeRowEndpoints(rowSeats);
    redistributeRowLinear(rowData);

    pushHistorySnapshot();
    hasUnsavedChanges = true;
    updateCodeFromSeats();
    updateSaveButton();
    renderCanvas();
  });

  // --- Tangentbord / genvägar ---
  window.addEventListener("keydown", (e) => {
    const key = e.key.toLowerCase();
    const activeEl = document.activeElement;
    const isTextInput =
      activeEl &&
      (activeEl.tagName === "INPUT" ||
        activeEl.tagName === "TEXTAREA" ||
        activeEl.isContentEditable);

    // Ctrl/Cmd-kombinationer
    if (e.ctrlKey || e.metaKey) {
      if (key === "s") {
        e.preventDefault();
        if (!saveBtn.disabled) saveBtn.click();
        return;
      }
      if (key === "o") {
        e.preventDefault();
        openFileBtnTop.click();
        return;
      }
      if (key === "d") {
        e.preventDefault();
        deselectToolBtn.click();
        return;
      }
      if (key === "a") {
        e.preventDefault();
        selectAllSeats();
        return;
      }
      if (!e.shiftKey && key === "z") {
        e.preventDefault();
        undoLast();
        return;
      }
      return;
    }

    // Om man skriver i textfält: inga fler genvägar
    if (isTextInput) return;

    // Piltangenter: nudge
    if (e.key === "ArrowUp" || e.key === "ArrowDown" || e.key === "ArrowLeft" || e.key === "ArrowRight") {
      e.preventDefault();
      const step = e.shiftKey ? 10 : 1;
      let dx = 0, dy = 0;
      if (e.key === "ArrowUp") dy = -step;
      if (e.key === "ArrowDown") dy = step;
      if (e.key === "ArrowLeft") dx = -step;
      if (e.key === "ArrowRight") dx = step;
      const didMove = nudgeSelection(dx, dy);
      if (didMove) {
        pushHistorySnapshot();
        hasUnsavedChanges = true;
        updateCodeFromSeats();
        updateSaveButton();
        renderCanvas();
      }
      return;
    }

    // Home = zooma så att allt syns
    if (e.key === "Home") {
      e.preventDefault();
      zoomToFitAllSeats();
      return;
    }
    // Tangent 1 = zoom-to-fit (bekväm snabbe)
    if (key === "1") {
      e.preventDefault();
      zoomToFitAllSeats();
      return;
    }

    // Enkeltangenter
    switch (key) {
      case "s":
        e.preventDefault();
        modeSectionBtn.click();
        break;
      case "d":
        e.preventDefault();
        modeRowBtn.click();
        break;
      case "f":
        e.preventDefault();
        modeSeatBtn.click();
        break;
      case "i":
        e.preventDefault();
        if (seatLabelMode === "none") setSeatLabelMode("row");
        else if (seatLabelMode === "row") setSeatLabelMode("seat");
        else setSeatLabelMode("none");
        break;
      case "v":
        e.preventDefault();
        if (!moveToolBtn.disabled) moveToolBtn.click();
        break;
      case "r":
        e.preventDefault();
        if (!rotateToolBtn.disabled) rotateToolBtn.click();
        break;
      case "z":
        e.preventDefault();
        if (!resizeToolBtn.disabled) resizeToolBtn.click();
        break;
      case "b":
        e.preventDefault();
        if (!bendToolBtn.disabled) bendToolBtn.click();
        break;
      case "c":
        e.preventDefault();
        selectToolBtn.click();
        break;
      case "q":
        e.preventDefault();
        resetRowBtn.click();
        break;
      case "t":
        e.preventDefault();
        makeTableBtn.click();
        break;
      case "e":
        e.preventDefault();
        if (!reshapeRowBtn.disabled) reshapeRowBtn.click();
        break;
      default:
        break;
    }
  });

  // --- Verktyg-knappar ---
  function setButtonActive(btn, isActive) {
    btn.classList.toggle("active", isActive);
    btn.classList.toggle("c-button--active", isActive);
  }

  function setTool(tool) {
    currentTool = tool;
    setButtonActive(selectToolBtn, tool === "select");
    setButtonActive(moveToolBtn, tool === "move");
    setButtonActive(rotateToolBtn, tool === "rotate");
    setButtonActive(resizeToolBtn, tool === "resize");
    setButtonActive(bendToolBtn, tool === "bend");
    setButtonActive(reshapeRowBtn, tool === "reshape");
    if (tool === "bend") {
      ensureBendDefaults();
      renderCanvas();
    }
  }

  selectToolBtn.addEventListener("click", () => setTool("select"));
  moveToolBtn.addEventListener("click", () => {
    if (!moveToolBtn.disabled) setTool("move");
  });
  rotateToolBtn.addEventListener("click", () => {
    if (!rotateToolBtn.disabled) setTool("rotate");
  });
  resizeToolBtn.addEventListener("click", () => {
    if (!resizeToolBtn.disabled) setTool("resize");
  });
  bendToolBtn.addEventListener("click", () => {
    if (!bendToolBtn.disabled) setTool("bend");
  });
  reshapeRowBtn.addEventListener("click", () => {
    if (!reshapeRowBtn.disabled) setTool("reshape");
  });
  resetRowBtn.addEventListener("click", () => {
    if (resetRowBtn.disabled) return;
    const didReset = resetSelectedRowsLinear();
    if (didReset) {
      pushHistorySnapshot();
      hasUnsavedChanges = true;
      updateCodeFromSeats();
      updateSaveButton();
      renderCanvas();
    }
  });
  makeTableBtn.addEventListener("click", () => {
    if (makeTableBtn.disabled) return;
    const didMake = makeTableFromSelectedRows();
    if (didMake) {
      pushHistorySnapshot();
      hasUnsavedChanges = true;
      updateCodeFromSeats();
      updateSaveButton();
      renderCanvas();
    }
  });

  deselectToolBtn.addEventListener("click", () => {
    let changed = false;
    for (const s of seats) {
      if (s.selected) {
        s.selected = false;
        changed = true;
      }
    }
    if (changed) {
      pushHistorySnapshot();    // ångra deselect
      updateMoveButtonState();
      renderCanvas();
    }
    setTool("select");
  });

  // --- Markeringsnivå-knappar ---
  function setSelectionMode(mode) {
    selectionMode = mode;
    setButtonActive(modeSectionBtn, mode === "section");
    setButtonActive(modeRowBtn, mode === "row");
    setButtonActive(modeSeatBtn, mode === "seat");
  }

  modeSectionBtn.addEventListener("click", () => setSelectionMode("section"));
  modeRowBtn.addEventListener("click", () => setSelectionMode("row"));
  modeSeatBtn.addEventListener("click", () => setSelectionMode("seat"));

  // --- Bakgrundsbild ---
  bgLoadBtn.addEventListener("click", () => bgFileInput.click());
  bgFileInput.addEventListener("change", () => {
    const file = bgFileInput.files && bgFileInput.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = async (e) => {
      const dataUrl = e.target?.result;
      if (typeof dataUrl === "string") {
        await loadBackgroundFromDataUrl(dataUrl);
      }
    };
    reader.readAsDataURL(file);
  });
  bgEnabledToggle.addEventListener("change", (e) => {
    setBackgroundEnabled(e.target.checked);
  });
  bgOpacityRange.addEventListener("input", (e) => {
    const val = parseFloat(e.target.value);
    setBackgroundOpacity(val);
  });
  bgScaleRange.addEventListener("input", (e) => {
    const val = parseFloat(e.target.value);
    setBackgroundScale(val);
  });
  viewGrayToggle?.addEventListener("change", (e) => {
    renderGrayscale = e.target.checked;
    renderCanvas();
  });
  viewHoverToggle?.addEventListener("change", (e) => {
    showHoverInfo = e.target.checked;
    if (!showHoverInfo) {
      hoverSeat = null;
      tooltipEl.style.display = "none";
    }
    renderCanvas();
  });
  viewSectionNamesToggle?.addEventListener("change", (e) => {
    showSectionNames = e.target.checked;
    renderCanvas();
  });
  [viewSeatLabelNone, viewSeatLabelRow, viewSeatLabelSeat].forEach((el) => {
    el?.addEventListener("change", (e) => {
      if (!e.target.checked) return;
      setSeatLabelMode(e.target.value || "none", false);
    });
  });

  // --- Align-knappar ---
  function handleAlign(mode) {
    const didAlign = alignSelectedSeats(mode);
    if (didAlign) {
      pushHistorySnapshot();
      hasUnsavedChanges = true;
      updateCodeFromSeats();
      updateSaveButton();
      renderCanvas();
    }
  }
  alignTopBtn.addEventListener("click", () => handleAlign("top"));
  alignBottomBtn.addEventListener("click", () => handleAlign("bottom"));
  alignLeftBtn.addEventListener("click", () => handleAlign("left"));
  alignRightBtn.addEventListener("click", () => handleAlign("right"));
  alignCenterHBtn.addEventListener("click", () => handleAlign("centerH"));
  alignCenterVBtn.addEventListener("click", () => handleAlign("centerV"));

  // --- Sektion: helpers & modal ---
  function newSeat(name = "1") {
    return { id: crypto.randomUUID ? crypto.randomUUID() : String(Math.random()), name };
  }

  function newRow(name = "Rad") {
    return { id: crypto.randomUUID ? crypto.randomUUID() : String(Math.random()), name, seats: [newSeat("1"), newSeat("2")] };
  }

  function computeNextSectionId() {
    const ids = new Set();
    sectionNames.forEach((_, key) => ids.add(key));
    seats.forEach(s => { if (s.sectionId) ids.add(s.sectionId); });
    sectionDrafts?.forEach(d => { if (d.sectionId) ids.add(d.sectionId); });
    let maxMajor = 0;
    ids.forEach(id => {
      const parts = String(id).split(".");
      const major = parseInt(parts[0], 10);
      if (Number.isFinite(major) && major > maxMajor) maxMajor = major;
    });
    const nextMajor = maxMajor > 0 ? maxMajor + 1 : 1;
    return `${nextMajor}.1`;
  }

  function buildSectionDraftsFromSeats() {
    const bySection = new Map();
    const compareIdSegments = (idA, idB) => {
      const aParts = String(idA).split(".").map((p) => parseInt(p, 10));
      const bParts = String(idB).split(".").map((p) => parseInt(p, 10));
      const len = Math.max(aParts.length, bParts.length);
      for (let i = 0; i < len; i++) {
        const av = aParts[i] ?? 0;
        const bv = bParts[i] ?? 0;
        if (av !== bv) return av - bv;
      }
      return 0;
    };
    seats.forEach((s) => {
      if (!s.sectionId) return;
      if (!bySection.has(s.sectionId)) {
        bySection.set(s.sectionId, {
          sectionId: s.sectionId,
          sectionName: sectionNames.get(s.sectionId) || s.sectionName || s.sectionId,
          color: sectionColors.get(s.sectionId) || "#14a0f4",
          rows: new Map()
        });
      }
      const draft = bySection.get(s.sectionId);
      if (!draft.rows.has(s.rowId)) {
        draft.rows.set(s.rowId, { id: s.rowId, name: s.rowName || s.rowId, seats: [] });
      }
      draft.rows.get(s.rowId).seats.push({ id: s.seatId, name: s.name || s.seatId });
    });

    // Convert maps to arrays and sort row/seat by id natural order
    return Array.from(bySection.values()).map((draft) => ({
      sectionId: draft.sectionId,
      sectionName: draft.sectionName,
      color: draft.color,
      rows: Array.from(draft.rows.values()).map((row) => ({
        id: row.id,
        name: row.name,
        seats: row.seats.sort((a, b) => compareIdSegments(a.id, b.id))
      }))
    })).sort((a, b) => a.sectionId.localeCompare(b.sectionId));
  }

  function resetSectionDrafts() {
    sectionDrafts = buildSectionDraftsFromSeats();
    sectionDrafts.forEach((d) => {
      if (sectionRawText.has(d.sectionId)) {
        const txt = sectionRawText.get(d.sectionId) || "";
        const parsed = parseRowsText(txt);
        d.rows = parsed.rows;
        d.rawRowText = txt;
      } else {
        d.rawRowText = rowsToText(d.rows || []);
      }
    });
    if (!sectionDrafts.length) {
      sectionDrafts.push({
        sectionId: computeNextSectionId(),
        sectionName: "",
        color: "#14a0f4",
        rows: [newRow("Rad 1")]
      });
    }
    activeSectionDraftId = sectionDrafts[0].sectionId;
    sectionDirty = false;
  }

  function setSectionDirty(isDirty) {
    sectionDirty = isDirty;
    if (sectionDirtyFlag) {
      sectionDirtyFlag.textContent = isDirty ? "Ej sparade ändringar" : "Sparad";
      sectionDirtyFlag.style.color = isDirty ? "#c12e44" : "#5b6673";
    }
  }

  function rowsToText(rows) {
    return rows.map((row) => row.rawTextLine || "").filter(Boolean).join("\n");
  }

  function parseRowsText(text) {
    const lines = text.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
    const parsed = [];
    const errors = [];
    lines.forEach((line, lineIdx) => {
      if (!line.includes(":")) {
        errors.push(`Saknar kolon (:) i rad: "${line}"`);
        return;
      }
      const [rawName, rest] = line.split(":", 2);
      const rowName = rawName.trim() || "Rad";
      const rowBlocks = rest.split("||"); // double pipe = ny rad-id, samma Y men +1 gap i X
      let slotCursor = 0; // X-slot över hela textraden
      rowBlocks.forEach((block) => {
        const blockText = block.trim();
        const intervals = blockText.split("|").map(s => s.trim()).filter(Boolean);
        const items = [];
        const seatsArr = [];
        intervals.forEach((seg, idx) => {
          const parts = seg.split(/[,;-]/).map(x => x.trim()).filter(Boolean);
          if (parts.length === 1) {
            const n = Number(parts[0]);
            if (Number.isFinite(n) && Number.isInteger(n)) {
              const seatObj = newSeat(String(n));
              items.push({ ...seatObj, pos: slotCursor });
              seatsArr.push(seatObj);
              slotCursor += 1;
            } else {
              errors.push(`Ogiltigt nummer "${parts[0]}" i rad "${rowName}" (rad ${lineIdx + 1})`);
            }
          } else if (parts.length >= 2) {
            const start = Number(parts[0]);
            const end = Number(parts[1]);
            if (!Number.isInteger(start) || !Number.isInteger(end)) {
              errors.push(`Ogiltigt intervall "${seg}" i rad "${rowName}" (rad ${lineIdx + 1})`);
              return;
            }
            const step = start <= end ? 1 : -1;
            for (let v = start; step === 1 ? v <= end : v >= end; v += step) {
              const seatObj = newSeat(String(v));
              items.push({ ...seatObj, pos: slotCursor });
              seatsArr.push(seatObj);
              slotCursor += 1;
            }
          }
          if (idx < intervals.length - 1) {
            items.push({ id: crypto.randomUUID ? crypto.randomUUID() : String(Math.random()), name: "", isGap: true, pos: slotCursor });
            slotCursor += 1;
          }
        });
        parsed.push({
          id: crypto.randomUUID ? crypto.randomUUID() : String(Math.random()),
          name: rowName,
          seats: seatsArr.length ? seatsArr : [newSeat("1")],
          items: items.length ? items : [{ ...newSeat("1"), pos: slotCursor }],
          rowLine: lineIdx,
          rawTextLine: `${rowName}: ${rest}`
        });
        // Lägg ett tomt slot i X-led mellan blocken
        slotCursor += 1;
      });
    });
    return { rows: parsed.length ? parsed : [newRow("Rad 1")], errors };
  }

  function renderSectionPreview(draft) {
    if (!sectionPreviewCanvas) return;
    const ctxPrev = sectionPreviewCanvas.getContext("2d");
    if (!ctxPrev) return;

    // GruppЫra rader per radbrytning (rowLine)
    const groups = new Map();
    draft.rows.forEach((row, idx) => {
      const key = Number.isFinite(row.rowLine) ? row.rowLine : idx;
      if (!groups.has(key)) groups.set(key, []);
      groups.get(key).push(row);
    });
    const lines = Array.from(groups.entries()).sort((a, b) => a[0] - b[0]);
    const slotSize = 40;
    const rowHeight = 50;
    const marginX = 70;
    const marginY = 32;

    let maxOffset = 0;
    lines.forEach(([, rows]) => {
      rows.forEach((row) => {
        const items = row.items && row.items.length ? row.items : row.seats.map((s, i) => ({ ...s, pos: i }));
        items.forEach((it) => {
          if (Number.isFinite(it.pos) && it.pos > maxOffset) maxOffset = it.pos;
        });
      });
    });
    const contentWidth = marginX * 2 + (maxOffset + 1) * slotSize;
    const contentHeight = marginY * 2 + lines.length * rowHeight;
    const cssWidth = sectionPreviewCanvas.clientWidth || 900;
    const targetHeight = 320;
    const scaleX = contentWidth > 0 ? Math.min(1, cssWidth / contentWidth) : 1;
    const scaleY = contentHeight > 0 ? Math.min(1, targetHeight / contentHeight) : 1;
    const scale = Math.min(scaleX, scaleY);
    const dpr = window.devicePixelRatio || 1;
    const finalWidth = cssWidth;
    sectionPreviewCanvas.width = finalWidth * dpr;
    sectionPreviewCanvas.height = targetHeight * dpr;
    sectionPreviewCanvas.style.height = `${targetHeight}px`;
    sectionPreviewCanvas.style.width = "100%";

    ctxPrev.save();
    ctxPrev.scale(dpr * scale, dpr * scale);
    const clearW = finalWidth / scale;
    const clearH = targetHeight / scale;
    ctxPrev.clearRect(0, 0, clearW, clearH);
    ctxPrev.fillStyle = "#f7faff";
    ctxPrev.fillRect(0, 0, clearW, clearH);

    const labelColor = "#2e3c47";
    // Färginställningar för tydliga nummer
    const seatHex = draft.color || "#14a0f4";
    const seatFill = "#ffffff";
    const seatStroke = seatHex;
    const textColor = "#0f1d2a";

    ctxPrev.lineWidth = 1;
    ctxPrev.font = "12px 'Segoe UI', sans-serif";
    ctxPrev.textBaseline = "middle";

    lines.forEach(([, rows], lineIdx) => {
      const baseY = marginY + lineIdx * rowHeight;
      const displayRowNumber = (rows[0].name || "").replace(/^Rad\s*/i, "").trim() || `${lineIdx + 1}`;

      // Rad-etikett
      ctxPrev.fillStyle = labelColor;
      ctxPrev.fillText(displayRowNumber, 16, baseY);

      // Samla alla chips pЪ linjen
      const chips = [];
      rows.forEach((row) => {
        const items = row.items && row.items.length ? row.items : row.seats.map((s, i) => ({ ...s, pos: i }));
        items.forEach((it) => chips.push({ offset: it.pos ?? 0, seat: it }));
      });
      chips.sort((a, b) => a.offset - b.offset);

      let lastOffset = -1;
      chips.forEach(({ seat, offset }) => {
        const gapCount = offset - (lastOffset + 1);
        for (let g = 0; g < gapCount; g++) {
          const gx = marginX + (lastOffset + 1 + g) * slotSize;
          const gy = baseY;
          ctxPrev.strokeStyle = "#cbd7e6";
          ctxPrev.setLineDash([4, 4]);
          ctxPrev.beginPath();
          ctxPrev.arc(gx, gy, 14, 0, Math.PI * 2);
          ctxPrev.stroke();
          ctxPrev.setLineDash([]);
        }

        const x = marginX + offset * slotSize;
        const y = baseY;
        if (seat.isGap) {
          ctxPrev.strokeStyle = "#cbd7e6";
          ctxPrev.setLineDash([4, 4]);
          ctxPrev.beginPath();
          ctxPrev.arc(x, y, 14, 0, Math.PI * 2);
          ctxPrev.stroke();
          ctxPrev.setLineDash([]);
        } else {
          ctxPrev.fillStyle = seatFill;
          ctxPrev.strokeStyle = seatStroke;
          ctxPrev.beginPath();
          ctxPrev.arc(x, y, 14, 0, Math.PI * 2);
          ctxPrev.fill();
          ctxPrev.stroke();

          ctxPrev.fillStyle = textColor;
          ctxPrev.font = "12px 'Segoe UI', sans-serif";
          ctxPrev.textAlign = "center";
          ctxPrev.fillText(seat.name || "", x, y);
        }
        lastOffset = offset;
      });
    });
    ctxPrev.restore();
  }

  function hydrateDraftRowsFromRaw(draft) {
    const rawText = (draft.sectionId && sectionRawText.get(draft.sectionId)) ?? draft.rawRowText ?? "";
    if (!rawText.trim()) return { ok: true };
    const parsed = parseRowsText(rawText);
    if (parsed.errors.length) {
      return { ok: false, errors: parsed.errors, rawText };
    }
    draft.rows = parsed.rows;
    draft.rawRowText = rawText;
    if (draft.sectionId) sectionRawText.set(draft.sectionId, rawText);
    return { ok: true };
  }

  function renderRowsPreview(draft) {
    sectionRowsEditor.innerHTML = "";
    const groups = new Map();
    draft.rows.forEach((row, idx) => {
      const key = Number.isFinite(row.rowLine) ? row.rowLine : idx;
      if (!groups.has(key)) groups.set(key, []);
      groups.get(key).push(row);
    });

    Array.from(groups.entries()).sort((a, b) => a[0] - b[0]).forEach(([lineIdx, rows]) => {
      const rowEl = document.createElement("div");
      rowEl.className = "row-card";
      const displayRowNumber = (rows[0].name || "").replace(/^Rad\s*/i, "").trim() || `${lineIdx + 1}`;

      // samla chips med offset och lägg in gap-chip när det saknas offset (dubbla pipes)
      const chips = [];
      rows.forEach((row) => {
        const items = row.items && row.items.length ? row.items : row.seats.map((s, i) => ({ ...s, pos: i }));
        items.forEach((it) => chips.push({ offset: it.pos ?? 0, seat: it }));
      });
      chips.sort((a, b) => a.offset - b.offset);
      let lastOffset = -1;
      const chipHtml = [];
      chips.forEach(({ seat, offset }) => {
        const gapCount = offset - (lastOffset + 1);
        for (let g = 0; g < gapCount; g++) {
          chipHtml.push(`
            <span class="seat-chip seat-chip--gap" title="Tomt utrymme">
              <span>·</span>
            </span>
          `);
        }
        chipHtml.push(`
          <span class="seat-chip ${seat.isGap ? "seat-chip--gap" : ""}">
            ${seat.isGap ? `<span title="Tomt utrymme">·</span>` : `<input data-role="seat-name" value="${seat.name || ""}" />`}
          </span>
        `);
        lastOffset = offset;
      });
      rowEl.innerHTML = `
        <div class="row-card__line">
          <strong style="min-width:60px;display:inline-block;">${displayRowNumber}</strong>
          <span class="u-font--small" style="display:flex;flex-wrap:wrap;gap:0.25rem;align-items:center;">
            ${chipHtml.join("")}
          </span>
        </div>
      `;
      sectionRowsEditor.appendChild(rowEl);
    });
  }

  function renderSectionCards(filter = "") {
    if (!sectionCardsEl) return;
    sectionCardsEl.innerHTML = "";
    const lower = filter.trim().toLowerCase();
    sectionDrafts
      .filter(d => !lower || d.sectionId.toLowerCase().includes(lower) || (d.sectionName || "").toLowerCase().includes(lower))
      .forEach((draft) => {
        const card = document.createElement("div");
        card.className = "section-card" + (draft.sectionId === activeSectionDraftId ? " section-card--active" : "");
        card.dataset.sectionId = draft.sectionId;

        const colorDot = document.createElement("div");
        colorDot.className = "section-card__color";
        colorDot.style.background = draft.color || "#14a0f4";

        const body = document.createElement("div");
        body.className = "section-card__body";

        const title = document.createElement("div");
        title.className = "section-card__name";
        title.textContent = draft.sectionName || draft.sectionId;

        const meta = document.createElement("div");
        meta.className = "section-card__meta";
        const rowCount = draft.rows.length;
        const seatCount = draft.rows.reduce((sum, r) => sum + (r.seats?.length || 0), 0);
        meta.innerHTML = `<span>${rowCount} rader</span><span>${seatCount} platser</span>`;

        body.appendChild(title);
        body.appendChild(meta);

        card.appendChild(colorDot);
        card.appendChild(body);
        sectionCardsEl.appendChild(card);
      });
  }

  function getActiveDraft() {
    return sectionDrafts.find((d) => d.sectionId === activeSectionDraftId) || null;
  }

  function renderSectionDetail() {
    const draft = getActiveDraft();
    if (!draft || !sectionEditId || !sectionEditName || !sectionEditColor || !sectionRowsEditor) return;
    sectionEditId.value = draft.sectionId || "";
    sectionEditName.value = draft.sectionName || "";
    sectionEditColor.value = draft.color || "#14a0f4";
    const rawTxt = draft.rawRowText || sectionRawText.get(draft.sectionId) || rowsToText(draft.rows || []);
    if (sectionRowText && document.activeElement !== sectionRowText) {
      sectionRowText.value = rawTxt;
    }
    draft.rawRowText = rawTxt;
    // Säkerställ att rows matchar den text som visas
    if (rawTxt && rawTxt.trim()) {
      const parsed = parseRowsText(rawTxt);
      if (!parsed.errors.length) {
        draft.rows = parsed.rows;
      }
      if (sectionRowErrors) {
        sectionRowErrors.textContent = parsed.errors.join("\n");
      }
    } else if (sectionRowErrors) {
      sectionRowErrors.textContent = "";
    }

    const existingSeats = seats.some((s) => s.sectionId === draft.sectionId);
    sectionEditId.disabled = existingSeats;
    if (sectionEditHint) {
      sectionEditHint.textContent = existingSeats
        ? "Redigering av befintlig sektion – namn går att ändra. Strukturändringar begränsade."
        : "Ny sektion – du kan lägga till rader och platser.";
    }

    renderRowsPreview(draft);
    renderSectionPreview(draft);
  }

  function openSectionManager() {
    resetSectionDrafts();
    renderSectionCards();
    renderSectionDetail();
    setSectionDirty(false);
    if (sectionManagerOverlay) sectionManagerOverlay.style.display = "flex";
  }

  function closeSectionManager() {
    if (sectionManagerOverlay) sectionManagerOverlay.style.display = "none";
  }

  function addNewDraftFromTemplate() {
    const newDraft = {
      sectionId: computeNextSectionId(),
      sectionName: "",
      color: "#14a0f4",
      rows: [newRow("Rad 1")]
    };
    sectionDrafts.push(newDraft);
    activeSectionDraftId = newDraft.sectionId;
    setSectionDirty(true);
    renderSectionCards(sectionSearchInput?.value || "");
    renderSectionDetail();
  }

  function handleRowAdd() {
    const draft = getActiveDraft();
    if (!draft) return;
    draft.rows.push(newRow(`Rad ${draft.rows.length + 1}`));
    setSectionDirty(true);
    renderSectionDetail();
    renderSectionCards(sectionSearchInput?.value || "");
  }

  function handleRowRemove(rowId) {
    const draft = getActiveDraft();
    if (!draft) return;
    draft.rows = draft.rows.filter((r) => r.id !== rowId);
    if (!draft.rows.length) draft.rows = [newRow("Rad 1")];
    setSectionDirty(true);
    renderSectionDetail();
    renderSectionCards(sectionSearchInput?.value || "");
  }

  function handleSeatAdd(rowId) {
    const draft = getActiveDraft();
    if (!draft) return;
    const row = draft.rows.find((r) => r.id === rowId);
    if (!row) return;
    row.seats.push(newSeat(String(row.seats.length + 1)));
    setSectionDirty(true);
    renderSectionDetail();
    renderSectionCards(sectionSearchInput?.value || "");
  }

  function setRowSeatCount(rowId, targetCount) {
    const draft = getActiveDraft();
    if (!draft) return;
    const row = draft.rows.find((r) => r.id === rowId);
    if (!row) return;
    const count = Math.max(1, Math.floor(targetCount || 0));
    if (count === row.seats.length) return;
    if (count > row.seats.length) {
      const start = row.seats.length;
      for (let i = start; i < count; i++) {
        row.seats.push(newSeat(String(i + 1)));
      }
    } else {
      row.seats = row.seats.slice(0, count);
    }
    setSectionDirty(true);
    renderSectionDetail();
    renderSectionCards(sectionSearchInput?.value || "");
  }

  function handleSeatRemove(rowId, seatId) {
    const draft = getActiveDraft();
    if (!draft) return;
    const row = draft.rows.find((r) => r.id === rowId);
    if (!row) return;
    row.seats = row.seats.filter((s) => s.id !== seatId);
    if (!row.seats.length) row.seats.push(newSeat("1"));
    setSectionDirty(true);
    renderSectionDetail();
    renderSectionCards(sectionSearchInput?.value || "");
  }

  function splitRowIntoSegments(row) {
    return [row.seats];
  }

  function materializeNewSection(draft) {
    computeSectionOutlinesFromSeats(0);
    const baseX = layoutBounds ? layoutBounds.maxX + 200 : 0;
    const baseY = layoutBounds ? layoutBounds.minY : 0;
    const seatSpacing = 120;
    const rowSpacing = 180;
    const timestamp = buildTimestamp();

    const sectionId = (draft.sectionId || computeNextSectionId()).trim();
    const sectionName = (draft.sectionName || sectionId).trim();
    sectionNames.set(sectionId, sectionName);

    originalLines.push(`${timestamp}|SectionAdd|SectionId=${sectionId}|Name=${sectionName}`);

    let rowCounter = 1;
    draft.rows.forEach((row, rowIdx) => {
      const yIndex = Number.isFinite(row.rowLine) ? row.rowLine : rowIdx;
      const rowName = (row.name || `Rad ${rowCounter}`).trim();
      const rowId = `${sectionId}.${rowCounter}`;
      originalLines.push(`${timestamp}|RowAdd|RowId=${rowId}|Name=${rowName}`);

      const items = row.items && row.items.length ? row.items : row.seats.map((s, i) => ({ ...s, pos: i }));
      let seatOrdinal = 1;
      items.forEach((seat) => {
        if (seat.isGap) return;
        const seatName = (seat.name || `${seatOrdinal}`).trim();
        const seatId = `${sectionId}.${rowCounter}.${seatOrdinal}`;
        const centerX = baseX + (seat.pos ?? (seatOrdinal - 1)) * seatSpacing;
        const centerY = baseY + yIndex * rowSpacing;
        const seatObj = {
          seatId,
          name: seatName,
          sectionId,
          rowId,
          sectionName,
          rowName,
          centerX,
          centerY,
          vx: centerX,
          vy: centerY,
          radius: 10,
          rotation: 0,
          width: 100,
          entryVia: "-",
          goodness: 0,
          attribute: "",
          timestamp,
          selected: false,
          lineIndex: originalLines.length
        };
        originalLines.push(buildSeatLine(seatObj));
        seats.push(seatObj);
        seatIdToLineIndex.set(seatId, seatObj.lineIndex);
        seatOrdinal += 1;
      });
      rowCounter += 1;
    });
  }

  function removeSectionData(sectionId) {
    // Ta bort seats för sektionen
    seats = seats.filter(s => s.sectionId !== sectionId);

    // Filtrera originalLines från Section/Row/Seat/Outline som tillhör sektionen
    const matchSection = (line) => {
      if (!line) return false;
      const outlineCode = sectionIdToOutlineCode(sectionId);
      return line.includes(`SectionId=${sectionId}`) ||
             line.includes(`RowId=${sectionId}.`) ||
             line.includes(`SeatId=${sectionId}.`) ||
             line.includes(`<Outline|${outlineCode}|`);
    };
    originalLines = originalLines.filter(line => !matchSection(line));
    outlines = outlines.filter(o => o.sectionId !== sectionId);

    // Bygg om index-map
    seatIdToLineIndex = new Map();
    originalLines.forEach((line, idx) => {
      if (line.includes("|SeatAdd|")) {
        const seatIdMatch = line.match(/SeatId=([^|]+)/);
        if (seatIdMatch) {
          seatIdToLineIndex.set(seatIdMatch[1], idx);
        }
      }
    });
  }

  function applyDraftToExisting(draft) {
    const sectionId = draft.sectionId;
    const draftRows = draft.rows || [];
    sectionNames.set(sectionId, draft.sectionName || sectionId);
    const grouped = new Map();
    seats.forEach((s) => {
      if (s.sectionId === sectionId) {
        if (!grouped.has(s.rowId)) grouped.set(s.rowId, []);
        grouped.get(s.rowId).push(s);
      }
    });
    const compareIdSegments = (idA, idB) => {
      const aParts = String(idA).split(".").map((p) => parseInt(p, 10));
      const bParts = String(idB).split(".").map((p) => parseInt(p, 10));
      const len = Math.max(aParts.length, bParts.length);
      for (let i = 0; i < len; i++) {
        const av = aParts[i] ?? 0;
        const bv = bParts[i] ?? 0;
        if (av !== bv) return av - bv;
      }
      return 0;
    };

    draftRows.forEach((row) => {
      const rowSeats = grouped.get(row.id);
      if (!rowSeats) return;
      rowSeats.sort((a, b) => compareIdSegments(a.seatId, b.seatId));
      rowSeats.forEach((seatObj, idx) => {
        seatObj.rowName = row.name || seatObj.rowName;
        seatObj.sectionName = draft.sectionName || seatObj.sectionName;
        if (row.seats[idx]) {
          seatObj.name = row.seats[idx].name || seatObj.name;
        }
      });
    });
  }

  function saveActiveSection() {
    const activeDraft = getActiveDraft();
    if (activeDraft && sectionEditId && sectionEditName && sectionEditColor) {
      activeDraft.sectionId = (sectionEditId.value || activeDraft.sectionId || "").trim();
      activeDraft.sectionName = (sectionEditName.value || activeDraft.sectionName || "").trim();
      activeDraft.color = sectionEditColor.value || activeDraft.color || "#14a0f4";
    }

    const missingNames = sectionDrafts.filter(d => !d.sectionName || !d.sectionName.trim());
    if (missingNames.length) {
      alert("Alla sektioner måste ha namn innan du kan spara.");
      return;
    }

    const validationErrors = [];
    sectionDrafts.forEach((draft) => {
      const res = hydrateDraftRowsFromRaw(draft);
      if (!res.ok) {
        validationErrors.push(`${draft.sectionName || draft.sectionId || "Sektion"}: ${res.errors.join("; ")}`);
        if (draft.sectionId === activeSectionDraftId && sectionRowErrors) {
          sectionRowErrors.textContent = res.errors.join("\n");
          if (sectionRowText && document.activeElement !== sectionRowText) {
            sectionRowText.value = res.rawText ?? sectionRowText.value;
          }
        }
      }
    });
    if (validationErrors.length) {
      alert("Kan inte spara förrän radformatet är korrekt:\n" + validationErrors.join("\n"));
      return;
    }

    let addedNew = false;
    let anyChanged = false;
    sectionDrafts.forEach((draft) => {
      if (!draft.sectionId) return;
      const exists = seats.some((s) => s.sectionId === draft.sectionId);
      if (exists) {
        removeSectionData(draft.sectionId);
        materializeNewSection(draft);
        anyChanged = true;
      } else {
        materializeNewSection(draft);
        addedNew = true;
        anyChanged = true;
      }
      sectionColors.set(draft.sectionId, draft.color || "#14a0f4");
    });

    if (anyChanged) {
      rebuildSectionColors();
      const uniqueSections = new Set(seats.map(s => s.sectionId).filter(Boolean));
      const uniqueRows = new Set(seats.map(s => s.rowId).filter(Boolean));
      seatCountEl.textContent = seats.length.toString();
      sectionCountEl.textContent = uniqueSections.size.toString();
      rowCountEl.textContent = uniqueRows.size.toString();

      updateCodeFromSeats();
      hasUnsavedChanges = true;
      updateSaveButton();
      pushHistorySnapshot();
      renderCanvas();
      if (addedNew) {
        zoomToFitAllSeats();
      }
    }

    setSectionDirty(false);
    renderSectionCards(sectionSearchInput?.value || "");
  }

// --- Kod-modal ---
  let codeModalOriginal = "";
  function openCodeModal() {
    codeModalOriginal = codePane.value || "";
    codeModalTextarea.value = codeModalOriginal;
    codeModalApply.disabled = true;
    codeModalOverlay.style.display = "flex";
  }
  function closeCodeModal() {
    codeModalOverlay.style.display = "none";
  }
  openCodeModalBtn?.addEventListener("click", openCodeModal);
  codeModalClose?.addEventListener("click", closeCodeModal);
  codeModalOverlay?.addEventListener("click", (e) => {
    if (e.target === codeModalOverlay) closeCodeModal();
  });
  codeModalTextarea?.addEventListener("input", () => {
    codeModalApply.disabled = codeModalTextarea.value === codeModalOriginal;
  });
  codeModalApply?.addEventListener("click", () => {
    const newText = codeModalTextarea.value;
    codePane.value = newText;
    parseTlt(newText);
    hasUnsavedChanges = true;
    updateSaveButton();
    closeCodeModal();
  });

  // --- Section manager events ---
  openSectionManagerBtn?.addEventListener("click", openSectionManager);
  sectionManagerClose?.addEventListener("click", () => {
    if (!sectionDirty) {
      closeSectionManager();
      return;
    }
    if (confirm("Stäng utan att spara?")) closeSectionManager();
  });
  sectionManagerOverlay?.addEventListener("click", (e) => {
    if (e.target === sectionManagerOverlay) closeSectionManager();
  });

  sectionCreateBtn?.addEventListener("click", () => {
    addNewDraftFromTemplate();
  });

  function syncRowsFromText() {
    const draft = getActiveDraft();
    if (!draft) return;
    const rawText = sectionRowText?.value || "";
    const parsed = parseRowsText(rawText);
    draft.rows = parsed.rows;
    draft.rawRowText = rawText;
    if (draft.sectionId) sectionRawText.set(draft.sectionId, rawText);
    if (sectionRowErrors) {
      sectionRowErrors.textContent = parsed.errors.join("\n");
    }
    setSectionDirty(true);
    renderSectionDetail();
    renderSectionCards(sectionSearchInput?.value || "");
  }

  parseRowsBtn?.addEventListener("click", syncRowsFromText);
  sectionRowText?.addEventListener("input", () => {
    // Låt användaren skriva fritt; rensa bara felmeddelande tills man klickar "Uppdatera rader"
    const draft = getActiveDraft();
    if (draft && sectionRowText) {
      draft.rawRowText = sectionRowText.value;
    }
    if (sectionRowErrors) sectionRowErrors.textContent = "";
  });

  sectionCardsEl?.addEventListener("click", (e) => {
    const card = e.target.closest(".section-card");
    if (!card) return;
    activeSectionDraftId = card.dataset.sectionId;
    renderSectionCards(sectionSearchInput?.value || "");
    renderSectionDetail();
  });

  sectionSearchInput?.addEventListener("input", (e) => {
    renderSectionCards(e.target.value || "");
  });

  sectionEditId?.addEventListener("input", (e) => {
    const draft = getActiveDraft();
    if (!draft) return;
    draft.sectionId = e.target.value;
    activeSectionDraftId = draft.sectionId;
    setSectionDirty(true);
    renderSectionCards(sectionSearchInput?.value || "");
  });

  sectionEditName?.addEventListener("input", (e) => {
    const draft = getActiveDraft();
    if (!draft) return;
    draft.sectionName = e.target.value;
    setSectionDirty(true);
    renderSectionCards(sectionSearchInput?.value || "");
  });

  sectionEditColor?.addEventListener("input", (e) => {
    const draft = getActiveDraft();
    if (!draft) return;
    draft.color = e.target.value;
    setSectionDirty(true);
    renderSectionCards(sectionSearchInput?.value || "");
  });

  addRowInlineBtn?.addEventListener("click", () => {
    const draft = getActiveDraft();
    if (!draft) return;
    const exists = seats.some((s) => s.sectionId === draft.sectionId);
    if (exists) {
      alert("Strukturändring av befintliga sektioner är begränsad. Skapa en ny sektion för större ändringar.");
      return;
    }
    handleRowAdd();
  });

  sectionRowsEditor?.addEventListener("input", (e) => {
    const rowEl = e.target.closest(".row-card");
    const draft = getActiveDraft();
    if (!rowEl || !draft) return;
    const rowId = rowEl.dataset.rowId;
    const row = draft.rows.find((r) => r.id === rowId);
    if (!row) return;
    if (e.target.dataset.role === "row-name") {
      row.name = e.target.value;
      setSectionDirty(true);
      renderSectionCards(sectionSearchInput?.value || "");
    } else if (e.target.dataset.role === "seat-name") {
      const seatId = e.target.closest(".seat-chip")?.dataset.seatId;
      const seat = row.seats.find((s) => s.id === seatId);
      if (seat) {
        seat.name = e.target.value;
        setSectionDirty(true);
      }
    }
  });

  sectionRowsEditor?.addEventListener("click", (e) => {
    const rowEl = e.target.closest(".row-card");
    const draft = getActiveDraft();
    if (!rowEl || !draft) return;
    const rowId = rowEl.dataset.rowId;
    const exists = seats.some((s) => s.sectionId === draft.sectionId);

    if (e.target.dataset.role === "row-seat-inc") {
      if (exists) {
        alert("Strukturändring av befintliga sektioner är begränsad. Skapa en ny sektion för större ändringar.");
        return;
      }
      handleSeatAdd(rowId);
    }
    if (e.target.dataset.role === "row-seat-dec") {
      if (exists) {
        alert("Strukturändring av befintliga sektioner är begränsad. Skapa en ny sektion för större ändringar.");
        return;
      }
      const draft = getActiveDraft();
      const row = draft?.rows.find(r => r.id === rowId);
      if (row && row.seats.length > 1) {
        row.seats.pop();
        setSectionDirty(true);
        renderSectionDetail();
        renderSectionCards(sectionSearchInput?.value || "");
      }
    }
    if (e.target.dataset.role === "row-seat-set") {
      if (exists) {
        alert("Strukturändring av befintliga sektioner är begränsad. Skapa en ny sektion för större ändringar.");
        return;
      }
      const current = getActiveDraft()?.rows.find(r => r.id === rowId)?.seats.length || 0;
      const input = prompt("Ange antal platser i raden:", String(current));
      if (input !== null) {
        const n = parseInt(input, 10);
        if (Number.isFinite(n) && n > 0) {
          setRowSeatCount(rowId, n);
        }
      }
    }
    if (e.target.dataset.role === "row-new-id") {
      if (exists) {
        alert("Strukturändring av befintliga sektioner är begränsad. Skapa en ny sektion för större ändringar.");
        return;
      }
      const draft = getActiveDraft();
      if (!draft) return;
      const row = draft.rows.find(r => r.id === rowId);
      if (!row) return;
      const rowIdx = draft.rows.findIndex(r => r.id === rowId);
      const newR = newRow(row.name || `Rad ${draft.rows.length + 1}`);
      draft.rows.splice(rowIdx + 1, 0, newR);
      setSectionDirty(true);
      renderSectionDetail();
      renderSectionCards(sectionSearchInput?.value || "");
    }
    if (e.target.dataset.role === "row-remove") {
      if (exists) {
        alert("Du kan inte ta bort rader i befintliga sektioner i denna version.");
        return;
      }
      handleRowRemove(rowId);
    }
    if (e.target.dataset.role === "seat-remove") {
      if (exists) return;
      const seatId = e.target.closest(".seat-chip")?.dataset.seatId;
      if (seatId) handleSeatRemove(rowId, seatId);
    }
  });

  sectionDuplicateBtn?.addEventListener("click", () => {
    const draft = getActiveDraft();
    if (!draft) return;
    const copy = JSON.parse(JSON.stringify(draft));
    copy.sectionId = computeNextSectionId();
    copy.sectionName = `${draft.sectionName || draft.sectionId} (kopia)`;
    sectionDrafts.push(copy);
    activeSectionDraftId = copy.sectionId;
    setSectionDirty(true);
    renderSectionCards(sectionSearchInput?.value || "");
    renderSectionDetail();
  });

  sectionSaveBtn?.addEventListener("click", () => {
    saveActiveSection();
  });


  // --- Init ---

  window.addEventListener("load", () => {
  // Försök återställa en tidigare session (om det finns)
  tryRestoreSessionFromLocalStorage();
});

window.addEventListener("beforeunload", (e) => {
  if (!hasUnsavedChanges) return;

  // Detta magiska returnValue krävs för att vissa browsers ska visa varningen
  e.preventDefault();
  e.returnValue = "";
});


  updateBgOpacityDisplay();
  updateBgScaleDisplay();
  bgEnabledToggle.checked = backgroundState.enabled;
  renderGrayscale = viewGrayToggle?.checked ?? false;
  showHoverInfo = viewHoverToggle?.checked ?? true;
  showSectionNames = viewSectionNamesToggle?.checked ?? false;
  if (viewSeatLabelRow?.checked) seatLabelMode = "row";
  else if (viewSeatLabelSeat?.checked) seatLabelMode = "seat";
  else seatLabelMode = "none";

  setTool("select");
  setSelectionMode("seat");
  updateMoveButtonState();
  updateSaveButton();
  renderCanvas();
  </script>


  </body>
  </html>
