<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="UTF-8" />
  <title>Arena Designer</title>
  <link rel="icon" href="https://tickster.github.io/styleguide/logos/logo_t_circle_blue.png" type="image/png" />
  <style>

    @import url('https://fonts.googleapis.com/css2?family=Ubuntu:ital,wght@0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap');
    @import url('https://fonts.googleapis.com/css2?family=Ubuntu+Mono:ital,wght@0,400;0,700;1,400;1,700&display=swap');

    * { box-sizing: border-box; }

    :root {
      --tick-blue-light: #7cd0ff;
      --tick-blue:       #14a0f4;
      --tick-blue-dark:  #0c6ba5;

      --tick-turq-light: #6ee0db;
      --tick-turq:       #19bab5;
      --tick-turq-dark:  #117c79;

      --tick-yellow-light: #ffe479;
      --tick-yellow:       #e6c229;
      --tick-yellow-dark:  #99811c;

      --tick-grey-light: #dbe0e4;
      --tick-grey:       #849099;
      --tick-grey-dark:  #4f5d68;

      --tick-red-light: #e57c8c;
      --tick-red:       #c12e44;
      --tick-red-dark:  #801f2e;

      --tick-green-light: #5cae8f;
      --tick-green:       #007347;
      --tick-green-dark:  #004d2f;

      --app-bg: #f3f6f9;
      --card-bg: #ffffff;
      --card-border: #dbe0e4;
      --card-shadow: 0 2px 8px rgba(0,0,0,0.04);
      --radius-card: 4px;
      --radius-pill: 4px;
      --transition-fast: 0.15s ease-out;
      --font-main: "Ubuntu", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      --font-mono: "Ubuntu Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace;
    }

    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
    }

    body {
      font-family: var(--font-main);
      background: #415e6e;
      color: var(--tick-grey-dark);
      overflow: hidden;
    }

    /* Layout-root */
    #app {
      display: grid;
      grid-template-columns: 140px 1fr 300px;
      grid-template-rows: 1fr;
      gap: 0.5rem;
      height: 100vh;
      height: 100dvh;
      padding: 0.5rem;
    }

    #app > * {
      min-height: 0;
    }

    /* ---------- Tickster-komponenter ---------- */

    .c-card {
      background: var(--card-bg);
      border-radius: var(--radius-card);
      border: 1px solid var(--card-border);
      box-shadow: var(--card-shadow);
      padding: 0.75rem;
      display: flex;
      flex-direction: column;
      margin-bottom: .5rem;
    }

    .c-card__header {
      margin-bottom: 0.5rem;
    }

    .c-card__title {
      font-size: 0.9rem;
      font-weight: 600;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--tick-grey-dark);
      display: flex;
      align-items: center;
      gap: 0.35rem;
    }

    .c-card__subtitle {
      font-size: 0.8rem;
      color: var(--tick-grey);
      margin-top: 0.1rem;
    }

    .c-toolbar {
      display: flex;
      flex-direction: column;
      gap: 0.4rem;
      margin-bottom: 0.5rem;
    }

    .c-toolbar--horizontal {
      flex-direction: row;
      align-items: center;
    }

    .bg-toggle-group {
      width: 100%;
      gap: 0.4rem;
    }

    .bg-toggle-group .c-button {
      flex: 1 1 0;
      justify-content: center;
    }

    .c-button {
      border-radius: var(--radius-pill);
      border: 1px solid transparent;
      background: #f7f9fc;
      padding: 0.4rem 0.9rem;
      font-size: 0.85rem;
      font-family: "Ubuntu", -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      cursor: pointer;
      color: var(--tick-grey-dark);
      transition: background var(--transition-fast), border-color var(--transition-fast), transform var(--transition-fast), box-shadow var(--transition-fast);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.3rem;
      white-space: nowrap;
    }

    .c-button:hover:not(:disabled) {
      background: #edf5ff;
      transform: translateY(-1px);
      box-shadow: 0 2px 4px rgba(0,0,0,0.07);
    }

    .c-button:disabled {
      opacity: 0.5;
      cursor: default;
      box-shadow: none;
      transform: none;
    }

    .c-button--primary {
      background: var(--tick-blue-dark);
      border-color: var(--tick-blue-dark);
      color: #fff;
    }

    .c-button--primary:hover:not(:disabled) {
      background: var(--tick-blue-dark);
    }

    .c-button--secondary {
      background: var(--tick-turq-light);
      border-color: var(--tick-turq);
      color: var(--tick-turq-dark);
    }

    .c-button--ghost {
      background: var(--tick-grey-light);
      border-color: var(--tick-grey-dark);
      color: var(--tick-grey-dark);
    }

    .c-button--small {
      padding: 0.25rem 0.7rem;
      font-size: 0.78rem;
    }

    .c-button--icon-left::before {
      content: attr(data-icon);
      font-size: 0.9rem;
    }

    .c-select {
      border-radius: var(--radius-pill);
      border: 1px solid #cdd3e0;
      background: #f7f9fc;
      padding: 0.25rem 0.7rem;
      font-size: 0.78rem;
      font-family: "Ubuntu", -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: var(--tick-grey-dark);
      cursor: pointer;
    }

    .c-select--small {
      padding: 0.25rem 0.6rem;
      font-size: 0.75rem;
    }

    .c-button--active {
      box-shadow: 0 0 0 1px rgba(20,160,244,0.6);
      border-color: var(--tick-blue);
      background: rgba(124,208,255,0.15);
      color: var(--tick-blue-dark);
    }

    #newLayoutBtn:not(:disabled),
    #openSectionManagerBtn:not(:disabled),
    #altSectionCreateBtn:not(:disabled) {
      background: #00804f;
      border-color: #00804f;
      color: #fff;
    }

    #newLayoutBtn:hover:not(:disabled),
    #openSectionManagerBtn:hover:not(:disabled),
    #altSectionCreateBtn:hover:not(:disabled) {
      background: #006a41;
      border-color: #006a41;
    }

    #newLayoutBtn:disabled,
    #openSectionManagerBtn:disabled,
    #altSectionCreateBtn:disabled {
      background: #768680;
      border-color: #768680;
      color: #fff;
      opacity: 1;
    }

    #closeLayoutBtn:not(:disabled) {
      background: #ab293d;
      border-color: #ab293d;
      color: #fff;
    }

    #closeLayoutBtn:hover:not(:disabled) {
      background: #8f2435;
      border-color: #8f2435;
    }

    #closeLayoutBtn:disabled {
      background: #947e81;
      border-color: #947e81;
      color: #fff;
      opacity: 1;
    }

    #openFileBtnTop:not(:disabled),
    #saveBtn:not(:disabled),
    #saveAsBtn:not(:disabled),
    #exportBtn:not(:disabled) {
      background: #0a5888;
      border-color: #0a5888;
      color: #fff;
    }

    #openFileBtnTop:hover:not(:disabled),
    #saveBtn:hover:not(:disabled),
    #saveAsBtn:hover:not(:disabled),
    #exportBtn:hover:not(:disabled) {
      background: #084b73;
      border-color: #084b73;
    }

    #openFileBtnTop:disabled,
    #saveBtn:disabled,
    #saveAsBtn:disabled,
    #exportBtn:disabled {
      background: #7b878f;
      border-color: #7b878f;
      color: #fff;
      opacity: 1;
    }

    .c-pill {
      display: inline-flex;
      align-items: center;
      padding: 0.15rem 0.55rem;
      border-radius: var(--radius-pill);
      font-size: 0.75rem;
      background: var(--tick-grey-light);
      color: var(--tick-grey-dark);
      gap: 0.25rem;
    }

    .c-pill__code {
      font-family: var(--font-mono);
      background: #fff;
      padding: 0.05rem 0.4rem;
      border-radius: var(--radius-pill);
      border: 1px solid rgba(0,0,0,0.06);
      font-size: 0.72rem;
    }

    .u-font--small   { font-size: 0.8rem; }
    .u-font--smaller { font-size: 0.75rem; }
    .u-font--mono    { font-family: var(--font-mono); }

    .section-manager {
      width: min(1440px, 98vw);
      height: min(90vh, 960px);
      background: #fff;
      border-radius: 12px;
      box-shadow: 0 20px 50px rgba(0,0,0,0.25);
      border: 1px solid #dbe0e4;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .section-manager__header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.85rem 1rem;
      border-bottom: 1px solid #e5e9ef;
    }

    .section-manager__title {
      font-weight: 700;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      color: #243743;
      font-size: 0.95rem;
    }

    .section-manager__body {
      flex: 1;
      display: grid;
      grid-template-columns: 260px 1fr;
      gap: 0.75rem;
      padding: 0.75rem;
      background: #f7f9fc;
      overflow: auto;
      min-height: 0;
    }

    .section-list {
      background: #fff;
      border: 1px solid #e1e6ef;
      border-radius: 10px;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      box-shadow: 0 4px 16px rgba(0,0,0,0.04);
    }

    .section-list__header {
      padding: 0.7rem 0.75rem;
      border-bottom: 1px solid #e6ebf3;
      display: flex;
      flex-direction: column;
      gap: 0.45rem;
      align-items: stretch;
    }

    .section-list__search {
      flex: 1;
      max-width: 180px;
      padding: 0.4rem 0.55rem;
      border-radius: 8px;
      border: 1px solid #d3dae5;
      font-size: 0.9rem;
    }

    .section-cards {
      flex: 1;
      overflow: auto;
      padding: 0.4rem;
      display: flex;
      flex-direction: column;
      gap: 0.4rem;
      background: #f9fbff;
    }

    .section-card {
      border: 1px solid #e1e6ef;
      border-radius: 10px;
      background: #fff;
      padding: 0.55rem 0.65rem;
      display: flex;
      align-items: center;
      gap: 0.55rem;
      cursor: pointer;
      transition: border-color var(--transition-fast), box-shadow var(--transition-fast), transform var(--transition-fast);
    }

    .section-card:hover {
      border-color: var(--tick-blue);
      box-shadow: 0 2px 6px rgba(0,0,0,0.05);
    }

    .section-card--active {
      border-color: var(--tick-blue);
      box-shadow: 0 0 0 1px rgba(20,160,244,0.4);
      background: #f0f8ff;
    }

    .section-card__color {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      border: 1px solid #cbd4df;
      flex: 0 0 auto;
    }

    .section-card__body {
      display: flex;
      flex-direction: column;
      flex: 1;
      min-width: 0;
      gap: 0.1rem;
    }

    .section-card__header {
      display: flex;
      align-items: center;
      gap: 0.4rem;
    }

    .section-card__name {
      font-weight: 600;
      font-size: 0.9rem;
      color: #243743;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      flex: 1;
    }

    .section-card__rename {
      border: 1px solid #cbd4df;
      background: #f7f9fc;
      color: #243743;
      width: 26px;
      height: 26px;
      border-radius: 6px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 0.85rem;
      cursor: pointer;
      padding: 0;
      flex: 0 0 auto;
    }

    .section-card__rename:hover {
      background: #edf5ff;
      border-color: var(--tick-blue);
    }

    .section-card__meta {
      display: flex;
      gap: 0.5rem;
      font-size: 0.78rem;
      color: #5b6673;
    }

    .section-editor {
      background: #fff;
      border: 1px solid #e1e6ef;
      border-radius: 10px;
      padding: 0.85rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      box-shadow: 0 4px 16px rgba(0,0,0,0.04);
      overflow: auto;
      min-height: 0;
    }

    #altSectionManagerOverlay {
      position: fixed;
      inset: 0;
      background: rgba(12, 28, 48, 0.65);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 30;
      padding: 1rem;
    }

    .section-manager--alt .section-manager__body {
      overflow: hidden;
    }

    .section-editor--alt {
      overflow: hidden;
      gap: 0.6rem;
    }

    .alt-section-toolbar {
      display: flex;
      flex-direction: row;
      gap: 0.8rem;
      flex-wrap: wrap;
      justify-content: flex-start;
      align-items: flex-start;
      width: 100%;
    }

    .alt-section-toolbar__group {
      display: grid;
      grid-template-rows: repeat(2, min-content);
      grid-auto-flow: column;
      grid-auto-columns: max-content;
      column-gap: 0.45rem;
      row-gap: 0.35rem;
      align-items: start;
      flex: 1 1 0;
    }

    .alt-section-toolbar__group--tools {
      flex: 0 0 auto;
    }

    .alt-seat-numbering {
      display: flex;
      flex-direction: column;
      gap: 0.3rem;
      align-items: flex-start;
      grid-row: span 2;
    }

    .alt-seat-numbering__current {
      display: flex;
      align-items: center;
      gap: 0.35rem;
    }

    .alt-seat-numbering__label {
      font-size: 0.72rem;
      color: #5b6673;
    }

    .alt-seat-numbering__input {
      width: 76px;
      padding: 0.2rem 0.45rem;
      border-radius: 6px;
      border: 1px solid #cdd3e0;
      background: #fff;
      font-size: 0.75rem;
      text-align: center;
      color: #1f2b35;
    }

    html[data-theme="dark"] .alt-seat-numbering__label {
      color: #cbd5f5;
    }

    html[data-theme="dark"] .alt-seat-numbering__input {
      background: #0f172a;
      border-color: #2c3a49;
      color: #e2e8f0;
    }

    .alt-section-toolbar__divider {
      width: 1px;
      align-self: stretch;
      background: #d6dee8;
      opacity: 0.8;
    }

    .alt-section-canvas-wrap {
      flex: 1;
      min-height: 320px;
      background: #f8fbff;
      border: 1px solid #d0d9e8;
      border-radius: 10px;
      padding: 0.65rem;
      display: flex;
      align-items: stretch;
      overflow-x: scroll;
      overflow-y: auto;
      position: relative;
    }

    .alt-section-canvas {
      width: 100%;
      height: 100%;
      border-radius: 8px;
      background: linear-gradient(180deg, #ffffff, #f0f5fb);
      border: 1px solid #d8e1ed;
      box-shadow: inset 0 1px 2px rgba(0,0,0,0.04);
    }

    .alt-seat-tooltip {
      position: fixed;
      pointer-events: none;
      background: #0f172a;
      color: #f8fafc;
      font-size: 0.72rem;
      padding: 0.2rem 0.4rem;
      border-radius: 6px;
      box-shadow: 0 6px 12px rgba(0,0,0,0.2);
      opacity: 0;
      transition: opacity 0.08s ease-out;
      z-index: 45;
    }

    .section-editor__actions-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    .section-editor__actions-right {
      display: flex;
      gap: 0.35rem;
      margin-left: auto;
    }


    /* Ny layout-modal */
    #newLayoutOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.35);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }
    #newLayoutModal {
      background: #fff;
      border-radius: 12px;
      padding: 1rem;
      width: min(520px, 92vw);
      box-shadow: 0 10px 30px rgba(0,0,0,0.12);
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    #priceRegionOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.35);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }

    #priceRegionModal {
      background: #fff;
      border-radius: 12px;
      padding: 1rem;
      width: min(420px, 92vw);
      box-shadow: 0 10px 30px rgba(0,0,0,0.12);
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }
    #entryPointOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.35);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }

    #entryPointModal {
      background: #fff;
      border-radius: 12px;
      padding: 1rem;
      width: min(420px, 92vw);
      box-shadow: 0 10px 30px rgba(0,0,0,0.12);
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }
    #goodnessOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.35);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }

    #goodnessModal {
      background: #fff;
      border-radius: 12px;
      padding: 1rem;
      width: min(420px, 92vw);
      box-shadow: 0 10px 30px rgba(0,0,0,0.12);
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }
    #exportOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.35);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }
    #exportModal {
      background: #fff;
      border-radius: 12px;
      padding: 1rem;
      width: min(520px, 92vw);
      box-shadow: 0 10px 30px rgba(0,0,0,0.12);
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }
    #helpOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.35);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }
    #helpModal {
      background: #fff;
      border-radius: 12px;
      padding: 1rem;
      width: min(900px, 94vw);
      height: min(80vh, 720px);
      box-shadow: 0 10px 30px rgba(0,0,0,0.12);
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }
    .help-modal__content {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      overflow-y: auto;
      flex: 1 1 auto;
      min-height: 0;
      padding-right: 0.2rem;
    }
    .help-modal__section {
      display: flex;
      flex-direction: column;
      gap: 0.4rem;
    }
    .help-modal__grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 0.75rem;
    }
    .help-panel__title {
      font-size: 0.82rem;
      font-weight: 600;
      margin-bottom: 0.25rem;
    }
    .help-placeholder {
      color: var(--tick-grey);
      font-style: italic;
    }
    .help-tool-list {
      display: grid;
      gap: 0.5rem;
    }
    .help-tool-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 0.75rem;
    }
    .help-tool {
      display: grid;
      gap: 0.1rem;
    }
    .help-tool__title {
      font-weight: 600;
      font-size: 0.8rem;
    }
    .help-tool__desc {
      font-size: 0.78rem;
      opacity: 0.9;
    }
    .export-options {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 0.5rem;
      padding: 0.4rem 0;
    }
    .export-option {
      display: flex;
      align-items: center;
      gap: 0.35rem;
      font-size: 0.9rem;
    }

    .export-option--disabled {
      opacity: 0.55;
      cursor: help;
    }

    .export-option--disabled input {
      cursor: not-allowed;
    }
    #newLayoutModal h3,
    #priceRegionModal h3,
    #entryPointModal h3,
    #goodnessModal h3,
    #exportModal h3 {
      margin: 0;
      font-size: 1.1rem;
      color: #1f2b35;
    }
    .new-layout-field {
      display: flex;
      flex-direction: column;
      gap: 0.2rem;
      font-size: 0.9rem;
    }
    .new-layout-field input {
      padding: 0.55rem 0.65rem;
      border-radius: 8px;
      border: 1px solid #cdd3e0;
      font-size: 0.95rem;
    }
    .new-layout-field textarea {
      padding: 0.55rem 0.65rem;
      border-radius: 8px;
      border: 1px solid #cdd3e0;
      font-size: 0.95rem;
      min-height: 4.5rem;
      resize: vertical;
    }
    .new-layout-actions {
      display: flex;
      justify-content: flex-end;
      gap: 0.5rem;
    }

    .section-hint {
      font-size: 0.8rem;
      color: #5b6673;
    }

    /* ---------- Vänster verktygspalett ---------- */

    #left-toolbar {
      border: none;
      background: transparent;
      padding: 0;
      display: flex;
      flex-direction: column;
      overflow: auto;
      height: 100%;
    }

    #left-toolbar .c-card {
      flex: 1 1 auto;
      gap: 0.75rem;
      margin-bottom: 0;
      min-height: 0;
    }

    #toolButtons {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
    }

    .tool-button {
      width: 100%;
      text-align: left;
    }

    .tool-button.active {
      /* kopplad till JS .active-klassen */
      background: rgba(124,208,255,0.20);
      border-color: var(--tick-blue);
      color: var(--tick-blue-dark);
      box-shadow: 0 0 0 1px rgba(20,160,244,0.5);
    }

    #selectionModeGroup {
      margin-top: 0.25rem;
    }

    .help-text {
      font-size: 0.78rem;
      color: var(--tick-grey-dark);
      line-height: 1.5;
      padding: 0.6rem 0.7rem;
      border-radius: 8px;
      background: rgba(219,224,228,0.4);
    }

    .help-text strong {
      font-family: var(--font-mono);
      font-size: 0.76rem;
      background: rgba(255,255,255,0.6);
      padding: 0 0.25rem;
      border-radius: 4px;
    }

    /* ---------- Höger panel ---------- */

    #right-panels {
      padding: 0;
      border: none;
      overflow: auto;
    }

    #right-panels .c-card {
      gap: 0.5rem;
    }

    #right-panels .c-card__header {
      display: flex;
      align-items: center;
      gap: 0.4rem;
      margin-bottom: 0;
    }

    #right-panels .c-card__body {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .c-card__toggle {
      margin-left: auto;
      width: 22px;
      height: 22px;
      border-radius: 6px;
      border: 1px solid var(--card-border);
      background: #f7f9fc;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: background var(--transition-fast), border-color var(--transition-fast), transform var(--transition-fast);
    }

    .c-card__toggle:hover {
      background: #edf5ff;
      border-color: var(--tick-blue);
    }

    .c-card__toggle::before {
      content: "";
      width: 6px;
      height: 6px;
      border-right: 2px solid var(--tick-grey-dark);
      border-bottom: 2px solid var(--tick-grey-dark);
      transform: rotate(45deg);
      transition: transform var(--transition-fast);
    }

    .c-card--collapsed .c-card__toggle::before {
      transform: rotate(-45deg);
    }

    .c-card--collapsed .c-card__body {
      display: none;
    }

    #right-panels .c-card--collapsed .c-card__body {
      display: none !important;
    }

    #right-panels .c-card__body[hidden] {
      display: none !important;
    }

    .price-region-list {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      max-height: 42vh;
      overflow: auto;
      padding-right: 0.2rem;
    }

    .price-region-item {
      border: 1px solid #e1e6ef;
      border-radius: 8px;
      padding: 0.5rem 1.8rem 0.5rem 0.6rem;
      background: #f9fbff;
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
      position: relative;
    }

    .price-region-item__header {
      display: flex;
      align-items: center;
      justify-content: flex-start;
      gap: 0.5rem;
      font-size: 0.85rem;
      font-weight: 600;
      color: #243743;
      min-width: 0;
    }

    .price-region-item__header-left {
      display: inline-flex;
      align-items: center;
      gap: 0.45rem;
      min-width: 0;
    }

    .price-region-item__name {
      flex: 1;
      min-width: 0;
      border: 1px solid transparent;
      background: transparent;
      font-size: 0.85rem;
      font-weight: 600;
      color: #243743;
      padding: 0.1rem 0.3rem;
      border-radius: 6px;
    }

    .price-region-item__name:focus {
      outline: none;
      border-color: var(--tick-blue);
      background: #fff;
    }

    .price-region-item__count {
      font-size: 0.75rem;
      color: #5b6673;
      background: #eef2f7;
      border-radius: 999px;
      padding: 0.1rem 0.4rem;
      white-space: nowrap;
    }

    .price-region-item__delete {
      position: absolute;
      top: 6px;
      right: 6px;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      border: none;
      background: var(--tick-red);
      color: #fff;
      font-weight: 700;
      font-size: 0.75rem;
      line-height: 1;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }

    .price-region-item__delete:hover {
      background: var(--tick-red-dark);
    }

    .price-region-item__add--active {
      background: var(--tick-green);
      border-color: var(--tick-green-dark);
      color: #fff;
    }

    .price-region-item__add--active:hover:not(:disabled) {
      background: var(--tick-green-dark);
    }

    .price-region-item__meta {
      font-size: 0.78rem;
      color: var(--tick-grey);
    }

    .price-region-status {
      font-size: 0.95em;
      margin-left: 0.35rem;
    }

    .price-region-item__color {
      width: 34px;
      height: 20px;
      padding: 0;
      border: none;
      background: transparent;
      cursor: pointer;
    }

    .price-region-item__actions {
      display: flex;
      gap: 0.4rem;
      justify-content: flex-end;
      flex-wrap: wrap;
      min-width: 0;
    }

    .price-region-item__actions .c-button {
      max-width: 100%;
      white-space: nowrap;
    }

    #info-panel {
      font-size: 0.85rem;
      line-height: 1.4;
      color: var(--tick-grey-dark);
    }

    #info-panel div {
      margin-bottom: 0.25rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    #info-panel strong {
      font-weight: 500;
    }

    #info-panel span {
      font-family: var(--font-mono);
      font-size: 0.8rem;
      background: rgba(219,224,228,0.6);
      padding: 0.1rem 0.35rem;
      border-radius: 999px;
    }

    /* Bakgrundsreglage */
    .bg-control {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    .bg-control input[type="range"] {
      flex: 1 1 100%;
      min-width: 0;
      width: 100%;
    }

    .bg-control .u-font--mono {
      margin-left: auto;
    }

    /* Kod-modal */
    #codeModalOverlay {
      position: fixed;
      inset: 0;
      background: rgba(18, 32, 53, 0.65);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 20;
    }

    #codeModal {
      background: #fff;
      border-radius: 12px;
      width: min(1080px, 95vw);
      max-height: 85vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      box-shadow: 0 20px 50px rgba(0,0,0,0.25);
      border: 1px solid #dbe0e4;
    }

    #codeModal header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.9rem 1rem;
      border-bottom: 1px solid #e5e9ef;
    }

    #codeModal main {
      padding: 1rem;
      flex: 1;
      background: #f8f9fb;
      display: flex;
    }

    #codeModal textarea {
      width: 100%;
      height: 60vh;
      border-radius: 8px;
      border: 1px solid #cdd3e0;
      font-family: var(--font-mono);
      font-size: 11px;
      padding: 0.45rem;
      background: #fff;
      resize: vertical;
      white-space: pre;
      color: #27313b;
    }

    #codeModal footer {
      padding: 0.8rem 1rem;
      border-top: 1px solid #e5e9ef;
      background: #f7f9fc;
      display: flex;
      justify-content: flex-end;
      gap: 0.5rem;
    }

    /* Attribute-modal */
    #attributeModalOverlay {
      position: fixed;
      inset: 0;
      background: rgba(18, 32, 53, 0.65);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 25;
      padding: 1rem;
    }

    #attributeModal {
      background: #fff;
      border-radius: 12px;
      width: min(520px, 92vw);
      max-height: 80vh;
      display: flex;
      flex-direction: column;
      border: 1px solid #dbe0e4;
      box-shadow: 0 20px 50px rgba(0,0,0,0.25);
      overflow: hidden;
    }

    #attributeModal header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.85rem 1rem;
      border-bottom: 1px solid #e5e9ef;
    }

    #attributeModal main {
      padding: 0.75rem 1rem;
      overflow: auto;
      background: #f8f9fb;
    }

    .attribute-modal__list {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
    }

    .attribute-option {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      justify-content: space-between;
      flex-wrap: wrap;
      padding: 0.45rem 0.5rem;
      border-radius: 8px;
      background: #fff;
      border: 1px solid #e1e6ef;
      font-size: 0.88rem;
    }

    .attribute-option__main {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      flex: 1 1 auto;
      min-width: 180px;
    }

    .attribute-option__internal {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      font-size: 0.8rem;
      color: #5b6772;
    }

    .attribute-option input {
      margin: 0;
    }

    #attributeModal footer {
      padding: 0.75rem 1rem;
      border-top: 1px solid #e5e9ef;
      background: #f7f9fc;
      display: flex;
      justify-content: flex-end;
      gap: 0.5rem;
    }

    #seatEditOverlay,
    #rowEditOverlay,
    #sectionEditOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.35);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }

    #seatEditModal,
    #rowEditModal,
    #sectionEditModal {
      background: #fff;
      border-radius: 12px;
      width: min(860px, 95vw);
      max-height: 80vh;
      display: flex;
      flex-direction: column;
      border: 1px solid #dbe0e4;
      box-shadow: 0 20px 50px rgba(0,0,0,0.25);
      overflow: hidden;
    }

    #seatEditModal header,
    #rowEditModal header,
    #sectionEditModal header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.85rem 1rem;
      border-bottom: 1px solid #e5e9ef;
    }

    #seatEditModal main,
    #rowEditModal main,
    #sectionEditModal main {
      padding: 0.75rem 1rem;
      overflow: auto;
      background: #f8f9fb;
    }

    #seatEditModal footer,
    #rowEditModal footer,
    #sectionEditModal footer {
      padding: 0.75rem 1rem;
      border-top: 1px solid #e5e9ef;
      background: #f7f9fc;
      display: flex;
      justify-content: flex-end;
      gap: 0.5rem;
    }

    .edit-list {
      display: flex;
      flex-direction: column;
      gap: 0.6rem;
    }

    .edit-item {
      background: #fff;
      border: 1px solid #e1e6ef;
      border-radius: 10px;
      padding: 0.6rem 0.7rem;
      display: flex;
      flex-direction: column;
      gap: 0.55rem;
      font-size: 0.85rem;
    }

    .edit-item__title {
      font-weight: 600;
      color: #243743;
    }

    .edit-item__grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(170px, 1fr));
      gap: 0.5rem;
    }

    .edit-field {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
      font-size: 0.8rem;
      color: #5b6772;
    }

    .edit-field input,
    .edit-field select {
      padding: 0.45rem 0.55rem;
      border-radius: 8px;
      border: 1px solid #cdd3e0;
      font-size: 0.9rem;
    }

    .edit-item__actions {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    .edit-item__meta {
      font-size: 0.8rem;
      color: #6b7280;
    }

    /* ---------- Mitten: canvas + topp-bar + kod ---------- */

    #center-area {
      display: flex;
      flex-direction: column;
      min-width: 0;
      min-height: 0;
      gap: 0.5rem;
    }

    #top-bar {
      padding: 0.45rem 0.75rem;
      border-radius: var(--radius-card);
      border: 1px solid var(--card-border);
      background: var(--card-bg);
      box-shadow: var(--card-shadow);
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      flex: 0 0 auto;
    }

    .top-bar__row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.75rem;
      flex-wrap: wrap;
    }

    #top-bar-left {
      display: flex;
      flex-wrap: wrap;
      gap: 0.45rem;
      row-gap: 0.45rem;
      align-items: center;
      min-width: 0;
    }

    #top-bar .file-info {
      font-size: 0.8rem;
      color: var(--tick-grey-dark);
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
    }

    #top-bar .file-info::before {
      content: "●";
      font-size: 0.6rem;
      color: var(--tick-green);
    }

    #top-bar button {
      /* overrida gamla knappar – nu Tickster-knappar */
      border: none;
    }

    #openFileBtnTop {
      /* primär handling */
      color: #fff;
    }

    #saveBtn {
      /* sekundär visuell – men fortfarande .c-button--primary i HTML om du vill */
      color: #fff;
    }

    #saveAsBtn {
      color: #fff;
    }

    #top-bar input[type="file"] {
      display: none;
    }

    #top-bar-right {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    html[data-theme="dark"] body {
      background: #0f141a;
      color: #e5e7eb;
    }

    html[data-theme="dark"] .c-card,
    html[data-theme="dark"] #top-bar,
    html[data-theme="dark"] #codeModal,
    html[data-theme="dark"] #newLayoutModal,
    html[data-theme="dark"] #exportModal,
    html[data-theme="dark"] #helpModal,
    html[data-theme="dark"] #goodnessModal,
    html[data-theme="dark"] #seatEditModal,
    html[data-theme="dark"] #rowEditModal,
    html[data-theme="dark"] #sectionEditModal,
    html[data-theme="dark"] .section-manager,
    html[data-theme="dark"] .section-list,
    html[data-theme="dark"] .section-editor {
      background: #151b23;
      border-color: #2b3442;
      box-shadow: 0 8px 20px rgba(0,0,0,0.45);
    }

    html[data-theme="dark"] .section-manager__body,
    html[data-theme="dark"] #codeModal main,
    html[data-theme="dark"] #codeModal footer,
    html[data-theme="dark"] .section-cards {
      background: #0f141a;
      border-color: #2b3442;
    }

    html[data-theme="dark"] #canvas-container {
      background: #0b1117;
      border-color: #2b3442;
      box-shadow: 0 10px 24px rgba(0,0,0,0.5);
    }

    html[data-theme="dark"] #layoutCanvas {
      background: #111827;
      border-color: #2b3442;
      box-shadow: 0 0 0 1px rgba(255,255,255,0.04), 0 10px 24px rgba(0,0,0,0.6);
    }

    html[data-theme="dark"] .section-card {
      background: #111827;
      border-color: #2b3442;
      box-shadow: 0 4px 14px rgba(0,0,0,0.35);
    }

    html[data-theme="dark"] .section-card--active {
      background: rgba(59,130,246,0.15);
      border-color: #3b82f6;
      box-shadow: 0 0 0 1px rgba(59,130,246,0.35);
    }


    html[data-theme="dark"] .c-button {
      background: #1f2937;
      border-color: #2b3442;
      color: #e5e7eb;
    }

    html[data-theme="dark"] .c-button:hover:not(:disabled) {
      background: #273244;
      box-shadow: 0 3px 8px rgba(0,0,0,0.45);
    }

    html[data-theme="dark"] .c-button--ghost {
      background: transparent;
      border-color: #334155;
      color: #e5e7eb;
    }

    html[data-theme="dark"] .c-button--active {
      background: rgba(59,130,246,0.18);
      border-color: #3b82f6;
      color: #e5e7eb;
      box-shadow: 0 0 0 1px rgba(59,130,246,0.35);
    }

    html[data-theme="dark"] input,
    html[data-theme="dark"] select,
    html[data-theme="dark"] textarea,
    html[data-theme="dark"] .section-list__search {
      background: #0f141a;
      border-color: #2b3442;
      color: #e5e7eb;
    }

    html[data-theme="dark"] .help-text {
      background: rgba(31,41,55,0.65);
      color: #cbd5f5;
    }

    html[data-theme="dark"] .help-text strong {
      background: rgba(15,23,42,0.7);
      color: #e5e7eb;
    }


    html[data-theme="dark"] #info-panel span,
    html[data-theme="dark"] .c-pill,
    html[data-theme="dark"] .c-pill__code {
      background: rgba(31,41,55,0.7);
      border-color: #2b3442;
      color: #e5e7eb;
    }

    html[data-theme="dark"] #codeModalOverlay,
    html[data-theme="dark"] #altSectionManagerOverlay,
    html[data-theme="dark"] #exportOverlay,
    html[data-theme="dark"] #helpOverlay,
    html[data-theme="dark"] #goodnessOverlay,
    html[data-theme="dark"] #seatEditOverlay,
    html[data-theme="dark"] #rowEditOverlay,
    html[data-theme="dark"] #sectionEditOverlay {
      background: rgba(6, 10, 18, 0.7);
    }

    html[data-theme="dark"] #attributeModalOverlay {
      background: rgba(6, 10, 18, 0.7);
    }

    html[data-theme="dark"] #exportModal h3,
    html[data-theme="dark"] #helpModal h3,
    html[data-theme="dark"] #goodnessModal h3,
    html[data-theme="dark"] #seatEditModal h3,
    html[data-theme="dark"] #rowEditModal h3,
    html[data-theme="dark"] #sectionEditModal h3 {
      color: #e5e7eb;
    }

    html[data-theme="dark"] #attributeModal {
      background: #151b23;
      border-color: #2b3442;
      box-shadow: 0 20px 50px rgba(0,0,0,0.45);
    }

    html[data-theme="dark"] #attributeModal main,
    html[data-theme="dark"] #attributeModal footer {
      background: #0f141a;
      border-color: #2b3442;
    }

    html[data-theme="dark"] .goodness-hint {
      color: #9aa5b1;
    }

    html[data-theme="dark"] .attribute-option {
      background: #111827;
      border-color: #2b3442;
      color: #e5e7eb;
    }

    html[data-theme="dark"] .attribute-option__internal {
      color: #9aa5b1;
    }

    html[data-theme="dark"] #seatEditModal header,
    html[data-theme="dark"] #rowEditModal header,
    html[data-theme="dark"] #sectionEditModal header {
      border-color: #2b3442;
    }

    html[data-theme="dark"] #seatEditModal main,
    html[data-theme="dark"] #rowEditModal main,
    html[data-theme="dark"] #sectionEditModal main {
      background: #0f141a;
      border-color: #2b3442;
    }

    html[data-theme="dark"] #seatEditModal footer,
    html[data-theme="dark"] #rowEditModal footer,
    html[data-theme="dark"] #sectionEditModal footer {
      background: #111827;
      border-color: #2b3442;
    }

    html[data-theme="dark"] .edit-item {
      background: #111827;
      border-color: #2b3442;
    }

    html[data-theme="dark"] .edit-item__title {
      color: #e5e7eb;
    }

    html[data-theme="dark"] .edit-field {
      color: #9aa5b1;
    }

    html[data-theme="dark"] .edit-field input,
    html[data-theme="dark"] .edit-field select {
      background: #0f141a;
      border-color: #2b3442;
      color: #e5e7eb;
    }

    html[data-theme="dark"] .edit-item__meta {
      color: #9aa5b1;
    }

    html[data-theme="dark"] .price-region-item {
      background: #111827;
      border-color: #2b3442;
      box-shadow: 0 4px 14px rgba(0,0,0,0.35);
    }

    html[data-theme="dark"] .price-region-item__header {
      color: #e5e7eb;
    }

    html[data-theme="dark"] .price-region-item__meta {
      color: #9aa5b1;
    }

    html[data-theme="dark"] .price-region-item__color {
      background: transparent;
    }

    html[data-theme="dark"] .align-grouping label {
      color: #cbd5f5;
    }
    html[data-theme="dark"] .align-divider {
      background: #3a4653;
      opacity: 0.8;
    }

    #alignBar {
      width: 100%;
      flex-wrap: wrap;
      gap: 0.35rem;
    }

    .align-grouping {
      display: flex;
      align-items: center;
      gap: 0.35rem;
    }

    .align-grouping label {
      font-size: 0.78rem;
      color: var(--tick-grey-dark);
    }

    .align-grouping select {
      padding: 0.25rem 0.55rem;
      border-radius: 8px;
      border: 1px solid var(--card-border);
      background: #fff;
      font-size: 0.78rem;
    }

    .align-divider {
      width: 2px;
      align-self: stretch;
      background: #d6dee8;
      opacity: 0.9;
      margin: 0 0.35rem;
    }

    .align-rotate {
      display: flex;
      align-items: center;
      gap: 0.35rem;
    }

    .align-rotate input {
      width: 64px;
      padding: 0.25rem 0.5rem;
      border-radius: 8px;
      border: 1px solid var(--card-border);
      font-size: 0.78rem;
      text-align: center;
    }

    .goodness-settings {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
    }

    .goodness-settings input {
      width: 120px;
      max-width: 100%;
    }

    .goodness-hint {
      color: #6b7280;
    }

    #canvas-container {
      flex: 1 1 auto;
      min-height: 0;
      background: #fff;
      border-radius: var(--radius-card);
      border: 1px solid var(--card-border);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0.75rem;
      cursor: default;
      overflow: hidden;
      box-shadow: var(--card-shadow);
    }

    #canvas-container.panning {
      cursor: grabbing;
    }

    #layoutCanvas {
      background: #f8f9fb;
      border-radius: 8px;
      border: 1px solid #f1f1f1;
      display: block;
    }

    /* Kodruta nedtill */


    /* Tooltip */

    #tooltip {
      position: fixed;
      pointer-events: none;
      background: rgba(12, 28, 48, 0.96);
      color: #fff;
      padding: 6px 8px;
      border-radius: 6px;
      font-size: 11px;
      line-height: 1.4;
      box-shadow: 0 4px 10px rgba(0,0,0,0.35);
      display: none;
      z-index: 10;
      max-width: 260px;
      border: 1px solid rgba(124,208,255,0.4);
    }

    #tooltip strong {
      font-weight: 600;
      color: var(--tick-yellow-light);
    }

    .context-menu {
      position: fixed;
      z-index: 60;
      background: #ffffff;
      border: 1px solid #dbe0e4;
      border-radius: 10px;
      box-shadow: 0 12px 30px rgba(0,0,0,0.18);
      padding: 0.35rem;
      min-width: 220px;
      display: none;
      color: #243743;
      font-size: 0.85rem;
    }

    .context-menu.open {
      display: block;
    }

    .context-menu__list {
      display: flex;
      flex-direction: column;
      gap: 0.15rem;
      padding: 0.15rem;
      max-height: 70vh;
      overflow: auto;
    }

    .context-menu__item {
      width: 100%;
      border: none;
      background: transparent;
      text-align: left;
      padding: 0.45rem 0.6rem;
      border-radius: 8px;
      font-size: 0.85rem;
      cursor: pointer;
      color: inherit;
      user-select: none;
      white-space: nowrap;
      position: relative;
      display: flex;
      align-items: center;
    }

    .context-menu__item:hover {
      background: #f1f5fb;
    }

    .context-menu__item:disabled {
      color: #9aa4b2;
      cursor: not-allowed;
      opacity: 0.6;
    }

    .context-menu__item:disabled:hover {
      background: transparent;
    }

    html[data-theme="dark"] .context-menu {
      background: #111827;
      border-color: #2b3442;
      color: #e5e7eb;
      box-shadow: 0 12px 30px rgba(0,0,0,0.45);
    }

    html[data-theme="dark"] .context-menu__item:hover {
      background: #1f2937;
    }

    html[data-theme="dark"] .context-menu__item:disabled {
      color: #6b7280;
      opacity: 0.65;
    }
  </style>
</head>
<body>
  <div id="app">
    <!-- Vänster: verktyg -->
    <aside id="left-toolbar">
      <div class="c-card">
        <div class="c-card__header">
          <div class="c-card__title">Tools</div>
        </div>

        <div id="toolButtons" class="c-toolbar">
          <button id="selectToolBtn" class="tool-button c-button c-button--ghost c-button--small c-button--active" title="Select (C)">
            Select
          </button>
          <button id="panToolBtn" class="tool-button c-button c-button--ghost c-button--small" title="Pan">
            Pan
          </button>
          <button id="moveToolBtn" class="tool-button c-button c-button--ghost c-button--small" disabled title="Move (V)">
            Move
          </button>
          <button id="rotateToolBtn" class="tool-button c-button c-button--ghost c-button--small" disabled title="Rotate (R)">
            Rotate
          </button>
          <button id="resizeToolBtn" class="tool-button c-button c-button--ghost c-button--small" disabled title="Resize (Z)">
            Resize
          </button>
          <button id="bendToolBtn" class="tool-button c-button c-button--ghost c-button--small" disabled title="Bend (B)">
            Bend
          </button>
          <button id="reshapeRowBtn" class="tool-button c-button c-button--ghost c-button--small" disabled title="Reshape row (E)">
            Reshape row
          </button>
          <button id="resetRowBtn" class="tool-button c-button c-button--ghost c-button--small" disabled title="Reset row (Q)">
            Reset row
          </button>
          <button id="makeTableBtn" class="tool-button c-button c-button--ghost c-button--small" disabled title="Make table (T)">
            Make table
          </button>
          <button id="deselectToolBtn" class="tool-button c-button c-button--ghost c-button--small" title="Deselect (CTRL+D)">
            Deselect
          </button>
          <button id="updateOutlinesBtn" class="tool-button c-button c-button--ghost c-button--small" title="Update outlines">
            Update outlines
          </button>
          <button id="updateRowIdsBtn" class="tool-button c-button c-button--ghost c-button--small" title="Update RowIds">
            Update RowIds
          </button>
        </div>

        <div id="selectionModeGroup">
          <div class="c-card__header" style="margin-top:0.5rem;">
            <div class="c-card__title">Selection</div>
          </div>
          <div class="c-toolbar">
            <button id="modeSectionBtn" class="tool-button c-button c-button--ghost c-button--small c-button--active" title="Section (S)">
              Section
            </button>
            <button id="modeRowBtn" class="tool-button c-button c-button--ghost c-button--small" title="Row (D)">
              Row
            </button>
            <button id="modeSeatBtn" class="tool-button c-button c-button--ghost c-button--small" title="Seat (F)">
              Seat
            </button>
          </div>
        </div>

        <div class="c-card__header" style="margin-top:0.5rem;">
          <div class="c-card__title">Background</div>
        </div>
        <div class="c-toolbar">
          <div class="c-toolbar c-toolbar--horizontal bg-toggle-group">
            <button id="bgLoadBtn" class="c-button c-button--ghost c-button--small">Add</button>
            <button id="bgToggleBtn" class="c-button c-button--ghost c-button--small" disabled>Show</button>
          </div>
          <div class="c-toolbar c-toolbar--horizontal bg-toggle-group">
            <button id="bgMoveBtn" class="c-button c-button--ghost c-button--small" disabled>Move</button>
            <button id="bgDeleteBtn" class="c-button c-button--ghost c-button--small" style="max-width: 50px" disabled>Delete</button>
          </div>
          <label class="bg-control u-font--small">
            Opacity
            <input type="range" id="bgOpacityRange" min="0" max="1" step="0.05" value="0.4" disabled />
          </label>
          <label class="bg-control u-font--small">
            Scale
            <input type="range" id="bgScaleRange" min="0.1" max="20" step="0.1" value="1" disabled />
          </label>
        </div>

      </div>
    </aside>

    <!-- Mitten: canvas + kod -->
    <section id="center-area">
      <div id="top-bar">

        <div class="top-bar__row">
          <div id="top-bar-left" class="c-toolbar c-toolbar--horizontal">

            <button id="newLayoutBtn" class="c-button c-button--primary c-button--icon-left" data-icon="">

              Create new

            </button>

            <button id="openFileBtnTop" class="c-button c-button--primary c-button--icon-left" data-icon="">

              Open layout

            </button>

            <button id="saveBtn" class="c-button c-button--primary c-button--icon-left" data-icon="" disabled>

              Save layout

            </button>

            <button id="saveAsBtn" class="c-button c-button--primary c-button--icon-left" data-icon="" disabled>

              Save layout as

            </button>

            <button id="closeLayoutBtn" class="c-button c-button--ghost c-button--icon-left" data-icon="" disabled>
              Close
            </button>

            <button id="openSectionManagerBtn" class="c-button c-button--primary c-button--icon-left" data-icon="">

              Manage sections

            </button>
            <button id="exportBtn" class="c-button c-button--primary">Export</button>
            <input type="file" id="fileInput" accept=".tlt" />

          </div>

          <div id="top-bar-right" class="c-toolbar c-toolbar--horizontal">
            <button id="helpBtn" class="c-button c-button--ghost" title="Help">
              HELP
            </button>
            <button id="themeToggleBtn" class="c-button c-button--ghost" title="Toggle dark mode">
              Dark mode
            </button>
          </div>
        </div>

        <div id="alignBar" class="c-toolbar c-toolbar--horizontal">
          <button id="alignTopBtn" class="c-button c-button--ghost c-button--small" title="Align top">Align Up</button>
          <button id="alignBottomBtn" class="c-button c-button--ghost c-button--small" title="Align bottom">Align Down</button>
          <button id="alignLeftBtn" class="c-button c-button--ghost c-button--small" title="Align left">Align Left</button>
          <button id="alignRightBtn" class="c-button c-button--ghost c-button--small" title="Align right">Align Right</button>
          <button id="alignCenterHBtn" class="c-button c-button--ghost c-button--small" title="Center horizontally">Center H</button>
          <button id="alignCenterVBtn" class="c-button c-button--ghost c-button--small" title="Center vertically">Center V</button>
          <div class="align-grouping">
            <label for="alignGroupingSelect" class="u-font--small">Align as</label>
            <select id="alignGroupingSelect">
              <option value="group">Group</option>
              <option value="individual">Individual</option>
            </select>
          </div>
          <div class="align-divider" aria-hidden="true"></div>
          <div class="align-rotate">
            <button id="rotateCcwBtn" class="c-button c-button--ghost c-button--small" title="Rotate counter-clockwise">Rotate CCW</button>
            <input id="rotateDegreesInput" type="number" inputmode="decimal" step="1" placeholder="deg" />
            <button id="rotateCwBtn" class="c-button c-button--ghost c-button--small" title="Rotate clockwise">Rotate CW</button>
          </div>
          <div class="align-divider" aria-hidden="true"></div>
          <button id="flipHBtn" class="c-button c-button--ghost c-button--small" title="Flip horizontally">Flip H</button>
          <button id="flipVBtn" class="c-button c-button--ghost c-button--small" title="Flip vertically">Flip V</button>
        </div>

      </div>


      <div id="canvas-container">
        <canvas id="layoutCanvas"></canvas>
      </div>
    </section>

    <!-- Höger: paneler -->
    <aside id="right-panels">
      <div class="c-card" data-collapsible="true" data-collapsed="true">
        <div class="c-card__header">
          <div class="c-card__title">Layout Information</div>
          <button class="c-card__toggle" type="button" aria-expanded="true" aria-label="Toggle panel" onclick="toggleRightPanel(this)"></button>
        </div>
        <div class="c-card__body" id="info-panel">
                    <div>
            <strong>Sections:</strong>
            <span id="sectionCount">0</span>
          </div>
          <div>
            <strong>Seats:</strong>
            <span id="seatCount">0</span>
          </div>
          <div id="fileInfo" class="file-info u-font--small">No file opened or saved.</div>

        </div>
      </div>

      <div class="c-card" data-collapsible="true" data-collapsed="true">
        <div class="c-card__header">
          <div class="c-card__title">Display</div>
          <button class="c-card__toggle" type="button" aria-expanded="true" aria-label="Toggle panel" onclick="toggleRightPanel(this)"></button>
        </div>
        <div class="c-card__body c-toolbar">
          <label class="bg-control u-font--small">
            <input type="checkbox" id="viewHoverToggle" checked />
            Hover info for seats
          </label>
          <label class="bg-control u-font--small">
            <input type="checkbox" id="viewSectionNamesToggle" />
            Display section name
          </label>
          <div class="u-font--small" style="display:flex; flex-direction:column; gap:0.35rem;">
            <div>Overlay (O)</div>
            <label class="bg-control">
              <input type="radio" name="overlayMode" id="viewOverlayNone" value="none" checked />
              No overlay
            </label>
            <label class="bg-control">
              <input type="radio" name="overlayMode" id="viewOverlayPrice" value="price" />
              Show price regions
            </label>
            <label class="bg-control">
              <input type="radio" name="overlayMode" id="viewOverlayGoodness" value="goodness" />
              Show goodness heatmap
            </label>
          </div>
          <div class="u-font--small" style="display:flex; flex-direction:column; gap:0.35rem;">
            <div>Seat Information (I)</div>
            <label class="bg-control">
              <input type="radio" name="seatLabelMode" id="viewSeatLabelNone" value="none" checked />
              No information (standard)
            </label>
            <label class="bg-control">
              <input type="radio" name="seatLabelMode" id="viewSeatLabelRow" value="row" />
              Display row number
            </label>
            <label class="bg-control">
              <input type="radio" name="seatLabelMode" id="viewSeatLabelSeat" value="seat" />
              Display seat number
            </label>
            <label class="bg-control">
              <input type="radio" name="seatLabelMode" id="viewSeatLabelSeatId" value="seatId" />
              Display seat ID
            </label>
          </div>
          <button id="openCodeModalBtn" class="c-button c-button--ghost c-button--small">Show source code</button>
        </div>
      </div>

      <div class="c-card" data-collapsible="true" data-collapsed="true">
        <div class="c-card__header">
          <div class="c-card__title">Price Regions <span id="priceRegionStatus" class="price-region-status">❌</span></div>
          <button class="c-card__toggle" type="button" aria-expanded="true" aria-label="Toggle panel" onclick="toggleRightPanel(this)"></button>
        </div>
        <div class="c-card__body c-toolbar">
          <button id="createPriceRegionBtn" class="c-button c-button--ghost c-button--small">Add price region</button>
          <button id="loadPriceRegionBtn" class="c-button c-button--ghost c-button--small">Load price regions from file</button>
          <button id="selectSeatsNoPriceRegionBtn" class="c-button c-button--ghost c-button--small">Select seats without price regions</button>
          <input type="file" id="priceRegionFileInput" accept=".tpr,.txt" style="display:none" />
          <div id="priceRegionList" class="price-region-list"></div>
        </div>
      </div>

      <div class="c-card" data-collapsible="true" data-collapsed="true">
        <div class="c-card__header">
          <div class="c-card__title">Entry Points</div>
          <button class="c-card__toggle" type="button" aria-expanded="true" aria-label="Toggle panel" onclick="toggleRightPanel(this)"></button>
        </div>
        <div class="c-card__body c-toolbar">
          <button id="createEntryPointBtn" class="c-button c-button--ghost c-button--small">Add entry point</button>
          <button id="selectSeatsNoEntryPointBtn" class="c-button c-button--ghost c-button--small">Select seats without entry points</button>
          <div id="entryPointList" class="price-region-list"></div>
        </div>
      </div>

      <div class="c-card" data-collapsible="true" data-collapsed="true">
        <div class="c-card__header">
          <div class="c-card__title">Goodness</div>
          <button class="c-card__toggle" type="button" aria-expanded="true" aria-label="Toggle panel" onclick="toggleRightPanel(this)"></button>
        </div>
        <div class="c-card__body c-toolbar">
          <div class="goodness-settings u-font--small">
            <label for="goodnessRangeCount">Ranking ranges</label>
            <input id="goodnessRangeCount" type="number" min="1" max="25" step="1" value="3" />
            <div id="goodnessRangeHint" class="goodness-hint">Each range spans 1000 (1-1000, 1001-2000, ...).</div>
          </div>
          <button id="selectSeatsNoGoodnessBtn" class="c-button c-button--ghost c-button--small">Select seats without goodness</button>
        </div>
      </div>


    </aside>
  </div>

    <div id="tooltip"></div>
    <div id="seatContextMenu" class="context-menu" aria-hidden="true">
      <div class="context-menu__list">
        <button id="editSeatsMenuItem" class="context-menu__item" type="button">Edit seat(s)</button>
        <button id="editRowsMenuItem" class="context-menu__item" type="button">Edit row(s)</button>
        <button id="mergeRowsMenuItem" class="context-menu__item" type="button">Merge rows</button>
        <button id="splitRowMenuItem" class="context-menu__item" type="button">Split row at selection</button>
        <button id="equalizeRowsMenuItem" class="context-menu__item" type="button">Equalize row distance</button>
        <button id="mimicRowShapeMenuItem" class="context-menu__item" type="button">Mimic shape of first selected row</button>
        <button id="editSectionsMenuItem" class="context-menu__item" type="button">Edit section</button>
        <button id="attributeMenuItem" class="context-menu__item" type="button">Attributes</button>
        <button id="goodnessFromPointMenuItem" class="context-menu__item" type="button">Set goodness from point</button>
        <button id="deleteSelectionMenuItem" class="context-menu__item" type="button">Delete selected seat(s)</button>
      </div>
    </div>
  <input type="file" id="bgFileInput" accept="image/*" style="display:none" />
  <div id="altSectionManagerOverlay">
    <div class="section-manager section-manager--alt">
      <header class="section-manager__header">
        <div class="section-manager__title">Sections</div>
        <div class="c-toolbar c-toolbar--horizontal" style="gap:0.35rem;">
          <span id="altSectionDirtyFlag" class="section-hint">Unsaved changes</span>
        </div>
      </header>
      <div class="section-manager__body">
        <aside class="section-list">
          <div class="section-list__header">
            <button id="altSectionImportExcelBtn" class="c-button c-button--primary" title="Import from Excel" style="width:100%; padding:0.7rem 0.9rem; font-weight:600; margin-bottom:0.5rem;">Import from Excel file</button>
            <input type="file" id="altSectionImportExcelInput" accept=".xlsx,.xls" style="display:none" />
            <button id="altSectionCreateBtn" class="c-button c-button--primary" title="New section" style="width:100%; padding:0.7rem 0.9rem; font-weight:600;">+ New section</button>
          </div>
          <div id="altSectionCards" class="section-cards"></div>
        </aside>
        <div class="section-editor section-editor--alt">
          <div class="alt-section-toolbar">
            <div class="alt-section-toolbar__group alt-section-toolbar__group--tools">
              <button id="altToolSelectBtn" class="c-button c-button--ghost c-button--small c-button--active">Select (S)</button>
              <button id="altToolDrawBtn" class="c-button c-button--ghost c-button--small">Draw (D)</button>
            </div>
            <div class="alt-section-toolbar__divider" aria-hidden="true"></div>
            <div class="alt-section-toolbar__group">
              <button id="altGapNewBtn" class="c-button c-button--ghost c-button--small">New RowId (N)</button>
              <button id="altSetStartRowBtn" class="c-button c-button--ghost c-button--small">Set start row</button>
              <button id="altReverseRowOrderBtn" class="c-button c-button--ghost c-button--small">Reverse row order</button>
              <button id="altSetRowsManualBtn" class="c-button c-button--ghost c-button--small">Set rows manually</button>
              <button id="altDuplicateRowBtn" class="c-button c-button--ghost c-button--small">Duplicate row</button>
              <button id="altAddRowBtn" class="c-button c-button--ghost c-button--small">Add row</button>
              <button id="altClearRowBtn" class="c-button c-button--ghost c-button--small">Clear current row</button>
              <button id="altClearAllRowsBtn" class="c-button c-button--ghost c-button--small">Clear all rows</button>
            </div>
            <div class="alt-section-toolbar__divider" aria-hidden="true"></div>
            <div class="alt-section-toolbar__group">
              <button id="altAddSeatBtn" class="c-button c-button--ghost c-button--small">Add seat</button>
              <button id="altRemoveSeatBtn" class="c-button c-button--ghost c-button--small">Remove seat</button>
              <button id="altSetStartSeatBtn" class="c-button c-button--ghost c-button--small">Set start seat</button>
              <button id="altReverseSeatOrderBtn" class="c-button c-button--ghost c-button--small">Reverse seat order</button>
              <div class="alt-seat-numbering">
                <select id="altSeatNumberingMode" class="c-select c-select--small">
                  <option value="row">Start each row at 1</option>
                  <option value="continuous">Continous seat numbering</option>
                </select>
                <div id="altContinuousControls" class="alt-seat-numbering__current" hidden>
                  <label for="altContinuousStartSeat" class="alt-seat-numbering__label">Current start</label>
                  <input id="altContinuousStartSeat" class="alt-seat-numbering__input" type="text" inputmode="numeric" readonly />
                  <button id="altContinuousSkipBtn" class="c-button c-button--ghost c-button--small" type="button">Skip</button>
                </div>
              </div>
            </div>
          </div>
          <div class="alt-section-canvas-wrap" id="altSectionCanvasWrap">
            <canvas id="altSectionCanvas" class="alt-section-canvas"></canvas>
          </div>
          <div class="section-editor__actions-row">
            <div></div>
            <div class="section-editor__actions-right c-toolbar c-toolbar--horizontal">
              <button id="altSectionManagerClose" class="c-button c-button--ghost c-button--small">Close</button>
              <button id="altSectionSaveCloseBtn" class="c-button c-button--secondary c-button--small">Save and close</button>
              <button id="altSectionSaveBtn" class="c-button c-button--primary c-button--small">Save section</button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
  <div id="altSeatTooltip" class="alt-seat-tooltip">Sista plats: 1</div>

  <div id="newLayoutOverlay">
    <div id="newLayoutModal">
      <h3>Create new layout</h3>
      <div class="new-layout-field">
        <label for="newProjectName">Project name</label>
        <input id="newProjectName" type="text" placeholder="e.g. ArenaLayout2026" />
      </div>
      <div class="new-layout-field">
        <label for="newVenueId">VenueId</label>
        <input id="newVenueId" type="text" inputmode="numeric" pattern="[0-9]*" placeholder="Enter VenueId" />
      </div>
      <div class="new-layout-actions">
        <button id="newLayoutCancel" class="c-button c-button--ghost c-button--small">Cancel</button>
        <button id="newLayoutStart" class="c-button c-button--primary c-button--small">Create</button>
      </div>
    </div>
  </div>

  <div id="priceRegionOverlay">
    <div id="priceRegionModal">
      <h3>New price region</h3>
      <div class="new-layout-field">
        <label for="priceRegionName">Name</label>
        <textarea id="priceRegionName" rows="4" placeholder="Enter name(s), one per line or comma-separated"></textarea>
      </div>
      <div class="new-layout-actions">
        <button id="priceRegionCancel" class="c-button c-button--ghost c-button--small">Cancel</button>
        <button id="priceRegionCreate" class="c-button c-button--primary c-button--small">Add</button>
      </div>
    </div>
  </div>
  <div id="entryPointOverlay">
    <div id="entryPointModal">
      <h3>New entry point</h3>
      <div class="new-layout-field">
        <label for="entryPointName">Name</label>
        <input id="entryPointName" type="text" placeholder="Enter name(s), comma-separated" />
      </div>
      <div class="new-layout-actions">
        <button id="entryPointCancel" class="c-button c-button--ghost c-button--small">Cancel</button>
        <button id="entryPointCreate" class="c-button c-button--primary c-button--small">Add</button>
      </div>
    </div>
  </div>

  <div id="goodnessOverlay">
    <div id="goodnessModal">
      <h3>Set goodness range</h3>
      <div class="new-layout-field">
        <div id="goodnessModalHint" class="u-font--small"></div>
      </div>
      <div class="new-layout-field">
        <label for="goodnessRangeSelect">Range</label>
        <select id="goodnessRangeSelect"></select>
      </div>
      <div class="new-layout-actions">
        <button id="goodnessCancel" class="c-button c-button--ghost c-button--small">Cancel</button>
        <button id="goodnessApply" class="c-button c-button--primary c-button--small">Apply</button>
      </div>
    </div>
  </div>

  <div id="exportOverlay">
    <div id="exportModal">
      <h3>Export files</h3>
      <div class="new-layout-field">
        <label for="exportName">Export name</label>
        <input id="exportName" type="text" placeholder="Enter name(s), comma-separated" />
      </div>
      <div class="new-layout-field">
        <label for="exportVenueId">VenueId</label>
        <input id="exportVenueId" type="text" placeholder="Enter VenueId" />
      </div>
      <div class="export-options">
        <label class="export-option">
          <input type="checkbox" id="exportTlc" checked />
          TLC
        </label>
        <label class="export-option">
          <input type="checkbox" id="exportTlt" checked />
          TLT
        </label>
        <label class="export-option">
          <input type="checkbox" id="exportTpr" checked />
          TPR
        </label>
        <label class="export-option">
          <input type="checkbox" id="exportCss" checked />
          CSS
        </label>
        <label class="export-option">
          <input type="checkbox" id="exportSvg" />
          SVG
        </label>
        <label class="export-option">
          <input type="checkbox" id="exportSvgSupport" />
          Include stage etc
        </label>
      </div>
      <div class="new-layout-actions">
        <button id="exportCancel" class="c-button c-button--ghost c-button--small">Cancel</button>
        <button id="exportConfirm" class="c-button c-button--primary c-button--small">Export</button>
      </div>
    </div>
  </div>

  <div id="helpOverlay">
    <div id="helpModal">
      <div class="help-modal__content">
        <div class="help-modal__section help-modal__grid">
          <div class="help-text">
            <div class="help-panel__title">Shortcuts</div>
            Pan: <strong>CTRL + drag</strong><br/>
            Zoom: <strong>CTRL + scroll</strong><br/>
            Multi-select: <strong>SHIFT + click</strong><br/>
            Box select: <strong>Drag without CTRL</strong><br/>
            Undo: <strong>CTRL + Z</strong>
          </div>
          <div class="help-text">
            <div class="help-panel__title">Basic Work flow</div>
            <div class="help-placeholder">Click 'Create new' to create a new layout. Name it and set a Venue Id. Select working folder (same structure as legacy Layout Editor recommended (e g GXFS/Venue/[VenueId]/Layouts)). Create sections as described in Sections Modal. Save and close when ready. Make adjustments needed using tools. Create price regions and Entry points, and assign seats to them. Entry points are not mandatory, but still recommended. Price regions panel will show a ✅ when all seats are assigned. This is crucial. Once satisfied press Export and export all files. Continue work in Boxy SVG.</div>
          </div>
        </div>
        <div class="help-modal__section">
          <div class="help-text">
            <div class="help-panel__title">Tools</div>
            <div class="help-tool-grid">
              <div class="help-tool-list">
                <div class="help-tool">
                  <div class="help-tool__title">Selection mode</div>
                  <div class="help-tool__desc">Section (S), Row (D), and Seat (F) decide what a click selects.</div>
                </div>
                <div class="help-tool">
                  <div class="help-tool__title">Select (C)</div>
                  <div class="help-tool__desc">Click or box-select seats, rows, or sections.</div>
                </div>
                <div class="help-tool">
                  <div class="help-tool__title">Move (V)</div>
                  <div class="help-tool__desc">Drag selected seats to reposition them.</div>
                </div>
                <div class="help-tool">
                  <div class="help-tool__title">Rotate (R)</div>
                  <div class="help-tool__desc">Rotate selected seats around the pivot.</div>
                </div>
                <div class="help-tool">
                  <div class="help-tool__title">Resize (Z)</div>
                  <div class="help-tool__desc">Scale selected seats using the resize handles.</div>
                </div>
                <div class="help-tool">
                  <div class="help-tool__title">Bend (B)</div>
                  <div class="help-tool__desc">Bend a selected row with an anchor handle. End points are also adjustable. Hold down shift while dragging to bend from row center. Scroll up/down to adjust bend sharpness. Double click handle to reset row. </div>
                </div>
              </div>
              <div class="help-tool-list">
                <div class="help-tool">
                  <div class="help-tool__title">Reshape row (E)</div>
                  <div class="help-tool__desc">On a selected row you can right click on any seat to create a temporary anchor point and then adjust the row from that anchor point by dragging the end seat. Hold down shift while dragging to rotate from anchor point.</div>
                </div>
                <div class="help-tool">
                  <div class="help-tool__title">Reset row (Q)</div>
                  <div class="help-tool__desc">Restore a row to a straight line from first to last seat on selected row.</div>
                </div>
                <div class="help-tool">
                  <div class="help-tool__title">Make table (T)</div>
                  <div class="help-tool__desc">Reshapes a row to mimic a table for customers wanting a table grid through the seating function.</div>
                </div>
                <div class="help-tool">
                  <div class="help-tool__title">Deselect (Ctrl+D)</div>
                  <div class="help-tool__desc">Clear the current selection.</div>
                </div>
                <div class="help-tool">
                  <div class="help-tool__title">Update outlines</div>
                  <div class="help-tool__desc">Recalculate section outlines from seats.</div>
                </div>
                <div class="help-tool">
                  <div class="help-tool__title">Update RowIds</div>
                  <div class="help-tool__desc">Renumber SeatId per row so they start at RowId.1.</div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <div class="help-modal__section help-modal__grid">
          <div class="help-text">
          <div class="help-panel__title">Price Regions</div>
            <div class="help-placeholder">Using the panel to the right, you can add price regions and set a preferred color to each one of them. Then you simply make a selection and click "Add" in order to add these seats to a specific price region. <br />Clicking "Select" makes a selection of every seat within that price region. <br />Clicking "Clear" removes every seat from that specific price region.</div>
          </div>
          <div class="help-text">
            <div class="help-panel__title">Entry Points</div>
            <div class="help-placeholder">In the same way price regions are created and managed, you also manage your Entry Points. Create them in the Entry Points Panel and then add seats to their correct entry point.<br /><br /></div>
            <div class="help-panel__title">Goodness</div>
            <div class="help-placeholder">To set goddness we first make sure to set a number of available ranking ranges in the panel to the left. After that you can make a selection, right click on the canvas where the seat with best goodness is and select "Set goodness from point". Here you select what range the selection should have. Lower is better.</div>
          </div>
        </div>

        <div class="help-modal__section help-modal__grid">
          <div class="help-text">
          <div class="help-panel__title">Create Sections</div>
            <div class="help-placeholder">Click "Manage sections" and select "+New section" to start creating a new section. Type a name and then the amount of rows for the section. Select "Draw" and then just click and drag in the canvas to create rows. Use various tools to make adjustments.</div>
          </div>
          <div class="help-text">
            <div class="help-panel__title">Import Sections</div>
            <div class="help-placeholder">You can import sections from an Excel file. In the Excel file each tab represents a section and the tab name represents the sections name. Column A is dedicated to row names, and from column B and onwards is where seat names goes. Use "-" to create one or more gaps in a row that keeps the same RowId. Use blank cells to create gaps and continues with a new RowId. You can also add the tabs "Entry" and "PriceRegion" where you can add entry points and price regions. They are all added in column A. </div>
            <div class="help-panel__title">Placeholder</div>
            <div class="help-placeholder">Placeholder text</div>
          </div>
        </div>
      </div>

      <div class="new-layout-actions">
        <button id="helpClose" class="c-button c-button--ghost c-button--small">Close</button>
      </div>
    </div>
  </div>

  <div id="seatEditOverlay">
    <div id="seatEditModal">
      <header>
        <h3>Edit seat(s)</h3>
        <button id="seatEditClose" class="c-button c-button--ghost c-button--small">Close</button>
      </header>
      <main>
        <div class="u-font--small" style="margin-bottom:0.5rem;">
          Update seat name, attributes, price region and entry point.
        </div>
        <div id="seatEditList" class="edit-list"></div>
      </main>
      <footer>
        <button id="seatEditCancel" class="c-button c-button--ghost c-button--small">Cancel</button>
        <button id="seatEditSave" class="c-button c-button--primary c-button--small">Save</button>
      </footer>
    </div>
  </div>

  <div id="rowEditOverlay">
    <div id="rowEditModal">
      <header>
        <h3>Edit row(s)</h3>
        <button id="rowEditClose" class="c-button c-button--ghost c-button--small">Close</button>
      </header>
      <main>
        <div class="u-font--small" style="margin-bottom:0.5rem;">
          Rename rows, renumber seats and add seats.
        </div>
        <div id="rowEditList" class="edit-list"></div>
      </main>
      <footer>
        <button id="rowEditCancel" class="c-button c-button--ghost c-button--small">Cancel</button>
        <button id="rowEditSave" class="c-button c-button--primary c-button--small">Save</button>
      </footer>
    </div>
  </div>

  <div id="sectionEditOverlay">
    <div id="sectionEditModal">
      <header>
        <h3>Edit section</h3>
        <button id="sectionEditClose" class="c-button c-button--ghost c-button--small">Close</button>
      </header>
      <main>
        <div class="u-font--small" style="margin-bottom:0.5rem;">
          Update section name and add rows.
        </div>
        <div id="sectionEditList" class="edit-list"></div>
        <div class="u-font--small" style="margin:0.75rem 0 0.35rem;">
          Add rows (appends after the last RowId in the section).
        </div>
        <button id="sectionAddRowBtn" class="c-button c-button--ghost c-button--small">Add row</button>
        <div id="sectionNewRowsList" class="edit-list" style="margin-top:0.5rem;"></div>
      </main>
      <footer>
        <button id="sectionEditCancel" class="c-button c-button--ghost c-button--small">Cancel</button>
        <button id="sectionEditSave" class="c-button c-button--primary c-button--small">Save</button>
      </footer>
    </div>
  </div>

  <div id="attributeModalOverlay">
    <div id="attributeModal">
      <header>
        <h3>Attributes</h3>
        <button id="attributeModalClose" class="c-button c-button--ghost c-button--small">Close</button>
      </header>
      <main>
        <div class="u-font--small" style="margin-bottom:0.5rem;">
          Choose attributes for the selected seats.
        </div>
        <div id="attributeModalList" class="attribute-modal__list"></div>
      </main>
      <footer>
        <button id="attributeModalCancel" class="c-button c-button--ghost c-button--small">Cancel</button>
        <button id="attributeModalSave" class="c-button c-button--primary c-button--small">Save &amp; close</button>
      </footer>
    </div>
  </div>

  <div id="codeModalOverlay">
    <div id="codeModal">
      <header>
        <h3>Source (.tlt)</h3>
        <button id="codeModalClose" class="c-button c-button--ghost c-button--small">Close</button>
      </header>
      <main>
        <textarea
          id="code-pane"
          class="u-font--mono u-font--smaller"
          placeholder="Your .tlt source appears here and can be edited"
        ></textarea>
      </main>
      <footer>
        <button id="codeModalApply" class="c-button c-button--primary c-button--small" disabled>Update and close</button>
      </footer>
    </div>
  </div>

<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
<script>
  // --- Globala variabler ---
  const canvas = document.getElementById("layoutCanvas");
  const canvasContainer = document.getElementById("canvas-container");
  const ctx = canvas.getContext("2d");

  const codePane = document.getElementById("code-pane");
  const alignTopBtn = document.getElementById("alignTopBtn");
  const alignBottomBtn = document.getElementById("alignBottomBtn");
  const alignLeftBtn = document.getElementById("alignLeftBtn");
  const alignRightBtn = document.getElementById("alignRightBtn");
  const alignCenterHBtn = document.getElementById("alignCenterHBtn");
  const alignCenterVBtn = document.getElementById("alignCenterVBtn");
  const flipVBtn = document.getElementById("flipVBtn");
  const flipHBtn = document.getElementById("flipHBtn");
  const alignGroupingSelect = document.getElementById("alignGroupingSelect");
  const rotateCcwBtn = document.getElementById("rotateCcwBtn");
  const rotateCwBtn = document.getElementById("rotateCwBtn");
  const rotateDegreesInput = document.getElementById("rotateDegreesInput");

  const openFileBtnTop = document.getElementById("openFileBtnTop");
  const openSectionManagerBtn = document.getElementById("openSectionManagerBtn");
  const saveBtn = document.getElementById("saveBtn");
  const saveAsBtn = document.getElementById("saveAsBtn");
  const closeLayoutBtn = document.getElementById("closeLayoutBtn");
  const fileInput = document.getElementById("fileInput");
  const fileInfo = document.getElementById("fileInfo");
  const themeToggleBtn = document.getElementById("themeToggleBtn");
  const helpBtn = document.getElementById("helpBtn");

  const selectToolBtn = document.getElementById("selectToolBtn");
  const panToolBtn = document.getElementById("panToolBtn");
  const moveToolBtn = document.getElementById("moveToolBtn");
  const rotateToolBtn = document.getElementById("rotateToolBtn");
  const resizeToolBtn = document.getElementById("resizeToolBtn");
  const bendToolBtn = document.getElementById("bendToolBtn");
  const reshapeRowBtn = document.getElementById("reshapeRowBtn");
  const resetRowBtn = document.getElementById("resetRowBtn");
  const makeTableBtn = document.getElementById("makeTableBtn");
  const deselectToolBtn = document.getElementById("deselectToolBtn");
  const updateOutlinesBtn = document.getElementById("updateOutlinesBtn");
  const updateRowIdsBtn = document.getElementById("updateRowIdsBtn");

  const modeSectionBtn = document.getElementById("modeSectionBtn");
  const modeRowBtn = document.getElementById("modeRowBtn");
  const modeSeatBtn = document.getElementById("modeSeatBtn");

  const seatCountEl = document.getElementById("seatCount");
  const sectionCountEl = document.getElementById("sectionCount");

  const tooltipEl = document.getElementById("tooltip");
  const seatContextMenu = document.getElementById("seatContextMenu");
  const deleteSelectionMenuItem = document.getElementById("deleteSelectionMenuItem");
  const attributeMenuItem = document.getElementById("attributeMenuItem");
  const goodnessFromPointMenuItem = document.getElementById("goodnessFromPointMenuItem");
  const editSeatsMenuItem = document.getElementById("editSeatsMenuItem");
  const editRowsMenuItem = document.getElementById("editRowsMenuItem");
  const mergeRowsMenuItem = document.getElementById("mergeRowsMenuItem");
  const splitRowMenuItem = document.getElementById("splitRowMenuItem");
  const equalizeRowsMenuItem = document.getElementById("equalizeRowsMenuItem");
  const mimicRowShapeMenuItem = document.getElementById("mimicRowShapeMenuItem");
  const editSectionsMenuItem = document.getElementById("editSectionsMenuItem");
  const attributeModalOverlay = document.getElementById("attributeModalOverlay");
  const attributeModalList = document.getElementById("attributeModalList");
  const attributeModalClose = document.getElementById("attributeModalClose");
  const attributeModalCancel = document.getElementById("attributeModalCancel");
  const attributeModalSave = document.getElementById("attributeModalSave");
  const seatEditOverlay = document.getElementById("seatEditOverlay");
  const seatEditList = document.getElementById("seatEditList");
  const seatEditClose = document.getElementById("seatEditClose");
  const seatEditCancel = document.getElementById("seatEditCancel");
  const seatEditSave = document.getElementById("seatEditSave");
  const rowEditOverlay = document.getElementById("rowEditOverlay");
  const rowEditList = document.getElementById("rowEditList");
  const rowEditClose = document.getElementById("rowEditClose");
  const rowEditCancel = document.getElementById("rowEditCancel");
  const rowEditSave = document.getElementById("rowEditSave");
  const sectionEditOverlay = document.getElementById("sectionEditOverlay");
  const sectionEditList = document.getElementById("sectionEditList");
  const sectionEditClose = document.getElementById("sectionEditClose");
  const sectionEditCancel = document.getElementById("sectionEditCancel");
  const sectionEditSave = document.getElementById("sectionEditSave");
  const sectionAddRowBtn = document.getElementById("sectionAddRowBtn");
  const sectionNewRowsList = document.getElementById("sectionNewRowsList");

  const bgFileInput = document.getElementById("bgFileInput");
  const bgLoadBtn = document.getElementById("bgLoadBtn");
  const bgToggleBtn = document.getElementById("bgToggleBtn");
  const bgMoveBtn = document.getElementById("bgMoveBtn");
  const bgDeleteBtn = document.getElementById("bgDeleteBtn");
  const bgOpacityRange = document.getElementById("bgOpacityRange");
  const bgScaleRange = document.getElementById("bgScaleRange");
  const viewHoverToggle = document.getElementById("viewHoverToggle");
  const viewSectionNamesToggle = document.getElementById("viewSectionNamesToggle");
  const viewOverlayNone = document.getElementById("viewOverlayNone");
  const viewOverlayPrice = document.getElementById("viewOverlayPrice");
  const viewOverlayGoodness = document.getElementById("viewOverlayGoodness");
  const viewSeatLabelNone = document.getElementById("viewSeatLabelNone");
  const viewSeatLabelRow = document.getElementById("viewSeatLabelRow");
  const viewSeatLabelSeat = document.getElementById("viewSeatLabelSeat");
  const viewSeatLabelSeatId = document.getElementById("viewSeatLabelSeatId");
  const openCodeModalBtn = document.getElementById("openCodeModalBtn");
  const codeModalOverlay = document.getElementById("codeModalOverlay");
  const codeModalClose = document.getElementById("codeModalClose");
  const codeModalApply = document.getElementById("codeModalApply");
  const codeModalTextarea = document.getElementById("code-pane");
  const newLayoutBtn = document.getElementById("newLayoutBtn");
  const newLayoutOverlay = document.getElementById("newLayoutOverlay");
  const newLayoutStart = document.getElementById("newLayoutStart");
  const newLayoutCancel = document.getElementById("newLayoutCancel");
  const newProjectName = document.getElementById("newProjectName");
  const newVenueId = document.getElementById("newVenueId");
  const exportBtn = document.getElementById("exportBtn");
  const exportOverlay = document.getElementById("exportOverlay");
  const exportName = document.getElementById("exportName");
  const exportVenueId = document.getElementById("exportVenueId");
  const exportTlc = document.getElementById("exportTlc");
  const exportTlt = document.getElementById("exportTlt");
  const exportTpr = document.getElementById("exportTpr");
  const exportCss = document.getElementById("exportCss");
  const exportSvg = document.getElementById("exportSvg");
  const exportSvgSupport = document.getElementById("exportSvgSupport");
  const exportCancel = document.getElementById("exportCancel");
  const exportConfirm = document.getElementById("exportConfirm");
  const helpOverlay = document.getElementById("helpOverlay");
  const helpClose = document.getElementById("helpClose");
  const createPriceRegionBtn = document.getElementById("createPriceRegionBtn");
  const loadPriceRegionBtn = document.getElementById("loadPriceRegionBtn");
  const selectSeatsNoPriceRegionBtn = document.getElementById("selectSeatsNoPriceRegionBtn");
  const priceRegionFileInput = document.getElementById("priceRegionFileInput");
  const priceRegionList = document.getElementById("priceRegionList");
  const priceRegionOverlay = document.getElementById("priceRegionOverlay");
  const priceRegionName = document.getElementById("priceRegionName");
  const priceRegionCancel = document.getElementById("priceRegionCancel");
  const priceRegionCreate = document.getElementById("priceRegionCreate");
  const createEntryPointBtn = document.getElementById("createEntryPointBtn");
  const selectSeatsNoEntryPointBtn = document.getElementById("selectSeatsNoEntryPointBtn");
  const entryPointList = document.getElementById("entryPointList");
  const entryPointOverlay = document.getElementById("entryPointOverlay");
  const entryPointName = document.getElementById("entryPointName");
  const entryPointCancel = document.getElementById("entryPointCancel");
  const entryPointCreate = document.getElementById("entryPointCreate");
  const goodnessRangeCountInput = document.getElementById("goodnessRangeCount");
  const goodnessRangeHint = document.getElementById("goodnessRangeHint");
  const selectSeatsNoGoodnessBtn = document.getElementById("selectSeatsNoGoodnessBtn");
  const goodnessOverlay = document.getElementById("goodnessOverlay");
  const goodnessRangeSelect = document.getElementById("goodnessRangeSelect");
  const goodnessCancel = document.getElementById("goodnessCancel");
  const goodnessApply = document.getElementById("goodnessApply");
  const goodnessModalHint = document.getElementById("goodnessModalHint");
  const altSectionManagerOverlay = document.getElementById("altSectionManagerOverlay");
  const altSectionManagerClose = document.getElementById("altSectionManagerClose");
  const altSectionCardsEl = document.getElementById("altSectionCards");
  const altSectionImportExcelBtn = document.getElementById("altSectionImportExcelBtn");
  const altSectionImportExcelInput = document.getElementById("altSectionImportExcelInput");
  const altSectionCreateBtn = document.getElementById("altSectionCreateBtn");
  const altSectionDirtyFlag = document.getElementById("altSectionDirtyFlag");
  const altSectionCanvasWrap = document.getElementById("altSectionCanvasWrap");
  const altSectionCanvas = document.getElementById("altSectionCanvas");
  const altSeatTooltip = document.getElementById("altSeatTooltip");
  const altToolSelectBtn = document.getElementById("altToolSelectBtn");
  const altToolDrawBtn = document.getElementById("altToolDrawBtn");
  const altGapNewBtn = document.getElementById("altGapNewBtn");
  const altReverseSeatOrderBtn = document.getElementById("altReverseSeatOrderBtn");
  const altSetStartSeatBtn = document.getElementById("altSetStartSeatBtn");
  const altAddSeatBtn = document.getElementById("altAddSeatBtn");
  const altRemoveSeatBtn = document.getElementById("altRemoveSeatBtn");
  const altSetStartRowBtn = document.getElementById("altSetStartRowBtn");
  const altReverseRowOrderBtn = document.getElementById("altReverseRowOrderBtn");
  const altSetRowsManualBtn = document.getElementById("altSetRowsManualBtn");
  const altDuplicateRowBtn = document.getElementById("altDuplicateRowBtn");
  const altAddRowBtn = document.getElementById("altAddRowBtn");
  const altClearRowBtn = document.getElementById("altClearRowBtn");
  const altClearAllRowsBtn = document.getElementById("altClearAllRowsBtn");
  const altSeatNumberingModeSelect = document.getElementById("altSeatNumberingMode");
  const altContinuousControls = document.getElementById("altContinuousControls");
  const altContinuousStartSeatInput = document.getElementById("altContinuousStartSeat");
  const altContinuousSkipBtn = document.getElementById("altContinuousSkipBtn");
  const altSectionSaveBtn = document.getElementById("altSectionSaveBtn");
  const altSectionSaveCloseBtn = document.getElementById("altSectionSaveCloseBtn");
  const sectionRawText = new Map();
  const priceRegions = [];
  const entryPoints = [];
  const PRICE_REGION_NAME_MAX = 30;
  const SECTION_NAME_MAX = 20;
  const GOODNESS_RANGE_SIZE = 1000;
  const GOODNESS_HEAT_START = "#f2a23b";
  const GOODNESS_HEAT_END = "#2a6bd7";
  const DEFAULT_GOODNESS_RANGE_COUNT = 3;
  let rowEditState = new Map();
  let sectionEditTargetId = null;
  let sectionEditRowCounter = 0;
  let altSectionTool = "select";
  let altRowLines = [];
  let altActiveLineIndex = null;
  let altIsDrawing = false;
  let altDrawStart = null;
  let altDrawEnd = null;
  let altDrawLineIndex = null;
  const ALT_SEAT_RADIUS = 8;
  const ALT_SEAT_SPACING = 18;
  const ALT_ROW_HEIGHT = 24;
  const ALT_ROW_GAP = 6;
  const ALT_MAX_SLOTS = 100;
  let altSeatNumberingMode = "row";
  let altContinuousStartSeat = 1;

  let seats = [];
  let outlines = [];
  let sectionNames = new Map();
  let layoutBounds = null;
  let backgroundState = {
    dataUrl: "",
    img: null,
    enabled: false,
    opacity: 0.4,
    scale: 1,
    originX: 0,
    originY: 0
  };
  let backgroundMoveMode = false;
  let isDraggingBackground = false;
  let backgroundDragStartWorldX = 0;
  let backgroundDragStartWorldY = 0;
  let backgroundDragOriginX = 0;
  let backgroundDragOriginY = 0;
  let seatLabelMode = "none";
  let lastDirectoryHandle = null;

  function setSeatLabelMode(mode, syncUI = true) {
    seatLabelMode = mode || "none";
    if (syncUI) {
      if (mode === "none" && viewSeatLabelNone) viewSeatLabelNone.checked = true;
      if (mode === "row" && viewSeatLabelRow) viewSeatLabelRow.checked = true;
      if (mode === "seat" && viewSeatLabelSeat) viewSeatLabelSeat.checked = true;
      if (mode === "seatId" && viewSeatLabelSeatId) viewSeatLabelSeatId.checked = true;
    }
    renderCanvas();
  }

  function setOverlayMode(mode, syncUI = true, persist = true) {
    if (mode === "price") overlayMode = "price";
    else if (mode === "goodness") overlayMode = "goodness";
    else overlayMode = "none";
    showPriceRegions = overlayMode === "price";
    showGoodnessHeatmap = overlayMode === "goodness";
    if (syncUI) {
      if (viewOverlayNone) viewOverlayNone.checked = overlayMode === "none";
      if (viewOverlayPrice) viewOverlayPrice.checked = overlayMode === "price";
      if (viewOverlayGoodness) viewOverlayGoodness.checked = overlayMode === "goodness";
    }
    renderCanvas();
    if (persist) saveSessionToLocalStorage();
  }

  async function tryGetDirectoryHandle(handle) {
    if (!handle) return null;
    if (handle.kind === "directory") return handle;
    if (typeof handle.getParent === "function") {
      try {
        const dir = await handle.getParent();
        if (dir?.kind === "directory") return dir;
      } catch (_) {}
    }
    return null;
  }
  let renderGrayscale = false;
  let showHoverInfo = true;
  let showSectionNames = false;
  let showPriceRegions = false;
  let showGoodnessHeatmap = false;
  let overlayMode = "none";
  let goodnessRangeCount = DEFAULT_GOODNESS_RANGE_COUNT;
  let goodnessAnchorPoint = null;
  let restoredSession = false;
  let sectionColors = new Map();
  let sectionDrafts = [];
  let activeSectionDraftId = null;
  let sectionDirty = false;
  let forceSaveAs = false;
  let layoutActive = false;

  // Kamera/transform
  let translateX = 0;
  let translateY = 0;
  let scale = 1;

  // Pan
  let isPanning = false;
  let panStartX = 0;
  let panStartY = 0;
  let panStartTranslateX = 0;
  let panStartTranslateY = 0;

  // Drag-flytt av markerade
  let isDraggingSelection = false;
  let dragStartWorldX = 0;
  let dragStartWorldY = 0;
  let dragStartSnapshot = null; // startpositioner för alla seats vid move

  // Rotation av markerade
  let isRotatingSelection = false;
  let rotateStartSnapshot = null;
  let rotateSnapshotById = null;
  let rotatePivot = null;
  let rotateStartAngle = 0;
  let hasRotatedDuringDrag = false;

  // Resize av markerade
  let isResizingSelection = false;
  let resizeStartSnapshot = null;
  let resizeSnapshotById = null;
  let resizePivot = null;
  let resizeStartBounds = null;
  let resizeHandleId = null;
  let resizeStartVector = null;
  let hasResizedDuringDrag = false;

  // Bend av rader
  let isBendingSelection = false;
  let bendStartSnapshot = null;
  let bendControlPoint = null; // anchor for quadratic bend
  let bendTension = 0;
  let bendRowsData = null;
  let hasBentDuringDrag = false;
  let bendDragTarget = null;     // "anchor" | "start" | "end"
  let bendActiveRowId = null;

  // Reshape row
  let isReshapingRow = false;
  let reshapeDragTarget = null; // "start" | "end"
  let reshapeStartSnapshot = null;
  let reshapeSnapshotById = null;
  let reshapeRowSeats = null;
  let reshapePivotSeatId = null;

  // Ruta-markering
  let selectionRectActive = false;
  let rectStartCanvasX = 0;
  let rectStartCanvasY = 0;
  let rectEndCanvasX = 0;
  let rectEndCanvasY = 0;

  // Verktyg & markeringsläge
  let currentTool = "select";   // "select" | "move" | "rotate" | "resize" | "bend" | "reshape"
  let selectionMode = "section";   // "section" | "row" | "seat"
  let selectionOrderCounter = 1;
  let lastSelectedSeatId = null;
  let lastSelectionSource = "click"; // "click" | "box" | "program"
  let alignGroupingMode = "group";

  // Smart rendering / prestanda
  let lastVisibleSeatCount = 0;
  const RECT_DOT_THRESHOLD = 2500; // över detta: små fyrkanter
  const HOVER_VISIBLE_LIMIT = 4000; // över detta: ingen tooltip/hover-info

  let hoverSeat = null;

  // Historik (undo, inkl. markering)
  let history = [];
  let historyIndex = -1;

  // Filhantering / kodsynk
  let currentFileHandle = null;
  let currentFileName = "";
  let hasUnsavedChanges = false;

  let originalLines = [];
  let seatIdToLineIndex = new Map();

  const MIN_SEAT_SCREEN_RADIUS = 3;  // px vid långt utzoomat
  const BASE_WORLD_RADIUS = 50;      // i "layoutvärlden"
  const SESSION_STORAGE_KEY = "arenaEditorSessionV1";

  const DB_NAME = "arenaEditorFileHandles";
  const DB_VERSION = 1;
  const DB_STORE = "handles";

  const supportsOpenPicker = typeof window.showOpenFilePicker === "function";
  const supportsSavePicker = typeof window.showSaveFilePicker === "function";


  // --- Canvas-storlek ---
  function resizeCanvas() {
    const rect = canvasContainer.getBoundingClientRect();
    const padding = 12;
    canvas.width = Math.max(100, rect.width - padding * 2);
    canvas.height = Math.max(100, rect.height - padding * 2);
    renderCanvas();
  }

  window.addEventListener("resize", resizeCanvas);
  resizeCanvas();

  // --- Utilities: world <-> screen ---
  function worldToScreen(wx, wy) {
    return {
      x: wx * scale + translateX,
      y: wy * scale + translateY
    };
  }

  function screenToWorld(sx, sy) {
    return {
      worldX: (sx - translateX) / scale,
      worldY: (sy - translateY) / scale
    };
  }

  // --- Färger per sektion ---
  function hslToHex(h, s, l) {
    const sat = Math.max(0, Math.min(1, s / 100));
    const light = Math.max(0, Math.min(1, l / 100));
    const c = (1 - Math.abs(2 * light - 1)) * sat;
    const hh = ((h % 360) + 360) % 360 / 60;
    const x = c * (1 - Math.abs((hh % 2) - 1));
    let r = 0, g = 0, b = 0;
    if (hh >= 0 && hh < 1) [r, g, b] = [c, x, 0];
    else if (hh >= 1 && hh < 2) [r, g, b] = [x, c, 0];
    else if (hh >= 2 && hh < 3) [r, g, b] = [0, c, x];
    else if (hh >= 3 && hh < 4) [r, g, b] = [0, x, c];
    else if (hh >= 4 && hh < 5) [r, g, b] = [x, 0, c];
    else if (hh >= 5 && hh < 6) [r, g, b] = [c, 0, x];
    const m = light - c / 2;
    const toHex = (v) => Math.round((v + m) * 255).toString(16).padStart(2, "0");
    return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
  }

  function normalizeColorToHex(color, fallback) {
    if (typeof color === "string") {
      const trimmed = color.trim();
      if (/^#([0-9a-f]{6})$/i.test(trimmed)) return trimmed;
      const hslMatch = trimmed.match(/hsl\(\s*([\d.]+)\s*,\s*([\d.]+)%\s*,\s*([\d.]+)%\s*\)/i);
      if (hslMatch) {
        return hslToHex(
          parseFloat(hslMatch[1]),
          parseFloat(hslMatch[2]),
          parseFloat(hslMatch[3])
        );
      }
    }
    return fallback;
  }

  function generatePriceRegionColor(index) {
    const goldenAngle = 137.508;
    const hue = (index * goldenAngle) % 360;
    return hslToHex(hue, 58, 54);
  }

  function rebuildSectionColors() {
    sectionColors.clear();
    const uniqueSections = Array.from(new Set(
      seats.map(s => s.sectionId).filter(Boolean)
    )).sort();
    const grayPalette = [];
    const steps = 40;
    const minL = 20;
    const maxL = 85;
    for (let i = 0; i < steps; i++) {
      const t = steps === 1 ? 0 : i / (steps - 1);
      const l = minL + (maxL - minL) * t;
      grayPalette.push(`hsl(0, 0%, ${l.toFixed(1)}%)`);
    }
    uniqueSections.forEach((secId, i) => {
      const color = grayPalette[i % grayPalette.length];
      sectionColors.set(secId, color);
    });
  }

  function sectionIdToOutlineCode(sectionId) {
    if (!sectionId) return "0";
    const parts = String(sectionId).split(".");
    const major = parseInt(parts[0], 10);
    const minor = parseInt(parts[1] || "0", 10);
    if (!Number.isFinite(major)) return String(sectionId);
    const minorStr = Number.isFinite(minor) ? String(minor).padStart(2, "0") : "00";
    return `${major}${minorStr}000000000`;
  }

  function outlineCodeToSectionId(code) {
    if (!code) return null;
    const codeStr = String(code);
    const trimmed = codeStr.replace(/0{9}$/, "");
    if (trimmed.length < 2) return codeStr;
    const majorStr = trimmed.slice(0, -2);
    const minorStr = trimmed.slice(-2);
    const major = parseInt(majorStr, 10);
    const minor = parseInt(minorStr, 10);
    if (!Number.isFinite(major) || !Number.isFinite(minor)) return codeStr;
    return `${major}.${minor}`;
  }

  // --- Parse av .tlt ---
  function parseTlt(text) {
    seats = [];
    outlines = [];
    selectionOrderCounter = 1;
    lastSelectedSeatId = null;
    sectionNames = new Map();
    originalLines = text.split(/\r?\n/);
    seatIdToLineIndex = new Map();

    const sections = new Map();
    const rows = new Map();

    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;

    for (let lineIndex = 0; lineIndex < originalLines.length; lineIndex++) {
      const line = originalLines[lineIndex].trim();
      if (!line) continue;

      // Outline
      if (line.includes("<Outline|")) {
        const polyIndex = line.indexOf("[Poly|");
        if (polyIndex >= 0) {
          const beforePoly = line.slice(0, polyIndex);
          const suffix = line.includes("|]>") ? "|]>" : (line.includes("]>") ? "]>" : "]");

          let sectionId = null;
          let sectionNameFromLine = null;
          let prefixTokens = [];
          const outlineStart = line.indexOf("<Outline|");
          if (outlineStart >= 0 && outlineStart < polyIndex) {
            const prefixPart = line.slice(outlineStart + "<Outline|".length, polyIndex);
            prefixTokens = prefixPart.split("|").filter(Boolean);
            if (prefixTokens.length >= 1) sectionId = outlineCodeToSectionId(prefixTokens[0]) || prefixTokens[0];
            if (prefixTokens.length >= 2) sectionNameFromLine = prefixTokens[1];
          }
          if (!sectionId) {
            const sectionMatch = line.match(/SectionId=([^|]+)/i);
            sectionId = sectionMatch ? sectionMatch[1] : null;
          }

          let polyPart = line.slice(polyIndex + 6);
          polyPart = polyPart.replace(/[\]>]/g, "");
          const tokens = polyPart.split("|");
          const coords = [];
          for (let i = 3; i < tokens.length; i++) {
            const t = tokens[i];
            if (!t) continue;
            const [xs, ys] = t.split(",");
            const x = parseFloat(xs);
            const y = parseFloat(ys);
            if (Number.isFinite(x) && Number.isFinite(y)) {
              coords.push({ x, y });
            }
          }
          if (coords.length > 1) {
            outlines.push({
          sectionId,
          sectionName: sectionNameFromLine || sectionNames.get(sectionId) || "",
          coords,
          lineIndex,
          beforePoly,
          suffix,
              headerTokens: tokens.slice(0, 3),
              prefixTokens
            });
          }
        }
        continue;
      }

      const pipeIdx = line.indexOf("|");
      if (pipeIdx < 0) continue;
      const timestamp = line.slice(0, pipeIdx);
      const rest = line.slice(pipeIdx + 1);
      const parts = rest.split("|");
      if (parts.length < 1) continue;
      const cmd = parts[0];

      const kv = {};
      const attributes = [];
      for (let i = 1; i < parts.length; i++) {
        const seg = parts[i];
        const eqIdx = seg.indexOf("=");
        if (eqIdx > -1) {
          const key = seg.slice(0, eqIdx);
          const val = seg.slice(eqIdx + 1);
          if (key === "Attribute") {
            attributes.push(val);
          } else {
            kv[key] = val;
          }
        }
      }

      if (cmd === "SectionAdd") {
        const sectionId = kv["SectionId"];
        const name = kv["Name"] || "";
        if (sectionId) {
          sections.set(sectionId, name);
          sectionNames.set(sectionId, name);
        }
      } else if (cmd === "RowAdd") {
        const rowId = kv["RowId"];
        const name = kv["Name"] || "";
        if (rowId) rows.set(rowId, name);
      } else if (cmd === "SeatAdd") {
        const seatId = kv["SeatId"];
        if (!seatId) continue;

        const name = kv["Name"] || "";
        const cx = parseFloat(kv["CenterX"]);
        const cy = parseFloat(kv["CenterY"]);
        if (!Number.isFinite(cx) || !Number.isFinite(cy)) continue;

        const rotation = parseFloat(kv["Rotation"] || "0");
        const width = parseFloat(kv["Width"] || "100");
        const entryVia = kv["EntryVia"] ?? "-";
        const goodnessRaw = kv["Goodness"];
        const goodnessVal = parseFloat(goodnessRaw != null ? goodnessRaw : "0");
        const goodness = Number.isFinite(goodnessVal) ? goodnessVal : 0;
        const attributesList = attributes;

        let sectionId = null;
        let rowId = null;
        const idParts = seatId.split(".");
        if (idParts.length >= 2) {
          sectionId = idParts[0] + "." + idParts[1];
        }
        if (idParts.length >= 3) {
          rowId = idParts[0] + "." + idParts[1] + "." + idParts[2];
        }

        const sectionName = sectionId ? (sections.get(sectionId) || "") : "";
        const rowName = rowId ? (rows.get(rowId) || "") : "";

        const seat = {
          seatId,
          name,
          sectionId,
          rowId,
          sectionName,
          rowName,
          centerX: cx,
          centerY: cy,
          vx: cx,
          vy: cy,
          radius: 10, // grund i world (justeras i render)
          rotation,
          width,
          entryVia,
          goodness,
          attributes: attributesList,
          timestamp,
          selected: false,
          selectedAt: null,
          lineIndex
        };

        seats.push(seat);
        seatIdToLineIndex.set(seatId, lineIndex);

        if (cx < minX) minX = cx;
        if (cx > maxX) maxX = cx;
        if (cy < minY) minY = cy;
        if (cy > maxY) maxY = cy;
      }
    }

    // Info-panel
    seatCountEl.textContent = seats.length.toString();
    const uniqueSections = new Set(seats.map(s => s.sectionId).filter(Boolean));
    sectionCountEl.textContent = uniqueSections.size.toString();

    rebuildSectionColors();
    updatePriceRegionStatus();
    syncEntryPointsFromSeats();
    renderEntryPointList();
    updateEntryPointUi();
    const outlinesChangedOnLoad = syncOutlinesIntoOriginalLines();
    if (outlinesChangedOnLoad) {
      const newText = originalLines.join("\n");
      if (codePane.value !== newText) {
        codePane.value = newText;
      }
    }

    // Fit to canvas
    if (seats.length > 0 && Number.isFinite(minX) && Number.isFinite(maxX)) {
      const paddingWorld = 50;
      const widthWorld = (maxX - minX) + paddingWorld * 2;
      const heightWorld = (maxY - minY) + paddingWorld * 2;
      const cxWorld = (minX + maxX) / 2;
      const cyWorld = (minY + maxY) / 2;

      const scaleX = canvas.width / widthWorld;
      const scaleY = canvas.height / heightWorld;
      scale = Math.min(scaleX, scaleY);

      translateX = canvas.width / 2 - cxWorld * scale;
      translateY = canvas.height / 2 - cyWorld * scale;
    }

    // Historik: nollställ och lägg första snapshot
    history = [];
    historyIndex = -1;
    pushHistorySnapshot();

    renderCanvas();

    hasUnsavedChanges = outlinesChangedOnLoad;
    updateSaveButton();

    saveSessionToLocalStorage();
    return outlinesChangedOnLoad;
  }

  // --- Historik (undo) – nu inkl. markering ---
  function captureSeatState() {
    return seats.map(s => ({
      seatId: s.seatId,
      vx: s.vx,
      vy: s.vy,
      centerX: s.centerX,
      centerY: s.centerY,
      selected: s.selected
    }));
  }

  function applySeatState(state) {
    const byId = new Map();
    for (const s of seats) byId.set(s.seatId, s);

    let anyPositionChanged = false;
    for (const snap of state) {
      const s = byId.get(snap.seatId);
      if (!s) continue;
      if (s.centerX !== snap.centerX || s.centerY !== snap.centerY) {
        anyPositionChanged = true;
      }
      s.vx = snap.vx;
      s.vy = snap.vy;
      s.centerX = snap.centerX;
      s.centerY = snap.centerY;
      if (typeof snap.selected === "boolean") {
        s.selected = snap.selected;
      }
    }

    rebuildSelectionOrderFromSelection();
    renderCanvas();

    // Markera ändringar & kod om positionerna ändrats
    if (anyPositionChanged) {
      hasUnsavedChanges = true;
      updateCodeFromSeats();
    }
    updateSaveButton();
    updateMoveButtonState();
  }

  function pushHistorySnapshot() {
    if (!seats.length) return;
    const snapshot = captureSeatState();
    history = history.slice(0, historyIndex + 1);
    history.push(snapshot);
    historyIndex = history.length - 1;
  }

  function undoLast() {
    if (historyIndex > 0) {
      historyIndex--;
      const state = history[historyIndex];
      applySeatState(state);
    }
  }

  // --- tlt-uppbyggnad vid flyttar ---
  function formatNumber(num) {
    if (!Number.isFinite(num)) return "0";
    if (Math.abs(num - Math.round(num)) < 1e-6) return String(Math.round(num));
    let s = num.toFixed(5);
    s = s.replace(/0+$/, "").replace(/\.$/, "");
    return s;
  }

  function buildTimestamp() {
    const d = new Date();
    const pad = (v, len = 2) => String(v).padStart(len, "0");
    return (
      d.getFullYear().toString() +
      pad(d.getMonth() + 1) +
      pad(d.getDate()) +
      pad(d.getHours()) +
      pad(d.getMinutes()) +
      pad(d.getSeconds()) +
      pad(d.getMilliseconds(), 3)
    );
  }

  function buildSeatLine(seat) {
    const timestamp = seat.timestamp || "";
    const widthStr = seat.width != null ? seat.width : 100;
    const rotationStr = seat.rotation != null ? seat.rotation : 0;
    const entryStr = seat.entryVia != null ? seat.entryVia : "-";
    const goodnessValue = Number(seat.goodness);
    const goodStr = Number.isFinite(goodnessValue) ? formatNumber(goodnessValue) : "0";
    const cxStr = formatNumber(seat.centerX);
    const cyStr = formatNumber(seat.centerY);

    let line = `${timestamp}|SeatAdd|SeatId=${seat.seatId}|Name=${seat.name}` +
      `|CenterX=${cxStr}|CenterY=${cyStr}|Width=${widthStr}|Rotation=${rotationStr}` +
      `|EntryVia=${entryStr}|Goodness=${goodStr}`;
    if (seat.attributes && seat.attributes.length) {
      for (const attr of seat.attributes) {
        line += `|Attribute=${attr}`;
      }
    }
    return line;
  }

  function computeConvexHull(points) {
    if (!points || points.length < 3) return points ? [...points] : [];
    const sorted = [...points].sort((a, b) => (a.x === b.x ? a.y - b.y : a.x - b.x));
    const cross = (o, a, b) => (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);
    const lower = [];
    for (const p of sorted) {
      while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], p) <= 0) {
        lower.pop();
      }
      lower.push(p);
    }
    const upper = [];
    for (let i = sorted.length - 1; i >= 0; i--) {
      const p = sorted[i];
      while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], p) <= 0) {
        upper.pop();
      }
      upper.push(p);
    }
    upper.pop();
    lower.pop();
    return lower.concat(upper);
  }

  function expandOutline(points, padding) {
    if (!points.length || !padding) return points;
    let sumX = 0;
    let sumY = 0;
    for (const p of points) {
      sumX += p.x;
      sumY += p.y;
    }
    const cx = sumX / points.length;
    const cy = sumY / points.length;
    return points.map((p) => {
      const dx = p.x - cx;
      const dy = p.y - cy;
      const len = Math.hypot(dx, dy) || 1;
      return { x: p.x + (dx / len) * padding, y: p.y + (dy / len) * padding };
    });
  }

  function computeSectionOutlinesFromSeats(padding = 0) {
    const boundsBySection = new Map();
    const pointsBySection = new Map();
    for (const s of seats) {
      if (!s.sectionId) continue;
      if (!pointsBySection.has(s.sectionId)) pointsBySection.set(s.sectionId, []);
      pointsBySection.get(s.sectionId).push({ x: s.centerX, y: s.centerY });
      let b = boundsBySection.get(s.sectionId);
      if (!b) {
        b = { minX: s.centerX, maxX: s.centerX, minY: s.centerY, maxY: s.centerY };
        boundsBySection.set(s.sectionId, b);
      } else {
        b.minX = Math.min(b.minX, s.centerX);
        b.maxX = Math.max(b.maxX, s.centerX);
        b.minY = Math.min(b.minY, s.centerY);
        b.maxY = Math.max(b.maxY, s.centerY);
      }
    }

    layoutBounds = null;
    for (const b of boundsBySection.values()) {
      if (!layoutBounds) {
        layoutBounds = { ...b };
      } else {
        layoutBounds.minX = Math.min(layoutBounds.minX, b.minX);
        layoutBounds.maxX = Math.max(layoutBounds.maxX, b.maxX);
        layoutBounds.minY = Math.min(layoutBounds.minY, b.minY);
        layoutBounds.maxY = Math.max(layoutBounds.maxY, b.maxY);
      }
    }

    const result = [];
    for (const [sectionId, b] of boundsBySection.entries()) {
      const points = pointsBySection.get(sectionId) || [];
      let coords = [];
      if (points.length >= 3) {
        const hull = computeConvexHull(points);
        coords = expandOutline(hull, padding);
      } else {
        coords = [
          { x: b.minX - padding, y: b.minY - padding },
          { x: b.maxX + padding, y: b.minY - padding },
          { x: b.maxX + padding, y: b.maxY + padding },
          { x: b.minX - padding, y: b.maxY + padding }
        ];
      }
      result.push({
        sectionId,
        sectionName: sectionNames.get(sectionId) || "",
        coords
      });
    }
    return result;
  }

  function buildOutlineLine(sectionId, sectionName, coords, template) {
    const headerTokens = (template && Array.isArray(template.headerTokens) && template.headerTokens.length)
      ? [...template.headerTokens]
      : ["1", "10", "#FFD3D3D3"];
    while (headerTokens.length < 3) headerTokens.push("0");
    if (headerTokens.length > 3) headerTokens.length = 3;

    const defaultTimestamp = seats[0]?.timestamp || buildTimestamp();
    const timePrefixRaw = template?.beforePoly
      ? template.beforePoly.split("<Outline")[0]
      : `${defaultTimestamp}`;
    const timePrefix = timePrefixRaw.replace(/\|$/, "");

    const sectionCode = sectionIdToOutlineCode(sectionId);
    const typeToken = (template && Array.isArray(template.prefixTokens) && template.prefixTokens.length >= 3)
      ? template.prefixTokens[2]
      : "1";
    const beforePoly = `${timePrefix}<Outline|${sectionCode}|${sectionName || ""}|${typeToken}|`;
    const suffix = template?.suffix || "|]>";
    const coordTokens = coords.map(c => `${Math.round(c.x)},${Math.round(c.y)}`);
    const allTokens = [...headerTokens, ...coordTokens].join("|");
    return `${beforePoly}[Poly|${allTokens}${suffix}`;
  }

  function syncOutlinesIntoOriginalLines() {
    if (!originalLines || !originalLines.length) return false;

    const computed = computeSectionOutlinesFromSeats(20);
    const existingBySection = new Map();
    for (const o of outlines) {
      if (!o.sectionId) continue;
      existingBySection.set(o.sectionId, o);
    }

    const usedLineIndexes = new Set();
    const newOutlines = [];
    let changed = false;

    for (const outline of computed) {
      const template = existingBySection.get(outline.sectionId);
      if (template && typeof template.lineIndex === "number" && template.lineIndex >= 0 && template.lineIndex < originalLines.length) {
        const newLine = buildOutlineLine(outline.sectionId, outline.sectionName, outline.coords, template);
        if (originalLines[template.lineIndex] !== newLine) {
          originalLines[template.lineIndex] = newLine;
          changed = true;
        }
        usedLineIndexes.add(template.lineIndex);
        newOutlines.push({
          ...outline,
          lineIndex: template.lineIndex,
          beforePoly: template.beforePoly,
          suffix: template.suffix,
          headerTokens: template.headerTokens,
          prefixTokens: template.prefixTokens
        });
      } else {
        const newLine = buildOutlineLine(outline.sectionId, outline.sectionName, outline.coords, null);
        originalLines.push(newLine);
        changed = true;
        const newIndex = originalLines.length - 1;
        newOutlines.push({
          ...outline,
          lineIndex: newIndex,
          beforePoly: newLine.slice(0, newLine.indexOf("[Poly|")),
          suffix: newLine.includes("|]>") ? "|]>" : (newLine.includes("]>") ? "]>" : "]"),
          headerTokens: ["1", "10", "#FFD3D3D3"],
          prefixTokens: [sectionIdToOutlineCode(outline.sectionId), outline.sectionName || "", "1"]
        });
      }
    }

    for (const o of outlines) {
      if (!o.sectionId) continue;
      if (typeof o.lineIndex === "number" && !usedLineIndexes.has(o.lineIndex) && o.lineIndex < originalLines.length) {
        if (originalLines[o.lineIndex] !== "") {
          originalLines[o.lineIndex] = "";
          changed = true;
        }
      }
    }

    outlines = newOutlines;
    return changed;
  }

  function updateOutlinesFromSeats() {
    if (!originalLines || !originalLines.length) return;
    const outlinesChanged = syncOutlinesIntoOriginalLines();
    if (!outlinesChanged) return;
    const newText = originalLines.join("\n");
    if (codePane.value !== newText) {
      codePane.value = newText;
    }
    hasUnsavedChanges = true;
    updateSaveButton();
    saveSessionToLocalStorage();
    renderCanvas();
  }

  function updateRowIdsFromSeats() {
    if (!seats.length) return;
    const rows = new Map();
    seats.forEach((seat) => {
      if (!seat.rowId) return;
      if (!rows.has(seat.rowId)) rows.set(seat.rowId, []);
      rows.get(seat.rowId).push(seat);
    });

    const seatIdMap = new Map();
    let changed = false;

    rows.forEach((rowSeats, rowId) => {
      if (!rowSeats.length) return;
      const sorted = sortSeatsInRow(rowSeats);
      if (!sorted.length) return;
      const firstSuffix = getSeatIdSuffix(sorted[0].seatId);
      if (firstSuffix === 1) return;
      sorted.forEach((seat, idx) => {
        const nextId = `${rowId}.${idx + 1}`;
        if (seat.seatId !== nextId) {
          const oldId = seat.seatId;
          seatIdMap.set(oldId, nextId);
          seat.seatId = nextId;
          changed = true;
        }
      });
    });

    if (!changed) return;

    if (lastSelectedSeatId && seatIdMap.has(lastSelectedSeatId)) {
      lastSelectedSeatId = seatIdMap.get(lastSelectedSeatId);
    }

    let priceRegionChanged = false;
    if (seatIdMap.size) {
      const remapValues = (values, map) => {
        if (!Array.isArray(values) || !values.length) return { next: values, changed: false };
        const seen = new Set();
        const next = [];
        let changedValues = false;
        values.forEach((val) => {
          const mapped = map.get(val) || val;
          if (mapped !== val) changedValues = true;
          if (!seen.has(mapped)) {
            seen.add(mapped);
            next.push(mapped);
          } else if (mapped !== val) {
            changedValues = true;
          }
        });
        return { next, changed: changedValues };
      };
      priceRegions.forEach((region) => {
        const seatRes = remapValues(region.seats, seatIdMap);
        if (seatRes.changed) {
          region.seats = seatRes.next;
          priceRegionChanged = true;
        }
      });
    }

    if (priceRegionChanged) {
      savePriceRegionsToStorage();
      renderPriceRegionList();
      updatePriceRegionUi();
    }
    updatePriceRegionStatus();
    updateEntryPointUi();
    updateCodeFromSeats();
    const newText = originalLines.join("\n");
    if (codePane.value !== newText) {
      codePane.value = newText;
    }
    rebuildSeatLineIndex();
    renderCanvas();
    hasUnsavedChanges = true;
    updateSaveButton();
    saveSessionToLocalStorage();
    pushHistorySnapshot();
  }

  // --- Bakgrundshantering ---
  function setBackgroundEnabled(enabled) {
    const hasImage = !!backgroundState.img;
    backgroundState.enabled = hasImage && !!enabled;
    updateBackgroundMoveButtons();
    saveSessionToLocalStorage();
    renderCanvas();
  }

  function updateBackgroundMoveButtons() {
    const hasImage = !!backgroundState.img;
    if (bgToggleBtn) {
      bgToggleBtn.disabled = !hasImage;
      bgToggleBtn.textContent = backgroundState.enabled ? "Hide" : "Show";
      bgToggleBtn.classList.toggle("c-button--active", backgroundState.enabled && hasImage);
    }
    if (bgMoveBtn) {
      bgMoveBtn.disabled = !hasImage;
      bgMoveBtn.textContent = backgroundMoveMode ? "Lock" : "Move";
      bgMoveBtn.classList.toggle("c-button--active", backgroundMoveMode && hasImage);
    }
    if (bgDeleteBtn) {
      bgDeleteBtn.disabled = !hasImage;
    }
    if (bgOpacityRange) {
      bgOpacityRange.disabled = !hasImage;
    }
    if (bgScaleRange) {
      bgScaleRange.disabled = !hasImage;
    }
  }

  function setBackgroundMoveMode(enabled) {
    backgroundMoveMode = !!enabled && !!backgroundState.img;
    if (!backgroundMoveMode) {
      isDraggingBackground = false;
    }
    updateBackgroundMoveButtons();
  }

  function clearBackgroundImage() {
    backgroundState.dataUrl = "";
    backgroundState.img = null;
    backgroundState.originX = NaN;
    backgroundState.originY = NaN;
    setBackgroundEnabled(false);
    setBackgroundMoveMode(false);
    updateBackgroundMoveButtons();
  }

  function setBackgroundOpacity(val) {
    const clamped = Math.min(1, Math.max(0, val));
    backgroundState.opacity = clamped;
    bgOpacityRange.value = clamped;
    saveSessionToLocalStorage();
    renderCanvas();
  }

  function setBackgroundScale(val) {
    const clamped = Math.min(20, Math.max(0.1, val));
    backgroundState.scale = clamped;
    bgScaleRange.value = clamped;
    saveSessionToLocalStorage();
    renderCanvas();
  }

  function loadBackgroundFromDataUrl(dataUrl) {
    return new Promise((resolve, reject) => {
      if (!dataUrl) {
        backgroundState.dataUrl = "";
        backgroundState.img = null;
        backgroundState.originX = NaN;
        backgroundState.originY = NaN;
        setBackgroundEnabled(false);
        setBackgroundMoveMode(false);
        updateBackgroundMoveButtons();
        saveSessionToLocalStorage();
        renderCanvas();
        resolve();
        return;
      }
      const img = new Image();
      img.onload = () => {
        backgroundState.dataUrl = dataUrl;
        backgroundState.img = img;
        if (!Number.isFinite(backgroundState.originX) || !Number.isFinite(backgroundState.originY)) {
          if (layoutBounds) {
            backgroundState.originX = layoutBounds.minX;
            backgroundState.originY = layoutBounds.minY;
          } else {
            backgroundState.originX = 0;
            backgroundState.originY = 0;
          }
        }
        setBackgroundEnabled(true);
        updateBackgroundMoveButtons();
        saveSessionToLocalStorage();
        renderCanvas();
        resolve();
      };
      img.onerror = reject;
      img.src = dataUrl;
    });
  }

  function updateCodeFromSeats() {
    if (!originalLines || !originalLines.length) return;
    let changed = false;
    for (const s of seats) {
      if (typeof s.lineIndex === "number" && s.lineIndex >= 0 && s.lineIndex < originalLines.length) {
        const newLine = buildSeatLine(s);
        if (originalLines[s.lineIndex] !== newLine) {
          originalLines[s.lineIndex] = newLine;
          changed = true;
        }
      }
    }
    const outlinesChanged = syncOutlinesIntoOriginalLines();
    changed = changed || outlinesChanged;
    const newText = originalLines.join("\n");
    if (codePane.value !== newText) {
      codePane.value = newText;
      changed = true;
    }
    if (!changed) return;
    hasUnsavedChanges = true;
    updateSaveButton();
    saveSessionToLocalStorage(); 
  }

  function rebuildSeatLineIndex() {
    seatIdToLineIndex = new Map();
    originalLines.forEach((line, idx) => {
      if (!line.includes("|SeatAdd|")) return;
      const seatIdMatch = line.match(/SeatId=([^|]+)/);
      if (seatIdMatch) {
        seatIdToLineIndex.set(seatIdMatch[1], idx);
      }
    });
    seats.forEach((s) => {
      const idx = seatIdToLineIndex.get(s.seatId);
      if (typeof idx === "number") s.lineIndex = idx;
    });
  }

  function prunePriceRegionsToExistingSeats() {
    const existingSeatIds = new Set(seats.map(s => s.seatId));
    const existingRowIds = new Set(seats.map(s => s.rowId).filter(Boolean));
    const existingSectionIds = new Set(seats.map(s => s.sectionId).filter(Boolean));
    let changed = false;
    priceRegions.forEach((region) => {
      const nextSections = region.sections.filter(id => existingSectionIds.has(id));
      const nextRows = region.rows.filter(id => existingRowIds.has(id));
      const nextSeats = region.seats.filter(id => existingSeatIds.has(id));
      if (nextSections.length !== region.sections.length) changed = true;
      if (nextRows.length !== region.rows.length) changed = true;
      if (nextSeats.length !== region.seats.length) changed = true;
      region.sections = nextSections;
      region.rows = nextRows;
      region.seats = nextSeats;
    });
    if (changed) {
      savePriceRegionsToStorage();
      renderPriceRegionList();
      updatePriceRegionUi();
      updatePriceRegionStatus();
    }
  }


function saveSessionToLocalStorage() {
  try {
    const readSeatLabelMode = () => {
      if (viewSeatLabelRow?.checked) return "row";
      if (viewSeatLabelSeat?.checked) return "seat";
      if (viewSeatLabelSeatId?.checked) return "seatId";
      return "none";
    };
    seatLabelMode = readSeatLabelMode();
    let sessionFileName = currentFileName || "";
    if (!sessionFileName) {
      const previous = localStorage.getItem(SESSION_STORAGE_KEY);
      if (previous) {
        const prevData = JSON.parse(previous);
        if (prevData && prevData.fileName) sessionFileName = prevData.fileName;
      }
    }
    const payload = {
      tltText: codePane.value || "",
      fileName: sessionFileName,
      translateX,
      translateY,
      scale,
      background: {
        dataUrl: backgroundState.dataUrl || "",
        enabled: !!backgroundState.enabled,
        opacity: backgroundState.opacity,
        scale: backgroundState.scale,
        originX: backgroundState.originX,
        originY: backgroundState.originY
      },
      view: {
        grayscale: !!renderGrayscale,
        hoverInfo: !!showHoverInfo,
        sectionNames: !!showSectionNames,
        overlayMode: overlayMode || "none",
        priceRegions: !!showPriceRegions,
        seatLabelMode: seatLabelMode || "none"
      },
      timestamp: Date.now()
    };
    localStorage.setItem(SESSION_STORAGE_KEY, JSON.stringify(payload));
  } catch (err) {
    console.warn("Kunde inte spara session i localStorage:", err);
  }
}

function openHandleDB() {
  return new Promise((resolve, reject) => {
    if (!("indexedDB" in window)) {
      reject(new Error("IndexedDB saknas"));
      return;
    }

    const req = indexedDB.open(DB_NAME, DB_VERSION);
    req.onupgradeneeded = (e) => {
      const db = e.target.result;
      if (!db.objectStoreNames.contains(DB_STORE)) {
        db.createObjectStore(DB_STORE);
      }
    };
    req.onsuccess = (e) => {
      resolve(e.target.result);
    };
    req.onerror = (e) => {
      reject(e.target.error || new Error("Kunde inte öppna DB"));
    };
  });
}

async function saveCurrentFileHandleToDB(handle) {
  if (!handle || !("indexedDB" in window)) return;
  try {
    const db = await openHandleDB();
    const tx = db.transaction(DB_STORE, "readwrite");
    tx.objectStore(DB_STORE).put(handle, "current");
    tx.oncomplete = () => db.close();
  } catch (err) {
    console.warn("Kunde inte spara fileHandle i IndexedDB:", err);
  }
}

async function loadCurrentFileHandleFromDB() {
  if (!("indexedDB" in window)) return null;
  try {
    const db = await openHandleDB();
    return await new Promise((resolve, reject) => {
      const tx = db.transaction(DB_STORE, "readonly");
      const req = tx.objectStore(DB_STORE).get("current");
      req.onsuccess = () => {
        const handle = req.result || null;
        db.close();
        resolve(handle);
      };
      req.onerror = (e) => {
        db.close();
        reject(e.target.error || new Error("get current failed"));
      };
    });
  } catch (err) {
    console.warn("Kunde inte läsa fileHandle från IndexedDB:", err);
    return null;
  }
}

async function clearCurrentFileHandleInDB() {
  if (!("indexedDB" in window)) return;
  try {
    const db = await openHandleDB();
    const tx = db.transaction(DB_STORE, "readwrite");
    tx.objectStore(DB_STORE).delete("current");
    tx.oncomplete = () => db.close();
  } catch (err) {
    console.warn("Kunde inte rensa fileHandle i IndexedDB:", err);
  }
}


async function tryRestoreSessionFromLocalStorage() {
  try {
    const raw = localStorage.getItem(SESSION_STORAGE_KEY);
    if (!raw) return;

    const data = JSON.parse(raw);
    if (!data || !data.tltText) return;

    const accept = confirm(
      "There is a previous unsaved session.\nDo you want to restore it?"
    );
    if (!accept) return;
    restoredSession = true;

    // Återställ tlt-texten
    codePane.value = data.tltText;
    parseTlt(data.tltText);

    // Återställ filnamn-info (om vi hade ett)
    currentFileName = data.fileName || "";
    if (currentFileName) {
      fileInfo.textContent = `Recovered session \n${currentFileName}`;
    } else {
      fileInfo.textContent = "Recovered session \n(file not saved)";
    }
    loadPriceRegionsFromStorage();
    loadEntryPointsFromStorage();
    loadGoodnessSettingsFromStorage();

    // Återställ zoom/pan om vi har dem
    if (typeof data.translateX === "number") translateX = data.translateX;
    if (typeof data.translateY === "number") translateY = data.translateY;
    if (typeof data.scale === "number")      scale      = data.scale;

    if (data.background) {
      backgroundState.enabled = !!data.background.enabled;
      backgroundState.opacity = typeof data.background.opacity === "number" ? data.background.opacity : backgroundState.opacity;
      backgroundState.scale = typeof data.background.scale === "number" ? data.background.scale : backgroundState.scale;
      backgroundState.originX = typeof data.background.originX === "number" ? data.background.originX : backgroundState.originX;
      backgroundState.originY = typeof data.background.originY === "number" ? data.background.originY : backgroundState.originY;
      
      setBackgroundEnabled(!!backgroundState.enabled);
      if (data.background.dataUrl) {
        await loadBackgroundFromDataUrl(data.background.dataUrl);
      }
    }

    if (data.view) {
      renderGrayscale = false;
      showHoverInfo = !!data.view.hoverInfo;
      showSectionNames = !!data.view.sectionNames;
      const overlay = data.view.overlayMode || (data.view.priceRegions ? "price" : "none");
      setOverlayMode(overlay, true, false);
      seatLabelMode = data.view.seatLabelMode || "none";
      if (viewHoverToggle) viewHoverToggle.checked = showHoverInfo;
      if (viewSectionNamesToggle) viewSectionNamesToggle.checked = showSectionNames;
      setSeatLabelMode(seatLabelMode, true);
    }

    saveSessionToLocalStorage();



    renderCanvas();

    // Vi betraktar detta som osparade ändringar (kan ju vara viktigare än filen)
    hasUnsavedChanges = true;
    updateSaveButton();

    loadCurrentFileHandleFromDB().then((handle) => {
      if (handle) {
        currentFileHandle = handle;
        // fileInfo-texten är redan satt utifrån currentFileName
      }
    });

  } catch (err) {
    console.warn("Kunde inte läsa session från localStorage:", err);
  }
}

codePane.addEventListener("input", () => {
  hasUnsavedChanges = true;
  updateSaveButton();
  saveSessionToLocalStorage();
});


  function isTltFileName(name) {
    return /\.tlt$/i.test(String(name || "").trim());
  }

  async function loadTltFromHandle(handle) {
    const file = await handle.getFile();
    if (!isTltFileName(file?.name)) {
      alert("Only .tlt files can be opened.");
      fileInfo.textContent = "Invalid file type (only .tlt).";
      return;
    }
    const text = await file.text();
    clearBackgroundImage();
    parseTlt(text);
    codePane.value = text;
    currentFileHandle = handle;
    currentFileName = file.name || "";
    forceSaveAs = false;
    lastDirectoryHandle = await tryGetDirectoryHandle(handle) || handle;
    fileInfo.textContent = currentFileName ? `Opened file (${currentFileName})` : "Opened file";
    hasUnsavedChanges = false;
    updateSaveButton();
    setLayoutActive(true);
    saveSessionToLocalStorage();
    loadPriceRegionsFromStorage();
    loadEntryPointsFromStorage();
    loadGoodnessSettingsFromStorage();
    saveCurrentFileHandleToDB(handle);
  }

  async function handleOpenViaPicker() {
    try {
      const pickerOpts = {
        types: [
          {
            description: "Tickster Layout (.tlt)",
            accept: { "text/plain": [".tlt"] }
          }
        ],
        excludeAcceptAllOption: true,
        multiple: false
      };
      const startDir = lastDirectoryHandle || await tryGetDirectoryHandle(currentFileHandle);
      if (startDir) {
        pickerOpts.startIn = startDir;
      }
      const [handle] = await window.showOpenFilePicker(pickerOpts);
      if (handle) {
        await loadTltFromHandle(handle);
      }
    } catch (err) {
      console.warn("Öppna via picker misslyckades, provar filinput:", err);
      fileInput?.click();
    }
  }

  async function handleSaveViaPicker(forceDialog = false, suggestedNameOverride = "") {
    const text = stripEmptyLines(codePane.value || "");
    try {
      let handle = (forceSaveAs || forceDialog) ? null : currentFileHandle;
      const startDir = lastDirectoryHandle || await tryGetDirectoryHandle(currentFileHandle);
      if (!handle) {
        const pickerOpts = {
          types: [
            {
              description: "Tickster Layout (.tlt)",
              accept: { "text/plain": [".tlt"] }
            }
          ],
          suggestedName: suggestedNameOverride || currentFileName || "layout.tlt",
          excludeAcceptAllOption: false,
          startIn: startDir || undefined
        };
        handle = await window.showSaveFilePicker(pickerOpts);
      }
      if (!handle) return false;
      const writable = await handle.createWritable();
      await writable.write(text);
      await writable.close();
      currentFileHandle = handle;
      forceSaveAs = false;
      lastDirectoryHandle = await tryGetDirectoryHandle(handle) || handle;
      currentFileName = handle.name || currentFileName || "layout.tlt";
      fileInfo.textContent = `Saved ${currentFileName}`;
      hasUnsavedChanges = false;
      updateSaveButton();
      saveCurrentFileHandleToDB(handle);
      saveSessionToLocalStorage();
      return true;
    } catch (err) {
      if (err?.name === "AbortError") {
        console.warn("Spara avbrutet av användare.");
        return false;
      }
      console.warn("Spara via picker misslyckades, provar nedladdning:", err);
      downloadFallback(text, suggestedNameOverride);
      return true;
    }
  }

  function downloadFallback(text, overrideName = "") {
    try {
      const blob = new Blob([text], { type: "text/plain" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = overrideName || currentFileName || "layout.tlt";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      fileInfo.textContent = `Saved ${a.download}`;
      hasUnsavedChanges = false;
      updateSaveButton();
    } catch (err) {
      console.warn("Nedladdningsfallback misslyckades:", err);
    }
  }

  async function openFileFromInput(file) {
    if (!file) return;
    if (!isTltFileName(file?.name)) {
      alert("Only .tlt files can be opened.");
      fileInfo.textContent = "Invalid file type (only .tlt).";
      fileInput.value = "";
      return;
    }
    const text = await file.text();
    clearBackgroundImage();
    parseTlt(text);
    codePane.value = text;
    currentFileName = file.name || "";
    currentFileHandle = null;
    forceSaveAs = true;
    fileInfo.textContent = currentFileName ? `Opened file (${currentFileName})` : "Opened file";
    hasUnsavedChanges = false;
    updateSaveButton();
    setLayoutActive(true);
    saveSessionToLocalStorage();
    loadPriceRegionsFromStorage();
    loadEntryPointsFromStorage();
    clearCurrentFileHandleInDB();
    fileInput.value = "";
  }

  async function openFile() {
    if (supportsOpenPicker) {
      await handleOpenViaPicker();
    } else {
      fileInput?.click();
    }
  }

  async function saveFile() {
    if (supportsSavePicker) {
      await handleSaveViaPicker();
    } else {
      downloadFallback(stripEmptyLines(codePane.value || ""));
    }
  }

  async function saveFileAs() {
    const suggestedName = currentFileName || "layout.tlt";
    if (supportsSavePicker) {
      const didSave = await handleSaveViaPicker(true, suggestedName);
      if (didSave) {
        savePriceRegionsToStorage();
        saveEntryPointsToStorage();
        saveGoodnessSettingsToStorage();
      }
      return;
    }
    const rawName = prompt("Enter file name.", suggestedName);
    if (!rawName) return;
    const trimmed = rawName.trim();
    if (!trimmed) return;
    const hasExt = /\.tlt$/i.test(trimmed);
    const finalName = hasExt ? trimmed : `${trimmed}.tlt`;
    currentFileName = finalName;
    currentFileHandle = null;
    forceSaveAs = true;
    clearCurrentFileHandleInDB();
    downloadFallback(stripEmptyLines(codePane.value || ""), finalName);
    savePriceRegionsToStorage();
    saveEntryPointsToStorage();
    saveGoodnessSettingsToStorage();
  }

  function resetLayoutState(baseName = "", venueId = "") {
    clearBackgroundImage();
    seats = [];
    outlines = [];
    selectionOrderCounter = 1;
    lastSelectedSeatId = null;
    const initTs = buildTimestamp();
    originalLines = [`${initTs}|LayoutInit|VenueId=${venueId}`];
    seatIdToLineIndex = new Map();
    sectionNames = new Map();
    sectionColors = new Map();
    sectionRawText.clear();
    activeSectionDraftId = null;
    layoutBounds = null;
    codePane.value = originalLines.join("\n");
    currentFileHandle = null;
    forceSaveAs = true;
    currentFileName = baseName ? `${baseName}.tlt` : "";
    hasUnsavedChanges = false;
    updateSaveButton();
    seatCountEl.textContent = "0";
    sectionCountEl.textContent = "0";
    resetSectionDrafts();
    renderAltSectionCards();
    renderAltSectionDetail();
    renderCanvas();
    loadPriceRegionsFromStorage();
    loadEntryPointsFromStorage();
    loadGoodnessSettingsFromStorage();
  }

  function clearLayoutState() {
    clearBackgroundImage();
    seats = [];
    outlines = [];
    selectionOrderCounter = 1;
    lastSelectedSeatId = null;
    originalLines = [];
    seatIdToLineIndex = new Map();
    sectionNames = new Map();
    sectionColors = new Map();
    sectionRawText.clear();
    activeSectionDraftId = null;
    layoutBounds = null;
    codePane.value = "";
    currentFileHandle = null;
    currentFileName = "";
    forceSaveAs = true;
    hasUnsavedChanges = false;
    restoredSession = false;
    seatCountEl.textContent = "0";
    sectionCountEl.textContent = "0";
    goodnessAnchorPoint = null;
    setGoodnessRangeCount(DEFAULT_GOODNESS_RANGE_COUNT, false);
    resetSectionDrafts();
    renderAltSectionCards();
    renderAltSectionDetail();
    priceRegions.length = 0;
    renderPriceRegionList();
    updatePriceRegionUi();
    updatePriceRegionStatus();
    entryPoints.length = 0;
    renderEntryPointList();
    updateEntryPointUi();
    fileInfo.textContent = "No file opened or saved.";
    renderCanvas();
    updateSaveButton();
    clearCurrentFileHandleInDB();
    try {
      localStorage.removeItem(SESSION_STORAGE_KEY);
    } catch (err) {
      console.warn("Kunde inte rensa session i localStorage:", err);
    }
  }

  function setLayoutActive(active) {
    layoutActive = !!active;
    const controls = document.querySelectorAll("#app button, #app input, #app select, #app textarea");
    const alwaysEnabledIds = new Set([
      "newLayoutBtn",
      "openFileBtnTop",
      "fileInput",
      "newLayoutCancel",
      "newLayoutStart",
      "newProjectName",
      "newVenueId",
      "helpBtn",
      "themeToggleBtn"
    ]);
    controls.forEach((control) => {
      if (alwaysEnabledIds.has(control.id)) {
        control.disabled = false;
        return;
      }
      control.disabled = !layoutActive;
    });
    if (layoutActive) {
      updateSaveButton();
      updateMoveButtonState();
      updateBackgroundMoveButtons();
    }
  }

  function getLayoutMeta() {
    let venueId = "";
    for (const line of originalLines) {
      if (!line || !line.includes("|LayoutInit|")) continue;
      const match = line.match(/VenueId=([^|]+)/i);
      if (match) venueId = match[1];
      break;
    }
    return {
      venueId,
      layoutName: currentFileName || ""
    };
  }

  function getPriceRegionStorageKey() {
    const meta = getLayoutMeta();
    const venuePart = meta.venueId || "unknown";
    const layoutPart = meta.layoutName || "unsaved";
    return `arenaDesignerPriceRegions:${venuePart}:${layoutPart}`;
  }

  function loadPriceRegionsFromStorage() {
    priceRegions.length = 0;
    try {
      const raw = localStorage.getItem(getPriceRegionStorageKey());
      if (raw) {
        const data = JSON.parse(raw);
        if (data && Array.isArray(data.regions)) {
          data.regions.forEach((region, idx) => {
            if (region && region.id && region.name) {
              const fallbackColor = generatePriceRegionColor(idx);
              const normalizedColor = normalizeColorToHex(region.color, fallbackColor);
              priceRegions.push({
                id: region.id,
                name: region.name,
                color: normalizedColor,
                sections: Array.isArray(region.sections) ? region.sections : [],
                rows: Array.isArray(region.rows) ? region.rows : [],
                seats: Array.isArray(region.seats) ? region.seats : []
              });
            }
          });
        }
      }
    } catch (err) {
      console.warn("Kunde inte läsa prisregioner:", err);
    }
    renderPriceRegionList();
    updatePriceRegionUi();
    updatePriceRegionStatus();
    if (showPriceRegions) renderCanvas();
  }

  function savePriceRegionsToStorage() {
    try {
      localStorage.setItem(getPriceRegionStorageKey(), JSON.stringify({ regions: priceRegions }));
    } catch (err) {
      console.warn("Kunde inte spara prisregioner:", err);
    }
    saveSessionToLocalStorage();
  }

  function renderPriceRegionList() {
    if (!priceRegionList) return;
    priceRegionList.innerHTML = "";
    if (!priceRegions.length) {
      const empty = document.createElement("div");
      empty.className = "u-font--small";
      empty.style.color = "var(--tick-grey)";
      empty.textContent = "No price regions available.";
      priceRegionList.appendChild(empty);
      return;
    }
    priceRegions.forEach((region) => {
      const item = document.createElement("div");
      item.className = "price-region-item";

      const header = document.createElement("div");
      header.className = "price-region-item__header";
      const headerLeft = document.createElement("div");
      headerLeft.className = "price-region-item__header-left";
      const deleteBtn = document.createElement("button");
      deleteBtn.type = "button";
      deleteBtn.className = "price-region-item__delete";
      deleteBtn.textContent = "×";
      deleteBtn.dataset.role = "price-region-delete";
      deleteBtn.dataset.regionId = region.id;
      const colorInput = document.createElement("input");
      colorInput.type = "color";
      colorInput.className = "price-region-item__color";
      colorInput.value = normalizeColorToHex(region.color, "#888888");
      colorInput.dataset.role = "price-region-color";
      colorInput.dataset.regionId = region.id;
      const seatCount = getPriceRegionSeatCount(region);
      const nameInput = document.createElement("input");
      nameInput.type = "text";
      nameInput.className = "price-region-item__name";
      nameInput.value = region.name || "";
      nameInput.dataset.role = "price-region-name";
      nameInput.dataset.regionId = region.id;
      const countBadge = document.createElement("span");
      countBadge.className = "price-region-item__count";
      countBadge.textContent = String(seatCount);
      headerLeft.appendChild(colorInput);
      headerLeft.appendChild(nameInput);
      headerLeft.appendChild(countBadge);
      header.appendChild(headerLeft);

      const meta = document.createElement("div");
      meta.className = "price-region-item__meta";
      const parts = [];
      if (region.sections.length) parts.push(`Sections: ${region.sections.length}`);
      if (region.rows.length) parts.push(`Rows: ${region.rows.length}`);
      if (region.seats.length) parts.push(`Seats: ${region.seats.length}`);
      meta.textContent = parts.length ? parts.join(" • ") : "No items added";

      const actions = document.createElement("div");
      actions.className = "price-region-item__actions";
      const addBtn = document.createElement("button");
      addBtn.type = "button";
      addBtn.className = "c-button c-button--ghost c-button--small";
      addBtn.textContent = "Add";
      addBtn.dataset.role = "price-region-add";
      addBtn.dataset.regionId = region.id;
      const markBtn = document.createElement("button");
      markBtn.type = "button";
      markBtn.className = "c-button c-button--ghost c-button--small";
      markBtn.textContent = "Select";
      markBtn.dataset.role = "price-region-mark";
      markBtn.dataset.regionId = region.id;
      const clearBtn = document.createElement("button");
      clearBtn.type = "button";
      clearBtn.className = "c-button c-button--ghost c-button--small";
      clearBtn.textContent = "Clear";
      clearBtn.dataset.role = "price-region-clear";
      clearBtn.dataset.regionId = region.id;
      actions.appendChild(addBtn);
      actions.appendChild(markBtn);
      actions.appendChild(clearBtn);

      item.appendChild(deleteBtn);
      item.appendChild(header);
      item.appendChild(meta);
      item.appendChild(actions);
      priceRegionList.appendChild(item);
    });
    updatePriceRegionStatus();
  }

  function updatePriceRegionUi() {
    if (!priceRegionList) return;
    const hasSelection = getSelectedSeats().length > 0;
    priceRegionList.querySelectorAll("[data-role='price-region-add']").forEach((btn) => {
      btn.disabled = !hasSelection;
      btn.classList.toggle("price-region-item__add--active", hasSelection);
    });
    priceRegionList.querySelectorAll("[data-role='price-region-mark']").forEach((btn) => {
      const regionId = btn.dataset.regionId;
      const region = priceRegions.find(r => r.id === regionId);
      const hasItems = region ? (region.sections.length + region.rows.length + region.seats.length) > 0 : false;
      btn.disabled = !hasItems;
    });
    priceRegionList.querySelectorAll("[data-role='price-region-clear']").forEach((btn) => {
      const regionId = btn.dataset.regionId;
      const region = priceRegions.find(r => r.id === regionId);
      const hasItems = region ? (region.sections.length + region.rows.length + region.seats.length) > 0 : false;
      btn.disabled = !hasItems;
    });
  }

  function getPriceRegionMappingStatus() {
    const existingSeatIds = new Set(seats.map(s => s.seatId));
    const existingRowIds = new Set(seats.map(s => s.rowId).filter(Boolean));
    const existingSectionIds = new Set(seats.map(s => s.sectionId).filter(Boolean));
    let hasStaleMappings = false;
    priceRegions.forEach((region) => {
      if (!region) return;
      if (region.sections?.some(id => !existingSectionIds.has(id))) hasStaleMappings = true;
      if (region.rows?.some(id => !existingRowIds.has(id))) hasStaleMappings = true;
      if (region.seats?.some(id => !existingSeatIds.has(id))) hasStaleMappings = true;
    });
    const lookups = buildPriceRegionLookups();
    const allCovered = seats.length > 0 && seats.every(s => getSeatPriceRegionColor(s, lookups));
    return { allCovered, hasStaleMappings };
  }

  function updatePriceRegionStatus() {
    const statusEl = document.getElementById("priceRegionStatus");
    if (!statusEl) return;
    if (!seats.length) {
      statusEl.textContent = "❌";
      statusEl.title = "No seats in the layout";
      updateExportOptionsAvailability();
      return;
    }
    const { allCovered, hasStaleMappings } = getPriceRegionMappingStatus();
    const isOk = allCovered && !hasStaleMappings;
    statusEl.textContent = hasStaleMappings ? "⚠️" : (isOk ? "✅" : "❌");
    if (hasStaleMappings) {
      statusEl.title = "Price regions reference seats/rows/sections that do not exist in this layout";
    } else {
      statusEl.title = isOk ? "All seats belong to a price region" : "Some seats have no price region";
    }
    updateExportOptionsAvailability();
  }

  function updateExportOptionsAvailability() {
    const hasRegions = priceRegions.length > 0;
    const { allCovered, hasStaleMappings } = getPriceRegionMappingStatus();
    const enabled = hasRegions && allCovered && !hasStaleMappings;
    const tooltip = hasStaleMappings
      ? "Price regions reference seats/rows/sections that do not exist in this layout. Update them before exporting TPR/CSS/SVG."
      : "Price regions must be created and assigned to all seats before exporting TPR/CSS/SVG.";
    const applyState = (input) => {
      if (!input) return;
      const label = input.closest(".export-option");
      input.disabled = !enabled;
      if (!enabled) {
        input.checked = false;
        input.title = tooltip;
      } else {
        input.removeAttribute("title");
      }
      if (label) {
        label.classList.toggle("export-option--disabled", !enabled);
        if (!enabled) label.title = tooltip;
        else label.removeAttribute("title");
      }
    };
    applyState(exportTpr);
    applyState(exportCss);
    applyState(exportSvg);
    updateSvgSupportOptionAvailability();
  }

  function updateSvgSupportOptionAvailability() {
    if (!exportSvgSupport) return;
    const enabled = !!(exportSvg && !exportSvg.disabled && exportSvg.checked);
    const tooltip = exportSvg?.disabled
      ? (exportSvg.title || "Enable SVG export to include support graphics.")
      : "Enable SVG export to include support graphics.";
    const label = exportSvgSupport.closest(".export-option");
    exportSvgSupport.disabled = !enabled;
    if (!enabled) {
      exportSvgSupport.checked = false;
      exportSvgSupport.title = tooltip;
    } else {
      exportSvgSupport.removeAttribute("title");
    }
    if (label) {
      label.classList.toggle("export-option--disabled", !enabled);
      if (!enabled) label.title = tooltip;
      else label.removeAttribute("title");
    }
  }

  function openPriceRegionModal() {
    if (priceRegionOverlay) priceRegionOverlay.style.display = "flex";
    if (priceRegionName) {
      priceRegionName.value = "";
      setTimeout(() => priceRegionName.focus(), 50);
    }
  }

  function closePriceRegionModal() {
    if (priceRegionOverlay) priceRegionOverlay.style.display = "none";
  }

  function openExportModal() {
    if (exportOverlay) exportOverlay.style.display = "flex";
    if (exportName) {
      const base = currentFileName ? currentFileName.replace(/\.[^/.]+$/, "") : "";
      exportName.value = base || exportName.value || "";
      setTimeout(() => exportName.focus(), 50);
    }
    if (exportVenueId) {
      const meta = getLayoutMeta();
      exportVenueId.value = meta.venueId || "";
    }
    if (exportTlc) exportTlc.checked = true;
    if (exportTlt) exportTlt.checked = true;
    if (exportTpr) exportTpr.checked = true;
    if (exportCss) exportCss.checked = true;
    if (exportSvg) exportSvg.checked = true;
    if (exportSvgSupport) exportSvgSupport.checked = false;
    updateExportOptionsAvailability();
  }

  function closeExportModal() {
    if (exportOverlay) exportOverlay.style.display = "none";
  }

  function openHelpModal() {
    if (helpOverlay) helpOverlay.style.display = "flex";
  }

  function closeHelpModal() {
    if (helpOverlay) helpOverlay.style.display = "none";
  }

  function getExportBaseName() {
    const raw = (exportName?.value || "").trim();
    const fromFile = currentFileName ? currentFileName.replace(/\.[^/.]+$/, "") : "";
    const base = raw || fromFile || "layout";
    return base.replace(/[\\/:*?"<>|]/g, "_");
  }

  function buildTlcText(baseName, venueId) {
    const safeVenueId = venueId || "";
    return [
      `LayoutConfigurationName=${baseName}.tlc`,
      `LayoutName=${baseName}.tlt`,
      `PriceRegionFile=${baseName}.tpr`,
      `VenueId=${safeVenueId}`,
      "SubVenueId="
    ].join("\n");
  }

  function stripEmptyLines(text) {
    return String(text || "")
      .split(/\r?\n/)
      .filter((line) => line.trim())
      .join("\n");
  }

  function isValidRangeId(rangeId) {
    return /^[1-9]\d{7,9}$/.test(String(rangeId || ""));
  }

  function buildRangeId(region, index) {
    if (region && isValidRangeId(region.rangeId)) return String(region.rangeId);
    if (region && isValidRangeId(region.id)) return String(region.id);
    const seed = `${region.id}|${region.name}|${index}`;
    let hash = 0;
    for (let i = 0; i < seed.length; i++) {
      hash = (hash * 31 + seed.charCodeAt(i)) >>> 0;
    }
    const rangeId = (hash % 900000000) + 100000000; // 9 digits, non-zero start
    return String(rangeId);
  }

  function updateTltVenueId(text, venueId) {
    if (!venueId) return text;
    const lines = String(text || "").split(/\r?\n/);
    for (let i = 0; i < lines.length; i++) {
      if (lines[i].includes("|LayoutInit|")) {
        if (lines[i].includes("VenueId=")) {
          lines[i] = lines[i].replace(/VenueId=([^|]*)/i, `VenueId=${venueId}`);
        } else {
          lines[i] = `${lines[i]}|VenueId=${venueId}`;
        }
        break;
      }
    }
    return lines.join("\n");
  }

  function buildTprText(baseName, venueId) {
    const ts = buildTimestamp();
    const layoutName = `${baseName}.tlt`;
    const lines = [`${ts}|PriceRegionInit|VenueId=${venueId}|LayoutName=${layoutName}`];
    priceRegions.forEach((region, idx) => {
      const rangeId = buildRangeId(region, idx);
      lines.push(`${ts}|RangeInit|RangeId=${rangeId}`);
      lines.push(`${ts}|RangeSetType|RangeId=${rangeId}|RangeType=PriceRegion`);
      lines.push(`${ts}|RangeSetName|RangeId=${rangeId}|Name=${region.name}`);
      region.sections.forEach((sectionId) => {
        lines.push(`${ts}|RangeAddTo|RangeId=${rangeId}|AddedSection=${sectionId}`);
      });
      region.rows.forEach((rowId) => {
        lines.push(`${ts}|RangeAddTo|RangeId=${rangeId}|AddedRow=${rowId}`);
      });
      region.seats.forEach((seatId) => {
        lines.push(`${ts}|RangeAddTo|RangeId=${rangeId}|AddedSeat=${seatId}`);
      });
    });
    priceRegions.forEach((region, idx) => {
      const rangeId = buildRangeId(region, idx);
      const color = normalizeColorToHex(region.color, "#c9cbcd").toUpperCase();
      lines.push(`${ts}<Outline|${rangeId}|${region.name}|2|[Poly|1|5|${color}|123,321|${color}|123,321|${color}|123,321]>`);
    });
    return lines.join("\n");
  }

  function parseTprText(text) {
    const regionsById = new Map();
    const lines = String(text || "").split(/\r?\n/);
    for (const rawLine of lines) {
      const line = rawLine.trim();
      if (!line) continue;
      if (line.includes("|RangeInit|")) {
        const m = line.match(/RangeId=([^|]+)/);
        if (!m) continue;
        const rangeId = m[1];
        if (!regionsById.has(rangeId)) {
          regionsById.set(rangeId, {
            id: rangeId,
            rangeId,
            name: rangeId,
            color: "",
            sections: [],
            rows: [],
            seats: []
          });
        }
      } else if (line.includes("|RangeSetName|")) {
        const idMatch = line.match(/RangeId=([^|]+)/);
        const nameMatch = line.match(/Name=([^|]+)/);
        if (!idMatch) continue;
        const rangeId = idMatch[1];
        const region = regionsById.get(rangeId) || {
          id: rangeId,
          rangeId,
          name: rangeId,
          color: "",
          sections: [],
          rows: [],
          seats: []
        };
        if (nameMatch) region.name = nameMatch[1];
        regionsById.set(rangeId, region);
      } else if (line.includes("|RangeAddTo|")) {
        const idMatch = line.match(/RangeId=([^|]+)/);
        if (!idMatch) continue;
        const rangeId = idMatch[1];
        const region = regionsById.get(rangeId) || {
          id: rangeId,
          rangeId,
          name: rangeId,
          color: "",
          sections: [],
          rows: [],
          seats: []
        };
        const sectionMatch = line.match(/AddedSection=([^|]+)/);
        const rowMatch = line.match(/AddedRow=([^|]+)/);
        const seatMatch = line.match(/AddedSeat=([^|]+)/);
        if (sectionMatch) region.sections.push(sectionMatch[1]);
        if (rowMatch) region.rows.push(rowMatch[1]);
        if (seatMatch) region.seats.push(seatMatch[1]);
        regionsById.set(rangeId, region);
      } else if (line.includes("<Outline|")) {
        const outlineMatch = line.match(/<Outline\|([^|]+)\|([^|]+)\|[^|]*\|\[Poly\|[^|]*\|[^|]*\|(#?[0-9A-Fa-f]{6,8})/);
        if (!outlineMatch) continue;
        const rangeId = outlineMatch[1];
        const name = outlineMatch[2];
        let color = outlineMatch[3];
        if (color) {
          const raw = color.startsWith("#") ? color.slice(1) : color;
          if (raw.length === 8) {
            color = `#${raw.slice(2)}`;
          } else {
            color = `#${raw}`;
          }
        }
        const region = regionsById.get(rangeId) || {
          id: rangeId,
          rangeId,
          name: name || rangeId,
          color: "",
          sections: [],
          rows: [],
          seats: []
        };
        if (name && name !== "-") region.name = name;
        if (color) region.color = color;
        regionsById.set(rangeId, region);
      }
    }
    const regions = Array.from(regionsById.values());
    regions.forEach((region, idx) => {
      const fallbackColor = generatePriceRegionColor(idx);
      region.color = normalizeColorToHex(region.color, fallbackColor);
      region.sections = Array.from(new Set(region.sections));
      region.rows = Array.from(new Set(region.rows));
      region.seats = Array.from(new Set(region.seats));
    });
    return regions;
  }

  function buildCssText() {
    const lines = [
      "<style type=\"text/css\">",
      "circle.seat { fill: #c9cbcd; stroke: #c9cbcd; fill-opacity: 1; }",
      "circle.seat.available { stroke-width: 16px; fill-opacity: 1; }",
      "circle.seat.available.reserved { stroke-width: 25px; fill-opacity: 0; stroke: #00804f; }",
      "circle.seat.available.hovered { stroke-width: 16px; fill-opacity: 1; fill: #dff4ff; stroke: #0069a6; }",
      "circle.seat.available.tapped  { stroke-width: 16px; fill-opacity: 1; fill: #dff4ff; stroke: #0069a6; }",
      "circle.seat.available.pending { stroke-width: 25px; fill-opacity: 1; fill: #dff4ff; stroke: #0069a6; }",
      "circle.seat.available.not-allowed { stroke-width: 16px; stroke: #d6334c; fill: #d6334c; cursor: not-allowed !important; }",
      "circle.seat.available.not-enough-seats { stroke-width: 16px; stroke: #d6334c; fill: #d6334c; cursor: not-allowed !important; }",
      ".unavailable circle.seat { fill: #c9cbcd; stroke: none; fill-opacity: 0.25; }"
    ];
    priceRegions.forEach((region, idx) => {
      const color = normalizeColorToHex(region.color, "#c9cbcd");
      const rangeId = buildRangeId(region, idx);
      lines.push(`/* Colors for price region ${region.name} */`);
      lines.push(`.pr-${rangeId}.available { stroke: ${color}; fill: ${color}; }`);
      lines.push(`div.pr-${rangeId}, .c-pill.pr-${rangeId} { background-color: ${color}; }`);
    });
    lines.push("</style>");
    return lines.join("\n");
  }

  const ATTRIBUTE_TRANSLATIONS = {
    Wheelchair: "Tillgänglighetsanpassad plats",
    AccompanyingPerson: "Ledsagarplats",
    ObstructedView: "Skymd sikt",
    SomewhatObstructedView: "Sikt delvis skymd",
    SomewhatObstructedViewPole: "Synfält något begränsat p.g.a smal stolpe",
    SomewhatObstructedViewRail: "Synfält något begränsat p.g.a räcke",
    ListeningLocations: "Lyssnarplats",
    NoVisibility: "Helt skymd sikt",
    HearingLoop: "Hörselslinga",
    NoHearingLoop: "Ej hörselslinga",
    SomewhatRestrictedLegroom: "Benutrymme något begränsat",
    ExtraLegroom: "Extra benutrymme",
    LessComfortable: "Sämre komfortnivå",
    HighStageEdge: "Hög scenkant",
    SomewhatHighStageEdge: "Något hög scenkant",
    ExtraStep: "Extra trappsteg",
    SingleSeat: "Singelplats",
    SingleSeatByRails: "Singelplats vid räcke",
    ActiveSeat: "Aktiv sittplats",
    VolumeMayBeLoud: "Ljudvolymen kan upplevas hög"
  };

  function escapeXml(value) {
    return String(value ?? "")
      .replace(/&/g, "&amp;")
      .replace(/"/g, "&quot;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;");
  }

  function parseSectionIdParts(sectionId) {
    if (!sectionId) return { major: null, minor: null };
    const parts = String(sectionId).split(".");
    const major = parseInt(parts[0], 10);
    const minor = parseInt(parts[1], 10);
    return { major: Number.isFinite(major) ? major : null, minor: Number.isFinite(minor) ? minor : null };
  }

  function parseRowIdParts(rowId) {
    if (!rowId) return { major: null, minor: null, row: null };
    const parts = String(rowId).split(".");
    const major = parseInt(parts[0], 10);
    const minor = parseInt(parts[1], 10);
    const row = parseInt(parts[2], 10);
    return {
      major: Number.isFinite(major) ? major : null,
      minor: Number.isFinite(minor) ? minor : null,
      row: Number.isFinite(row) ? row : null
    };
  }

  function parseSeatIdParts(seatId) {
    if (!seatId) return { major: null, minor: null, row: null, seat: null };
    const parts = String(seatId).split(".");
    const major = parseInt(parts[0], 10);
    const minor = parseInt(parts[1], 10);
    const row = parseInt(parts[2], 10);
    const seat = parseInt(parts[3], 10);
    return {
      major: Number.isFinite(major) ? major : null,
      minor: Number.isFinite(minor) ? minor : null,
      row: Number.isFinite(row) ? row : null,
      seat: Number.isFinite(seat) ? seat : null
    };
  }

  function rowIdToSvgCode(rowId) {
    const parts = parseRowIdParts(rowId);
    if (parts.major == null || parts.minor == null || parts.row == null) return String(rowId || "");
    const minorStr = String(parts.minor).padStart(2, "0");
    const rowStr = String(parts.row).padStart(3, "0");
    return `${parts.major}${minorStr}${rowStr}000000`;
  }

  function seatIdToSvgCode(seatId) {
    const parts = parseSeatIdParts(seatId);
    if (parts.major == null || parts.minor == null || parts.row == null || parts.seat == null) return String(seatId || "");
    const minorStr = String(parts.minor).padStart(2, "0");
    const rowStr = String(parts.row).padStart(3, "0");
    const seatStr = String(parts.seat).padStart(6, "0");
    return `${parts.major}${minorStr}${rowStr}${seatStr}`;
  }

  function buildSvgPriceRegionCss() {
    const lines = [];
    priceRegions.forEach((region, idx) => {
      const color = normalizeColorToHex(region.color, "#c9cbcd");
      const rangeId = buildRangeId(region, idx);
      lines.push("");
      lines.push(`/* Colors for price region ${region.name} */`);
      lines.push(`.pr-${rangeId} { stroke: ${color}; fill: ${color}; background-color: ${color}; }`);
    });
    return lines.join("\n").trim();
  }

  function buildSvgCssText() {
    const lines = [
      ".always-visible-section-outline { fill: #d6f0ff; stroke: #0069a6; stroke-width: 10px; }",
      ".open .always-visible-section-outline { fill: rgba(243, 243, 243, 0.8); stroke: #a3aaaf; stroke-dasharray: 30px 20px; stroke-width: 10px; }",
      ".unavailable .always-visible-section-outline { fill: #ececec; stroke: #485c6a; stroke-width: 10px; }",
      ".unavailable.open .always-visible-section-outline { fill: #ececec; stroke: #a3aaaf; stroke-width: 10px; }",
      ".section-text { fill: white; font-family: Roboto; font-size: 250px; font-weight: 400; }",
      ".section-text.large { font-size: 500px; }",
      ".row-number-text { fill: #202020; font-family: Roboto; font-size: 75px; }",
      ".section-text-box { fill: #09517c; }",
      ".unavailable .section-text-box { fill: #a3aaaf; }"
    ];
    const priceCss = buildSvgPriceRegionCss();
    if (priceCss) {
      lines.push("");
      lines.push(priceCss);
    }
    return lines.join("\n");
  }

  function formatSvgNumber(num) {
    if (!Number.isFinite(num)) return "0";
    if (Math.abs(num - Math.round(num)) < 1e-6) return String(Math.round(num));
    return num.toFixed(6).replace(/0+$/, "").replace(/\.$/, "");
  }

  function medianValue(values) {
    if (!values.length) return 0;
    const sorted = [...values].sort((a, b) => a - b);
    const mid = Math.floor(sorted.length / 2);
    if (sorted.length % 2 === 1) return sorted[mid];
    return (sorted[mid - 1] + sorted[mid]) / 2;
  }

  function computeRowStep(seats) {
    if (!seats || seats.length < 2) {
      const width = Number.isFinite(seats?.[0]?.width) ? seats[0].width : 100;
      const fallback = width * 1.28;
      return { dx: fallback, dy: 0 };
    }
    const dxs = [];
    const dys = [];
    for (let i = 1; i < seats.length; i++) {
      dxs.push(seats[i].centerX - seats[i - 1].centerX);
      dys.push(seats[i].centerY - seats[i - 1].centerY);
    }
    const dx = medianValue(dxs);
    const dy = medianValue(dys);
    if (Math.abs(dx) < 1e-6 && Math.abs(dy) < 1e-6) {
      const width = Number.isFinite(seats[0].width) ? seats[0].width : 100;
      return { dx: width * 1.28, dy: 0 };
    }
    return { dx, dy };
  }

  function computeSectionBounds(sectionId, outlineBySection, rowsBySection) {
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    const outline = outlineBySection.get(sectionId);
    if (outline && outline.coords && outline.coords.length) {
      outline.coords.forEach((c) => {
        const rx = Math.round(c.x);
        const ry = Math.round(c.y);
        minX = Math.min(minX, rx);
        maxX = Math.max(maxX, rx);
        minY = Math.min(minY, ry);
        maxY = Math.max(maxY, ry);
      });
    } else {
      const rows = rowsBySection.get(sectionId);
      if (rows) {
        rows.forEach((row) => {
          row.seats.forEach((seat) => {
            const rx = Math.round(seat.centerX);
            const ry = Math.round(seat.centerY);
            minX = Math.min(minX, rx);
            maxX = Math.max(maxX, rx);
            minY = Math.min(minY, ry);
            maxY = Math.max(maxY, ry);
          });
        });
      }
    }
    if (!Number.isFinite(minX) || !Number.isFinite(minY)) return null;
    return { minX, minY, maxX, maxY };
  }

  function stripSvgPriceRegionCss(cssText) {
    if (!cssText) return "";
    return cssText.replace(/\/\* Colors for price region[\s\S]*?\}\s*/g, "").trim();
  }

  function mergeSvgCss(existingCss) {
    const cleaned = stripSvgPriceRegionCss(existingCss || "");
    const priceCss = buildSvgPriceRegionCss();
    if (!cleaned) return priceCss;
    if (!priceCss) return cleaned;
    return `${cleaned}\n\n${priceCss}`;
  }

  function normalizeSvgMarkup(markup) {
    const lines = String(markup || "").replace(/\r/g, "").split("\n");
    while (lines.length && !lines[0].trim()) lines.shift();
    while (lines.length && !lines[lines.length - 1].trim()) lines.pop();
    let minIndent = Infinity;
    lines.forEach((line) => {
      if (!line.trim()) return;
      const indent = (line.match(/^ */) || [""])[0].length;
      minIndent = Math.min(minIndent, indent);
    });
    if (!Number.isFinite(minIndent)) return "";
    return lines.map((line) => line.slice(minIndent)).join("\n");
  }

  function indentSvgMarkup(markup, spaces = 0) {
    const normalized = normalizeSvgMarkup(markup);
    if (!normalized) return "";
    const pad = " ".repeat(Math.max(0, spaces));
    return normalized
      .split("\n")
      .map((line) => `${pad}${line}`)
      .join("\n");
  }

  const SVG_SUPPORT_BACKGROUND_MARKUP = `
<rect style="fill: rgb(36, 55, 67); filter: url(&quot;#gaussian-blur-filter-0&quot;); opacity: 0.35;" x="-3616.8" y="-3338.7" width="2027.18" height="2027.18"/>
<rect style="fill: rgb(255, 255, 255); stroke: rgb(137, 137, 137);" x="-3616.8" y="-3338.7" width="2027.18" height="2027.18"/>
`;

  const SVG_SUPPORT_ALWAYS_VISIBLE_MARKUP = `
<g transform="matrix(1, 0, 0, 1, -545.751709, -914)">
  <title>Stage</title>
  <rect style="fill: rgb(36, 56, 70);" x="-566.87" y="-2424.7" width="1797.63" height="944.515" rx="16.619" ry="16.619"/>
  <text style="fill: rgb(255, 255, 255); font-family: Arial, sans-serif; font-size: 458.2px; white-space: pre;" x="-190.21" y="-1792.4">Scen</text>
</g>
<g transform="matrix(2.080746, 0, 0, 2.080746, -1405.798828, -2575.989258)">
  <title>Rullstolsplats</title>
  <g>
    <circle class="st1" cx="305.3" cy="555.2" r="50.4" style="fill: rgb(255, 255, 255);"/>
    <path class="st2" d="M305.3,607.7c-28.9,0-52.5-23.5-52.5-52.5c0-28.9,23.5-52.5,52.5-52.5s52.5,23.5,52.5,52.5 C357.8,584.1,334.2,607.7,305.3,607.7z M305.3,506.9c-26.6,0-48.3,21.7-48.3,48.3s21.7,48.3,48.3,48.3s48.3-21.7,48.3-48.3 S331.9,506.9,305.3,506.9z" style="fill: rgb(68, 68, 68);"/>
  </g>
  <g transform="translate(0, 0)">
    <g>
      <path class="st3" d="M329.8,562.1h-15.3l-3.1-18.5c-0.6-3.9-4.3-6.5-8.2-5.9l-15.9,4.1c-0.6,0.2-1.2,0.5-1.6,1l-8.1,10.2 c-1.1,1.3-0.8,3.2,0.5,4.3c1.3,1.1,3.2,0.8,4.3-0.5l7.5-9.4l7.4-1.9l3.1,18.7c0.6,3.4,3.5,6,7,5.9h18.3l0.6,11.2h6.9l0.7-15.2 C333.8,563.9,332,562.1,329.8,562.1z" style="fill: rgb(90, 122, 132);"/>
    </g>
    <g>
      <path class="st2" d="M299.3,590.5c-10.1,0-18.3-8.2-18.3-18.3c0-10.1,8.2-18.3,18.3-18.3c10.1,0,18.3,8.2,18.3,18.3 C317.6,582.3,309.4,590.5,299.3,590.5z" style="fill: rgb(68, 68, 68);"/>
    </g>
    <g>
      <circle class="st4" cx="299.3" cy="572.2" r="14.2" style="fill: rgb(230, 230, 230);"/>
    </g>
    <g>
      <circle class="st2" cx="329.8" cy="586.5" r="4.1" style="fill: rgb(68, 68, 68);"/>
    </g>
    <g>
      <circle class="st3" cx="303.3" cy="525.5" r="8.1" style="fill: rgb(90, 122, 132);"/>
    </g>
    <g>
      <circle class="st2" cx="299.3" cy="572.2" r="4.1" style="fill: rgb(68, 68, 68);"/>
    </g>
  </g>
</g>
<g transform="matrix(2.080746, 0, 0, 2.080746, -1405.798828, -2575.989258)">
  <title>Ledsagare</title>
  <g>
    <g>
      <circle class="st1" cx="193.4" cy="554.4" r="50.4" style="fill: rgb(255, 255, 255);"/>
      <path class="st2" d="M193.4,606.9c-28.9,0-52.5-23.5-52.5-52.5s23.5-52.5,52.5-52.5s52.5,23.5,52.5,52.5S222.3,606.9,193.4,606.9 z M193.4,506.1c-26.6,0-48.3,21.7-48.3,48.3c0,26.6,21.7,48.3,48.3,48.3c26.6,0,48.3-21.7,48.3-48.3 C241.7,527.8,220,506.1,193.4,506.1z" style="fill: rgb(68, 68, 68);"/>
    </g>
  </g>
  <g transform="translate(0, 0)">
    <g>
      <circle class="st3" cx="192.7" cy="531.7" r="9.8" style="fill: rgb(90, 122, 132);"/>
    </g>
    <g>
      <path class="st3" d="M219.2,555.1l-11.2-9.8c-0.8-0.7-1.7-1-2.8-1h-25.2c-1,0-2,0.4-2.8,1l-11.2,9.8c-1.5,1.3-1.9,3.5-0.9,5.2 l5.8,10.2c1,1.8,3.2,2.4,5,1.4c1.7-0.9,2.4-3,1.6-4.7l-3.5-8.1l5.8-5.1v30.8c0,0.8,0.6,1.4,1.4,1.4h22.4c0.8,0,1.4-0.6,1.4-1.4 v-30.8l5.8,5.1l-3.5,8.1c-0.8,1.9,0,4.1,1.9,4.9c1.7,0.8,3.8,0.1,4.7-1.6l5.8-10.2C221.1,558.6,220.7,556.4,219.2,555.1z" style="fill: rgb(90, 122, 132);"/>
    </g>
    <g>
      <path class="st8" d="M198.3,544.3l-5.6,7.5l-5.6-7.5h-3.5l8,10.6c0.5,0.6,1.3,0.7,2,0.3c0.1-0.1,0.2-0.2,0.3-0.3l8-10.6H198.3z" style="fill: rgb(179, 179, 179);"/>
    </g>
    <g>
      <path class="st20" d="M187.3,564.8l1-11.7c0.1-1.1,1-1.9,2.1-1.8l5.8,0.5c1.1,0.1,1.9,1,1.8,2.1l-1,11.7c-0.1,1.1-1,1.9-2.1,1.8 l-5.8-0.5C188,566.8,187.2,565.9,187.3,564.8z" style="fill: rgb(200, 233, 236);"/>
    </g>
  </g>
</g>
<g transform="matrix(2.080746, 0, 0, 2.080746, -1405.798828, -2575.989258)">
  <title>Toalett</title>
  <g>
    <g>
      <circle class="st1" cx="420.4" cy="554.5" r="50.4" style="fill: rgb(255, 255, 255);"/>
      <path class="st2" d="M420.4,607c-28.9,0-52.5-23.5-52.5-52.5s23.5-52.5,52.5-52.5s52.5,23.5,52.5,52.5S449.3,607,420.4,607z M420.4,506.2c-26.6,0-48.3,21.7-48.3,48.3c0,26.6,21.7,48.3,48.3,48.3c26.6,0,48.3-21.7,48.3-48.3 C468.7,527.9,447,506.2,420.4,506.2z" style="fill: rgb(68, 68, 68);"/>
    </g>
  </g>
  <g transform="translate(0, 0)">
    <g>
      <path class="st7" d="M443,583.7h-8.2c-0.7,0-1.3-0.5-1.4-1.2l-1.2-11.1h-7c-0.8,0-1.4-0.6-1.4-1.4c0-0.1,0-0.3,0.1-0.4l6.3-21.3 c0.5-1.7,2.1-2.9,3.9-2.9h9.6c1.8,0,3.4,1.2,3.9,2.9l6.3,21.3c0.2,0.7-0.2,1.5-0.9,1.7c-0.1,0-0.3,0.1-0.4,0.1h-7l-1.2,11.1 C444.3,583.1,443.7,583.7,443,583.7z" style="fill: rgb(51, 82, 98);"/>
    </g>
    <g>
      <path class="st3" d="M402.1,541.3c-3.8,0-6.8-3.1-6.8-6.8c0-3.8,3.1-6.8,6.8-6.8s6.8,3.1,6.8,6.8 C408.9,538.3,405.8,541.3,402.1,541.3z" style="fill: rgb(90, 122, 132);"/>
    </g>
    <g>
      <path class="st7" d="M406.2,583.7H398c-0.7,0-1.3-0.5-1.4-1.2l-1.3-12.7l-4.5-1.1c-0.6-0.2-1-0.7-1-1.3v-15 c0-3.8,3.1-6.8,6.8-6.8h10.9c3.8,0,6.8,3.1,6.8,6.8v15c0,0.6-0.4,1.2-1,1.3l-4.5,1.1l-1.3,12.7 C407.5,583.1,406.9,583.7,406.2,583.7z" style="fill: rgb(51, 82, 98);"/>
    </g>
    <g>
      <circle class="st3" cx="438.9" cy="534.5" r="6.8" style="fill: rgb(90, 122, 132);"/>
    </g>
    <g>
      <path class="st8" d="M419.8,526.3L419.8,526.3c0.8,0,1.4,0.6,1.4,1.4v54.6c0,0.8-0.6,1.4-1.4,1.4l0,0c-0.8,0-1.4-0.6-1.4-1.4 v-54.6C418.5,526.9,419.1,526.3,419.8,526.3z" style="fill: rgb(179, 179, 179);"/>
    </g>
  </g>
</g>
<g transform="matrix(1.360732, 0, 0, 1.360732, 68.891167, -1910.654541)" style="">
  <title>Entrance</title>
  <g transform="translate(0 -552.36)">
    <g transform="matrix(1.1974 0 0 1.1974 -95.185 -154.13)">
      <g transform="matrix(0 -.55235 .55235 0 99.37 938.33)">
        <g transform="translate(0 -552.36)">
          <path d="M 233.02 587.81 C 224.71 587.81 218.02 594.5 218.02 602.81 L 218.02 903.37 L 145.363 830.687 C 142.426 827.749 138.604 826.281 134.769 826.281 C 130.935 826.281 127.113 827.749 124.175 830.687 L 100.175 854.687 C 94.299 860.563 94.299 870.03 100.175 875.906 L 200.675 976.406 L 216.769 992.531 C 216.8 992.562 216.832 992.593 216.863 992.625 C 216.894 992.656 216.925 992.688 216.956 992.719 L 233.456 1009.22 C 233.456 1009.22 241.037 1016.92 249.987 1016.92 C 258.859 1016.92 266.581 1009.13 266.581 1009.13 L 283.206 992.531 L 399.826 875.911 C 405.703 870.035 405.703 860.568 399.826 854.692 L 375.826 830.692 C 369.95 824.816 360.515 824.816 354.638 830.692 L 281.955 903.375 L 281.955 602.815 C 281.955 594.505 275.265 587.815 266.955 587.815 L 233.02 587.81 Z" style="transform-box: fill-box; transform-origin: 50% 50%;" transform="matrix(-1, 0, 0, -1, -0.000098, -0.000157)"/>
        </g>
      </g>
      <path transform="translate(0 552.36)" d="m283.19 87.562c-15.264 0-27.531 12.298-27.531 27.562v7.75h152.56c7.8141 0 14.094 6.3109 14.094 14.125v218.94c0 7.8141-6.2796 14.125-14.094 14.125h-152.56v7.75c0 15.264 12.267 27.562 27.531 27.562h146.88c15.264 0 27.562-12.298 27.562-27.562v-262.69c0-15.264-12.298-27.562-27.562-27.562h-146.88z" color="#000000"/>
    </g>
  </g>
</g>
<g>
  <title>Stairs</title>
  <path style="fill: rgb(216, 216, 216); stroke-width: 250px; stroke-dasharray: 60; stroke: rgb(198, 198, 198);" d="M 1205.65 -3338.7 L 1205.65 -1311.5"/>
</g>
`;

  function buildSvgSectionOutlines(sectionOrder, outlineBySection, supportMarkup = "") {
    const lines = [
      "      <g id=\"background-graphics-section-graphics-always-visible\" class=\"section-graphics-always-visible\">",
      "        <title>background-graphics-section-graphics-always-visible</title>"
    ];
    sectionOrder.forEach((sectionId) => {
      const sectionCode = sectionIdToOutlineCode(sectionId);
      const outline = outlineBySection.get(sectionId);
      if (!outline || !outline.coords || !outline.coords.length) return;
      const coords = outline.coords.map(c => ({ x: Math.round(c.x), y: Math.round(c.y) }));
      const path = coords.map((c, idx) => `${idx === 0 ? "M" : "L"}${c.x},${c.y}`).join("");
      lines.push(`        <g class="section-always-visible section-${sectionCode}" style="visibility: hidden;">`);
      lines.push(`          <title>section-always-visible section-${sectionCode}</title>`);
      lines.push(`          <path d="${path}" class="always-visible-section-outline"/>`);
      lines.push("        </g>");
    });
    if (supportMarkup) {
      lines.push(indentSvgMarkup(supportMarkup, 8));
    }
    lines.push("      </g>");
    return lines.join("\n");
  }

  function buildSvgRowNumberMarkup(sectionOrder, rowsBySection) {
    const lines = [
      "      <g id=\"background-graphics-visible-when-section-open\" class=\"section-graphics-visible-when-open\">",
      "        <title>background-graphics-visible-when-section-open</title>"
    ];

    sectionOrder.forEach((sectionId) => {
      const sectionCode = sectionIdToOutlineCode(sectionId);
      lines.push(`        <g class="section-visible-when-open section-${sectionCode}">`);
      lines.push(`          <title>section-visible-when-open section-${sectionCode}</title>`);

      const beginLines = [];
      const endLines = [];
      const rows = rowsBySection.get(sectionId) || [];
      rows.forEach((row) => {
        if (!row.seats || !row.seats.length) return;
        const rowLabel = row.name || (row.rowId ? String(row.rowId).split(".")[2] : "");
        if (!rowLabel) return;
        const step = computeRowStep(row.seats);
        const first = row.seats[0];
        const last = row.seats[row.seats.length - 1];
        const startX = Math.round(first.centerX - step.dx);
        const startY = Math.round(first.centerY - step.dy);
        const endX = Math.round(last.centerX + step.dx);
        const endY = Math.round(last.centerY + step.dy);
        const label = escapeXml(rowLabel);
        beginLines.push(`            <text data-name="${label}" x="${startX}" y="${startY}" text-anchor="middle" dominant-baseline="middle" style="white-space: pre;">${label}</text>`);
        endLines.push(`            <text data-name="${label}" x="${endX}" y="${endY}" text-anchor="middle" dominant-baseline="middle" style="white-space: pre;">${label}</text>`);
      });

      lines.push("          <g class=\"row-number-text beginning-of-row\">");
      lines.push("            <title>row-number-text beginning-of-row</title>");
      lines.push(...beginLines);
      lines.push("          </g>");
      lines.push("          <g class=\"row-number-text end-of-row\">");
      lines.push("            <title>row-number-text end-of-row</title>");
      lines.push(...endLines);
      lines.push("          </g>");
      lines.push("        </g>");
    });

    lines.push("      </g>");
    return lines.join("\n");
  }

  function buildSvgFrontgroundMarkup(sectionOrder, outlineBySection, rowsBySection) {
    const lines = [
      "    <g id=\"frontground-graphics\" class=\"graphics\">",
      "      <title>frontground-graphics</title>",
      "      <g id=\"frontground-graphics-visible-when-section-not-open\" class=\"section-graphics-visible-when-not-open\">",
      "        <title>frontground-graphics-visible-when-section-not-open</title>"
    ];

    sectionOrder.forEach((sectionId) => {
      const sectionCode = sectionIdToOutlineCode(sectionId);
      const sectionName = sectionNames.get(sectionId) || "";
      if (!sectionName) return;
      const bounds = computeSectionBounds(sectionId, outlineBySection, rowsBySection);
      if (!bounds) return;
      const centerX = (bounds.minX + bounds.maxX) / 2;
      const centerY = (bounds.minY + bounds.maxY) / 2;
      const text = sectionName;
      const width = Math.max(1000, text.length * 200);
      const height = 500;
      const radius = height / 2;
      const yOffset = height / 38;
      const rectX = centerX - width / 2;
      const rectY = centerY - height / 2 - yOffset;

      lines.push(`        <g class="section-visible-when-not-open section-${sectionCode}">`);
      lines.push(`          <title>section-visible-when-not-open section-${sectionCode}</title>`);
      lines.push("          <g>");
      lines.push(`            <rect class="section-text-box" x="${formatSvgNumber(rectX)}" y="${formatSvgNumber(rectY)}" width="${formatSvgNumber(width)}" height="${formatSvgNumber(height)}" rx="${formatSvgNumber(radius)}" ry="${formatSvgNumber(radius)}"/>`);
      lines.push(`            <text class="section-text" x="${formatSvgNumber(centerX)}" y="${formatSvgNumber(centerY)}" text-anchor="middle" dominant-baseline="middle" style="white-space: pre;">${escapeXml(text)}</text>`);
      lines.push("          </g>");
      lines.push("        </g>");
    });

    lines.push("      </g>");
    lines.push("      <g id=\"extra-graphics\">");
    lines.push("        <title>extra-graphics</title>");
    lines.push("      </g>");
    lines.push("    </g>");
    return lines.join("\n");
  }

  function buildSvgHexPoints(cx, cy, radius) {
    const points = [];
    for (let i = 0; i < 6; i++) {
      const angle = (Math.PI / 3) * i - Math.PI / 3;
      const px = Math.round(cx + Math.cos(angle) * radius);
      const py = Math.round(cy + Math.sin(angle) * radius);
      points.push(`${px}, ${py}`);
    }
    return points.join(" ");
  }

  function buildSvgSectionsMarkup(sectionOrder, rowsBySection, outlineBySection, priceRegionLookups) {
    const lines = [
      "    <g id=\"sections\">",
      "      <title>sections</title>"
    ];

    sectionOrder.forEach((sectionId) => {
      const sectionCode = sectionIdToOutlineCode(sectionId);
      const sectionName = sectionNames.get(sectionId) || "";
      const parts = parseSectionIdParts(sectionId);
      const dataId = parts.major != null ? String(parts.major) : String(sectionId || "");

      const bounds = computeSectionBounds(sectionId, outlineBySection, rowsBySection);
      const hasBounds = !!bounds;
      const minXr = hasBounds ? bounds.minX : 0;
      const minYr = hasBounds ? bounds.minY : 0;
      const width = hasBounds ? Math.round(bounds.maxX - bounds.minX) : 0;
      const height = hasBounds ? Math.round(bounds.maxY - bounds.minY) : 0;
      const bboxAttr = hasBounds ? ` data-bounding-box="${minXr} ${minYr} ${width} ${height};"` : "";

      lines.push(`      <g id="section-${sectionCode}" class="section" data-name="${escapeXml(sectionName)}" data-id="${escapeXml(dataId)}"${bboxAttr}>`);
      lines.push(`        <title>section-${sectionCode}</title>`);
      lines.push(`        <g id="rows-${sectionCode}" class="rows">`);
      lines.push(`          <title>rows-${sectionCode}</title>`);

      const rows = rowsBySection.get(sectionId) || [];
      rows.forEach((row) => {
        const rowCode = rowIdToSvgCode(row.rowId);
        const rowName = row.name || (row.rowId ? String(row.rowId).split(".")[2] : "");
        lines.push(`          <g id="row-${rowCode}" class="row" data-name="${escapeXml(rowName)}">`);
        lines.push(`            <title>row-${rowCode}</title>`);

        const attributeSeats = [];
        row.seats.forEach((seat) => {
          const seatCode = seatIdToSvgCode(seat.seatId);
          const cx = Math.round(seat.centerX);
          const cy = Math.round(seat.centerY);
          const r = Math.round((Number.isFinite(seat.width) ? seat.width : 100) / 2);
          const regionId = getSeatPriceRegionRangeId(seat, priceRegionLookups);
          const classParts = ["seat"];
          if (regionId) classParts.push(`pr-${regionId}`);
          const className = classParts.join(" ");

          let dataAttributes = "";
          if (Array.isArray(seat.attributes) && seat.attributes.length) {
            const translated = seat.attributes
              .filter(attr => attr && !String(attr).startsWith("."))
              .map((attr) => {
                const key = String(attr);
                const label = ATTRIBUTE_TRANSLATIONS[key] || key;
                return label ? label.toLocaleLowerCase("sv-SE") : "";
              })
              .filter(Boolean);
            if (translated.length) {
              dataAttributes = translated.join(", ");
              attributeSeats.push({ cx, cy, r, seatCode });
            }
          }

          const attrs = [
            `id="${seatCode}"`,
            `cx="${cx}"`,
            `cy="${cy}"`,
            `r="${r}"`,
            `class="${className}"`,
            `data-name="${escapeXml(seat.name)}"`
          ];
          if (dataAttributes) {
            attrs.push(`data-attributes="${escapeXml(dataAttributes)}"`);
          }
          lines.push(`            <circle ${attrs.join(" ")}/>`);
        });

        if (attributeSeats.length) {
          lines.push("            <g>");
          attributeSeats.forEach((marker) => {
            const hexRadius = Math.round(marker.r * 0.5);
            const points = buildSvgHexPoints(marker.cx, marker.cy, hexRadius);
            lines.push(`              <polygon points="${points}" class="seat-attribute" data-id="${marker.seatCode}"/>`);
          });
          lines.push("            </g>");
        }

        lines.push("          </g>");
      });

      lines.push("        </g>");
      lines.push("      </g>");
    });

    lines.push("    </g>");
    return lines.join("\n");
  }

  function replaceSvgGroupById(svgText, groupId, newGroupText) {
    if (!svgText || !groupId) return { text: svgText, replaced: false };
    const startRegex = new RegExp(`<g\\b[^>]*\\bid="${groupId}"[^>]*>`, "i");
    const match = startRegex.exec(svgText);
    if (!match) return { text: svgText, replaced: false };
    const startIndex = match.index;
    const openEnd = startIndex + match[0].length;
    const tagRegex = /<\/?g\b[^>]*>/gi;
    tagRegex.lastIndex = openEnd;
    let depth = 1;
    let endIndex = -1;
    let tagMatch;
    while ((tagMatch = tagRegex.exec(svgText)) !== null) {
      const token = tagMatch[0];
      if (token.startsWith("</")) {
        depth -= 1;
      } else {
        depth += 1;
      }
      if (depth === 0) {
        endIndex = tagRegex.lastIndex;
        break;
      }
    }
    if (endIndex === -1) return { text: svgText, replaced: false };
    const next = svgText.slice(0, startIndex) + newGroupText + svgText.slice(endIndex);
    return { text: next, replaced: true };
  }

  function replaceSvgStyle(svgText, newCss) {
    if (!svgText) return { text: svgText, replaced: false };
    const styleRegex = /<style\b[^>]*>[\s\S]*?<\/style>/i;
    const match = styleRegex.exec(svgText);
    if (!match) return { text: svgText, replaced: false };
    const openTagMatch = match[0].match(/<style\b[^>]*>/i);
    const openTag = openTagMatch ? openTagMatch[0] : "<style type=\"text/css\">";
    const css = (newCss || "").trim();
    const block = `${openTag}\n${css}\n</style>`;
    const next = svgText.slice(0, match.index) + block + svgText.slice(match.index + match[0].length);
    return { text: next, replaced: true };
  }

  function insertSvgStyle(svgText, newCss) {
    const css = (newCss || "").trim();
    if (!svgText || !css) return svgText;
    const svgOpenMatch = svgText.match(/<svg\b[^>]*>/i);
    if (!svgOpenMatch) return svgText;
    const insertAt = svgOpenMatch.index + svgOpenMatch[0].length;
    const block = `\n  <style type="text/css">\n${css}\n  </style>`;
    return svgText.slice(0, insertAt) + block + svgText.slice(insertAt);
  }

  async function loadSvgTemplate(baseName) {
    const baseHandle = lastDirectoryHandle || currentFileHandle;
    const dirHandle = await tryGetDirectoryHandle(baseHandle);
    if (!dirHandle || typeof dirHandle.getFileHandle !== "function") return null;
    const candidates = [];
    if (baseName) candidates.push(`${baseName}.svg`);
    const fallbackBase = currentFileName ? currentFileName.replace(/\.[^/.]+$/, "") : "";
    if (fallbackBase && fallbackBase !== baseName) candidates.push(`${fallbackBase}.svg`);
    for (const name of candidates) {
      try {
        const handle = await dirHandle.getFileHandle(name);
        const file = await handle.getFile();
        return await file.text();
      } catch (err) {
        if (err?.name !== "NotFoundError") {
          console.warn("Kunde inte läsa SVG-mall:", err);
          return null;
        }
      }
    }
    return null;
  }

  function buildSvgSkeleton(viewBox, cssText, supportBackgroundMarkup, outlineMarkup, rowNumberMarkup, sectionsMarkup, frontgroundMarkup) {
    const lines = [
      "<?xml version=\"1.0\" encoding=\"utf-8\"?>",
      `<svg id="venue" version="1.1" baseProfile="full" preserveAspectRatio="xMidYMid meet" viewBox="${viewBox}" xmlns="http://www.w3.org/2000/svg">`,
      "  <defs>",
      "    <filter id=\"gaussian-blur-filter-0\" color-interpolation-filters=\"sRGB\" x=\"-50%\" y=\"-50%\" width=\"200%\" height=\"200%\">",
      "      <feGaussianBlur stdDeviation=\"50 50\" edgeMode=\"none\"/>",
      "    </filter>",
      "  </defs>",
      "  <style type=\"text/css\">",
      cssText || "",
      "  </style>",
      "  <g id=\"viewport\">",
      "    <title>viewport</title>",
      "    <g id=\"background-graphics\" class=\"graphics\">",
      "      <title>background-graphics</title>",
      supportBackgroundMarkup ? indentSvgMarkup(supportBackgroundMarkup, 6) : "",
      outlineMarkup || "",
      "      <g id=\"helper-graphics\">",
      "        <title>helper-graphics</title>",
      "      </g>",
      rowNumberMarkup || "",
      "    </g>",
      sectionsMarkup || "",
      frontgroundMarkup || "",
      "  </g>",
      "</svg>"
    ];
    return lines.filter(Boolean).join("\n");
  }

  function computeSvgViewBox(outlineBySection, rowsBySection) {
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;

    outlineBySection.forEach((outline) => {
      if (!outline || !outline.coords) return;
      outline.coords.forEach((c) => {
        minX = Math.min(minX, c.x);
        maxX = Math.max(maxX, c.x);
        minY = Math.min(minY, c.y);
        maxY = Math.max(maxY, c.y);
      });
    });

    if (!Number.isFinite(minX)) {
      rowsBySection.forEach((rows) => {
        rows.forEach((row) => {
          row.seats.forEach((seat) => {
            minX = Math.min(minX, seat.centerX);
            maxX = Math.max(maxX, seat.centerX);
            minY = Math.min(minY, seat.centerY);
            maxY = Math.max(maxY, seat.centerY);
          });
        });
      });
    }

    if (!Number.isFinite(minX) || !Number.isFinite(minY)) {
      return "0 0 1200 800";
    }

    const spanX = maxX - minX;
    const spanY = maxY - minY;
    const dominantSpan = Math.max(spanX, spanY, 1);
    // Adaptive export margin: always at least a bit larger than before, and scales with layout size.
    const padding = Math.max(260, Math.round(dominantSpan * 0.06));
    const minXr = Math.round(minX - padding);
    const minYr = Math.round(minY - padding);
    const width = Math.round((maxX - minX) + padding * 2);
    const height = Math.round((maxY - minY) + padding * 2);
    return `${minXr} ${minYr} ${width} ${height}`;
  }

  function buildPriceRegionLookupsForSvg() {
    return priceRegions.map((region, idx) => ({
      rangeId: buildRangeId(region, idx),
      sections: new Set(region.sections),
      rows: new Set(region.rows),
      seats: new Set(region.seats)
    }));
  }

  function getSeatPriceRegionRangeId(seat, lookups) {
    for (const region of lookups) {
      if (region.sections.has(seat.sectionId)) return region.rangeId;
      if (region.rows.has(seat.rowId)) return region.rangeId;
      if (region.seats.has(seat.seatId)) return region.rangeId;
    }
    return null;
  }

  async function buildSvgText(baseName, options = {}) {
    const includeSupportGraphics = !!options.includeSupportGraphics;
    if (!seats.length) {
      return [
        "<?xml version=\"1.0\" encoding=\"utf-8\"?>",
        "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"1200\" height=\"800\">",
        "  <rect width=\"100%\" height=\"100%\" fill=\"#f3f6f9\" />",
        "  <text x=\"50%\" y=\"50%\" text-anchor=\"middle\" fill=\"#7b8794\" font-size=\"20\" font-family=\"Arial, sans-serif\">",
        "    SVG-export kräver en layout",
        "  </text>",
        "</svg>"
      ].join("\n");
    }

    const outlineBySection = new Map();
    outlines.forEach((outline) => {
      if (outline && outline.sectionId) outlineBySection.set(outline.sectionId, outline);
    });

    const rowsBySection = new Map();
    seats.forEach((seat) => {
      if (!seat.sectionId || !seat.rowId) return;
      if (!rowsBySection.has(seat.sectionId)) rowsBySection.set(seat.sectionId, new Map());
      const rows = rowsBySection.get(seat.sectionId);
      if (!rows.has(seat.rowId)) {
        rows.set(seat.rowId, {
          rowId: seat.rowId,
          name: seat.rowName || "",
          seats: []
        });
      }
      rows.get(seat.rowId).seats.push(seat);
    });

    const sectionOrder = Array.from(rowsBySection.keys()).sort((a, b) => {
      const pa = parseSectionIdParts(a);
      const pb = parseSectionIdParts(b);
      if (pa.major != null && pb.major != null && pa.major !== pb.major) return pa.major - pb.major;
      if (pa.minor != null && pb.minor != null && pa.minor !== pb.minor) return pa.minor - pb.minor;
      return String(a).localeCompare(String(b), "sv");
    });

    const normalizedRowsBySection = new Map();
    sectionOrder.forEach((sectionId) => {
      const rowMap = rowsBySection.get(sectionId);
      if (!rowMap) return;
      const rows = Array.from(rowMap.values());
      rows.forEach((row) => {
        row.seats.sort((a, b) => {
          const pa = parseSeatIdParts(a.seatId);
          const pb = parseSeatIdParts(b.seatId);
          if (pa.seat != null && pb.seat != null && pa.seat !== pb.seat) return pa.seat - pb.seat;
          return String(a.seatId).localeCompare(String(b.seatId), "sv");
        });
      });
      rows.sort((a, b) => {
        const pa = parseRowIdParts(a.rowId);
        const pb = parseRowIdParts(b.rowId);
        if (pa.row != null && pb.row != null && pa.row !== pb.row) return pa.row - pb.row;
        return String(a.rowId).localeCompare(String(b.rowId), "sv");
      });
      normalizedRowsBySection.set(sectionId, rows);
    });

    const supportBackgroundMarkup = includeSupportGraphics ? SVG_SUPPORT_BACKGROUND_MARKUP : "";
    const supportAlwaysVisibleMarkup = includeSupportGraphics ? SVG_SUPPORT_ALWAYS_VISIBLE_MARKUP : "";
    const priceRegionLookups = buildPriceRegionLookupsForSvg();
    const outlineMarkup = buildSvgSectionOutlines(sectionOrder, outlineBySection, supportAlwaysVisibleMarkup);
    const rowNumberMarkup = buildSvgRowNumberMarkup(sectionOrder, normalizedRowsBySection);
    const sectionsMarkup = buildSvgSectionsMarkup(sectionOrder, normalizedRowsBySection, outlineBySection, priceRegionLookups);
    const frontgroundMarkup = buildSvgFrontgroundMarkup(sectionOrder, outlineBySection, normalizedRowsBySection);
    const cssText = buildSvgCssText();

    const viewBox = computeSvgViewBox(outlineBySection, normalizedRowsBySection);
    return buildSvgSkeleton(viewBox, cssText, supportBackgroundMarkup, outlineMarkup, rowNumberMarkup, sectionsMarkup, frontgroundMarkup);
  }

  function downloadTextFile(filename, text) {
    const blob = new Blob([text], { type: "text/plain" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  async function exportFiles() {
    const baseName = getExportBaseName();
    const metaVenueId = getLayoutMeta().venueId || "";
    const venueId = (exportVenueId?.value || "").trim() || metaVenueId;
    const files = [];
    if (exportTlc?.checked) files.push({ name: `${baseName}.tlc`, text: buildTlcText(baseName, venueId) });
    if (exportTlt?.checked) files.push({ name: `${baseName}.tlt`, text: stripEmptyLines(updateTltVenueId(codePane.value || "", venueId)) });
    if (exportTpr?.checked) files.push({ name: `${baseName}.tpr`, text: stripEmptyLines(buildTprText(baseName, venueId)) });
    if (exportCss?.checked) files.push({ name: `${baseName}.css`, text: buildCssText() });
    if (exportSvg?.checked) {
      files.push({
        name: `${baseName}.svg`,
        text: await buildSvgText(baseName, { includeSupportGraphics: !!exportSvgSupport?.checked })
      });
    }

    if (!files.length) {
      alert("Select at least one file to export.");
      return;
    }

    if (typeof window.showDirectoryPicker === "function") {
      try {
        const dir = await window.showDirectoryPicker();
        for (const file of files) {
          const handle = await dir.getFileHandle(file.name, { create: true });
          const writable = await handle.createWritable();
          await writable.write(file.text);
          await writable.close();
        }
        return;
      } catch (err) {
        if (err?.name === "AbortError") return;
        console.warn("Export via mappval misslyckades, fallback till nedladdning:", err);
      }
    }

    files.forEach((file) => downloadTextFile(file.name, file.text));
  }

  function buildPriceRegionTargetsFromSelection() {
    const selected = getSelectedSeats();
    if (!selected.length) return { sections: [], rows: [], seats: [] };

    const selectedIds = new Set(selected.map(s => s.seatId));
    const seatsBySection = new Map();
    const seatsByRow = new Map();
    for (const s of seats) {
      if (s.sectionId) {
        if (!seatsBySection.has(s.sectionId)) seatsBySection.set(s.sectionId, []);
        seatsBySection.get(s.sectionId).push(s);
      }
      if (s.rowId) {
        if (!seatsByRow.has(s.rowId)) seatsByRow.set(s.rowId, []);
        seatsByRow.get(s.rowId).push(s);
      }
    }

    const covered = new Set();
    const sections = [];
    const rows = [];
    const seatsOut = [];

    for (const [sectionId, sectionSeats] of seatsBySection) {
      let anySelected = false;
      let allSelected = true;
      for (const s of sectionSeats) {
        const isSelected = selectedIds.has(s.seatId);
        if (isSelected) anySelected = true;
        if (!isSelected) allSelected = false;
      }
      if (anySelected && allSelected) {
        sections.push(sectionId);
        sectionSeats.forEach(s => covered.add(s.seatId));
      }
    }

    for (const [rowId, rowSeats] of seatsByRow) {
      let anySelected = false;
      let allSelected = true;
      for (const s of rowSeats) {
        const isSelected = selectedIds.has(s.seatId);
        if (isSelected) anySelected = true;
        if (!isSelected) allSelected = false;
      }
      if (!anySelected || !allSelected) continue;
      const alreadyCovered = rowSeats.every(s => covered.has(s.seatId));
      if (alreadyCovered) continue;
      rows.push(rowId);
      rowSeats.forEach(s => covered.add(s.seatId));
    }

    for (const s of selected) {
      if (!covered.has(s.seatId)) seatsOut.push(s.seatId);
    }

    return {
      sections: sections.sort(),
      rows: rows.sort(),
      seats: seatsOut.sort()
    };
  }

  function buildPriceRegionTargetsFromSeatSet(seatSet) {
    if (!seatSet || seatSet.size === 0) return { sections: [], rows: [], seats: [] };

    const seatsBySection = new Map();
    const seatsByRow = new Map();
    for (const s of seats) {
      if (s.sectionId) {
        if (!seatsBySection.has(s.sectionId)) seatsBySection.set(s.sectionId, []);
        seatsBySection.get(s.sectionId).push(s);
      }
      if (s.rowId) {
        if (!seatsByRow.has(s.rowId)) seatsByRow.set(s.rowId, []);
        seatsByRow.get(s.rowId).push(s);
      }
    }

    const covered = new Set();
    const sections = [];
    const rows = [];
    const seatsOut = [];

    for (const [sectionId, sectionSeats] of seatsBySection) {
      let anySelected = false;
      let allSelected = true;
      for (const s of sectionSeats) {
        const isSelected = seatSet.has(s.seatId);
        if (isSelected) anySelected = true;
        if (!isSelected) allSelected = false;
      }
      if (anySelected && allSelected) {
        sections.push(sectionId);
        sectionSeats.forEach(s => covered.add(s.seatId));
      }
    }

    for (const [rowId, rowSeats] of seatsByRow) {
      let anySelected = false;
      let allSelected = true;
      for (const s of rowSeats) {
        const isSelected = seatSet.has(s.seatId);
        if (isSelected) anySelected = true;
        if (!isSelected) allSelected = false;
      }
      if (!anySelected || !allSelected) continue;
      const alreadyCovered = rowSeats.every(s => covered.has(s.seatId));
      if (alreadyCovered) continue;
      rows.push(rowId);
      rowSeats.forEach(s => covered.add(s.seatId));
    }

    seatSet.forEach((seatId) => {
      if (!covered.has(seatId)) seatsOut.push(seatId);
    });

    return {
      sections: sections.sort(),
      rows: rows.sort(),
      seats: seatsOut.sort()
    };
  }

  function rebuildPriceRegionFromSeatSet(region, seatSet) {
    const targets = buildPriceRegionTargetsFromSeatSet(seatSet);
    region.sections = targets.sections;
    region.rows = targets.rows;
    region.seats = targets.seats;
  }

  function removeSeatsFromOtherPriceRegions(regionId, seatIds) {
    if (!seatIds || seatIds.size === 0) return false;
    let changed = false;
    priceRegions.forEach((region) => {
      if (region.id === regionId) return;
      const currentSeatIds = getRegionSeatIds(region);
      let removedAny = false;
      const nextSeatIds = new Set();
      currentSeatIds.forEach((seatId) => {
        if (seatIds.has(seatId)) {
          removedAny = true;
        } else {
          nextSeatIds.add(seatId);
        }
      });
      if (!removedAny) return;
      rebuildPriceRegionFromSeatSet(region, nextSeatIds);
      changed = true;
    });
    return changed;
  }

  function normalizePriceRegionTargets(region) {
    const seatById = new Map(seats.map(s => [s.seatId, s]));
    const sectionsSet = new Set(region.sections);
    let rowsSet = new Set(region.rows);
    region.rows = region.rows.filter((rowId) => {
      const parts = String(rowId).split(".");
      const sectionId = parts.length >= 2 ? `${parts[0]}.${parts[1]}` : "";
      if (sectionId && sectionsSet.has(sectionId)) {
        rowsSet.delete(rowId);
        return false;
      }
      return true;
    });
    rowsSet = new Set(region.rows);
    region.seats = region.seats.filter((seatId) => {
      const seat = seatById.get(seatId);
      if (!seat) return true;
      if (sectionsSet.has(seat.sectionId)) return false;
      if (rowsSet.has(seat.rowId)) return false;
      return true;
    });
  }

  function getPriceRegionSeatCount(region) {
    const sectionsSet = new Set(region.sections);
    const rowsSet = new Set(region.rows);
    const seatsSet = new Set(region.seats);
    const covered = new Set();
    let count = 0;

    for (const s of seats) {
      if (sectionsSet.has(s.sectionId)) {
        covered.add(s.seatId);
        count += 1;
      }
    }

    for (const s of seats) {
      if (covered.has(s.seatId)) continue;
      if (rowsSet.has(s.rowId)) {
        covered.add(s.seatId);
        count += 1;
      }
    }

    for (const seatId of seatsSet) {
      if (covered.has(seatId)) continue;
      if (seats.some(s => s.seatId === seatId)) {
        covered.add(seatId);
        count += 1;
      }
    }

    return count;
  }

  function buildPriceRegionLookups() {
    return priceRegions.map(region => ({
      id: region.id,
      name: region.name,
      color: region.color,
      sections: new Set(region.sections),
      rows: new Set(region.rows),
      seats: new Set(region.seats)
    }));
  }

  function getSeatPriceRegionColor(seat, lookups) {
    for (const region of lookups) {
      if (region.sections.has(seat.sectionId)) return region.color;
      if (region.rows.has(seat.rowId)) return region.color;
      if (region.seats.has(seat.seatId)) return region.color;
    }
    return null;
  }

  function getSeatPriceRegionName(seat, lookups) {
    for (const region of lookups) {
      if (region.sections.has(seat.sectionId)) return region.name;
      if (region.rows.has(seat.rowId)) return region.name;
      if (region.seats.has(seat.seatId)) return region.name;
    }
    return null;
  }

  function drawHexMarker(ctx, x, y, r, strokeWidth) {
    ctx.beginPath();
    for (let i = 0; i < 6; i++) {
      const a = (Math.PI / 3) * i - Math.PI / 2;
      const px = x + Math.cos(a) * r;
      const py = y + Math.sin(a) * r;
      if (i === 0) ctx.moveTo(px, py);
      else ctx.lineTo(px, py);
    }
    ctx.closePath();
    ctx.fill();
    if (strokeWidth > 0) {
      ctx.lineWidth = strokeWidth;
      ctx.stroke();
    }
  }

  function getRegionSeatIds(region) {
    const ids = new Set();
    const sectionSet = new Set(region.sections);
    const rowSet = new Set(region.rows);
    for (const s of seats) {
      if (sectionSet.has(s.sectionId) || rowSet.has(s.rowId)) {
        ids.add(s.seatId);
      }
    }
    region.seats.forEach((seatId) => ids.add(seatId));
    return ids;
  }

  function addSelectionToPriceRegion(regionId) {
    const region = priceRegions.find(r => r.id === regionId);
    if (!region) return;
    const targets = buildPriceRegionTargetsFromSelection();
    if (!targets.sections.length && !targets.rows.length && !targets.seats.length) return;
    const selectedSeatIds = new Set(getSelectedSeats().map(s => s.seatId));
    removeSeatsFromOtherPriceRegions(regionId, selectedSeatIds);

    const mergeUnique = (current, incoming) => {
      const set = new Set(current);
      incoming.forEach(item => set.add(item));
      return Array.from(set);
    };

    region.sections = mergeUnique(region.sections, targets.sections);
    region.rows = mergeUnique(region.rows, targets.rows);
    region.seats = mergeUnique(region.seats, targets.seats);
    normalizePriceRegionTargets(region);
    savePriceRegionsToStorage();
    renderPriceRegionList();
    updatePriceRegionUi();
    if (showPriceRegions) renderCanvas();
  }
  function buildEntryPointId() {
    return `ep-${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 6)}`;
  }

  function normalizePriceRegionName(raw) {
    return String(raw || "").trim();
  }

  function normalizePriceRegionKey(raw) {
    return normalizePriceRegionName(raw).toLowerCase();
  }
  function getPriceRegionNameIssues(names, existingKeys = new Set()) {
    const seenKeys = new Set();
    const duplicates = [];
    const tooLong = [];
    names.forEach((name) => {
      if (name.length > PRICE_REGION_NAME_MAX) {
        tooLong.push(name);
      }
      const key = normalizePriceRegionKey(name);
      if (existingKeys.has(key) || seenKeys.has(key)) {
        duplicates.push(name);
      }
      seenKeys.add(key);
    });
    return {
      duplicates: Array.from(new Set(duplicates)),
      tooLong: Array.from(new Set(tooLong))
    };
  }

  function buildPriceRegionIssueMessage(duplicates, tooLong) {
    const messages = [];
    if (duplicates.length) {
      messages.push(`Duplicate price region name(s): ${duplicates.join(", ")}`);
    }
    if (tooLong.length) {
      messages.push(`Name(s) longer than ${PRICE_REGION_NAME_MAX} characters: ${tooLong.join(", ")}`);
    }
    return messages.join("\n");
  }

  function normalizeEntryPointName(raw) {
    return String(raw || "").trim();
  }

  function getEntryPointStorageKey() {
    const meta = getLayoutMeta();
    const venuePart = meta.venueId || "unknown";
    const layoutPart = meta.layoutName || "unsaved";
    return `arenaDesignerEntryPoints:${venuePart}:${layoutPart}`;
  }

  function syncEntryPointsFromSeats() {
    const names = new Set();
    seats.forEach((s) => {
      const name = normalizeEntryPointName(s.entryVia);
      if (name && name !== "-") names.add(name);
    });
    names.forEach((name) => {
      const exists = entryPoints.some(ep => ep.name === name);
      if (!exists) entryPoints.push({ id: buildEntryPointId(), name });
    });
  }

  function loadEntryPointsFromStorage() {
    entryPoints.length = 0;
    try {
      const raw = localStorage.getItem(getEntryPointStorageKey());
      if (raw) {
        const data = JSON.parse(raw);
        if (data && Array.isArray(data.entryPoints)) {
          data.entryPoints.forEach((ep) => {
            const name = normalizeEntryPointName(ep?.name);
            if (name) entryPoints.push({ id: ep.id || buildEntryPointId(), name });
          });
        }
      }
    } catch (err) {
      console.warn("Kunde inte lasa entrepunkter:", err);
    }
    syncEntryPointsFromSeats();
    renderEntryPointList();
    updateEntryPointUi();
  }

  function saveEntryPointsToStorage() {
    try {
      localStorage.setItem(getEntryPointStorageKey(), JSON.stringify({ entryPoints }));
    } catch (err) {
      console.warn("Kunde inte spara entrepunkter:", err);
    }
  }

  function getGoodnessStorageKey() {
    const meta = getLayoutMeta();
    const venuePart = meta.venueId || "unknown";
    const layoutPart = meta.layoutName || "unsaved";
    return `arenaDesignerGoodness:${venuePart}:${layoutPart}`;
  }

  function normalizeGoodnessRangeCount(value) {
    const parsed = parseInt(value, 10);
    if (!Number.isFinite(parsed)) return DEFAULT_GOODNESS_RANGE_COUNT;
    return Math.max(1, Math.min(50, parsed));
  }

  function buildGoodnessRanges(count) {
    const safeCount = normalizeGoodnessRangeCount(count);
    const ranges = [];
    for (let i = 0; i < safeCount; i++) {
      const start = i * GOODNESS_RANGE_SIZE + 1;
      const end = (i + 1) * GOODNESS_RANGE_SIZE;
      ranges.push({ index: i + 1, start, end });
    }
    return ranges;
  }

  function updateGoodnessRangeHint() {
    if (!goodnessRangeHint) return;
    const ranges = buildGoodnessRanges(goodnessRangeCount);
    const labels = ranges.slice(0, 3).map(r => `${r.start}-${r.end}`);
    const suffix = ranges.length > 3 ? ", ..." : "";
    goodnessRangeHint.textContent = `Each range spans ${GOODNESS_RANGE_SIZE} (${labels.join(", ")}${suffix}).`;
  }

  function renderGoodnessRangeOptions() {
    if (!goodnessRangeSelect) return;
    goodnessRangeSelect.innerHTML = "";
    const ranges = buildGoodnessRanges(goodnessRangeCount);
    ranges.forEach((r) => {
      const opt = document.createElement("option");
      opt.value = String(r.index);
      opt.textContent = `Range ${r.index}: ${r.start}-${r.end}`;
      goodnessRangeSelect.appendChild(opt);
    });
  }

  function setGoodnessRangeCount(value, persist = true) {
    goodnessRangeCount = normalizeGoodnessRangeCount(value);
    if (goodnessRangeCountInput) goodnessRangeCountInput.value = String(goodnessRangeCount);
    updateGoodnessRangeHint();
    renderGoodnessRangeOptions();
    if (persist) saveGoodnessSettingsToStorage();
  }

  function loadGoodnessSettingsFromStorage() {
    try {
      const raw = localStorage.getItem(getGoodnessStorageKey());
      if (raw) {
        const data = JSON.parse(raw);
        if (data && data.rangeCount) {
          setGoodnessRangeCount(data.rangeCount, false);
        }
      }
    } catch (err) {
      console.warn("Could not load goodness settings:", err);
    }
    updateGoodnessRangeHint();
  }

  function saveGoodnessSettingsToStorage() {
    try {
      localStorage.setItem(getGoodnessStorageKey(), JSON.stringify({ rangeCount: goodnessRangeCount }));
    } catch (err) {
      console.warn("Could not save goodness settings:", err);
    }
    saveSessionToLocalStorage();
  }

  function getEntryPointSeatIds(entryPoint) {
    const ids = new Set();
    seats.forEach((s) => {
      if (s.entryVia === entryPoint.name) ids.add(s.seatId);
    });
    return ids;
  }

  function renderEntryPointList() {
    if (!entryPointList) return;
    entryPointList.innerHTML = "";
    if (!entryPoints.length) {
      const empty = document.createElement("div");
      empty.className = "u-font--small";
      empty.style.color = "var(--tick-grey)";
      empty.textContent = "No entry points available.";
      entryPointList.appendChild(empty);
      return;
    }
    entryPoints.forEach((entryPoint) => {
      const item = document.createElement("div");
      item.className = "price-region-item";

      const header = document.createElement("div");
      header.className = "price-region-item__header";
      const headerLeft = document.createElement("div");
      headerLeft.className = "price-region-item__header-left";

      const deleteBtn = document.createElement("button");
      deleteBtn.type = "button";
      deleteBtn.className = "price-region-item__delete";
      deleteBtn.textContent = "x";
      deleteBtn.dataset.role = "entry-point-delete";
      deleteBtn.dataset.entryPointId = entryPoint.id;

      const nameInput = document.createElement("input");
      nameInput.type = "text";
      nameInput.className = "price-region-item__name";
      nameInput.value = entryPoint.name || "";
      nameInput.dataset.role = "entry-point-name";
      nameInput.dataset.entryPointId = entryPoint.id;
      nameInput.dataset.prevName = entryPoint.name || "";

      headerLeft.appendChild(nameInput);
      header.appendChild(headerLeft);

      const actions = document.createElement("div");
      actions.className = "price-region-item__actions";
      const addBtn = document.createElement("button");
      addBtn.type = "button";
      addBtn.className = "c-button c-button--ghost c-button--small";
      addBtn.textContent = "Add";
      addBtn.dataset.role = "entry-point-add";
      addBtn.dataset.entryPointId = entryPoint.id;
      const markBtn = document.createElement("button");
      markBtn.type = "button";
      markBtn.className = "c-button c-button--ghost c-button--small";
      markBtn.textContent = "Select";
      markBtn.dataset.role = "entry-point-mark";
      markBtn.dataset.entryPointId = entryPoint.id;
      const clearBtn = document.createElement("button");
      clearBtn.type = "button";
      clearBtn.className = "c-button c-button--ghost c-button--small";
      clearBtn.textContent = "Clear";
      clearBtn.dataset.role = "entry-point-clear";
      clearBtn.dataset.entryPointId = entryPoint.id;
      actions.appendChild(addBtn);
      actions.appendChild(markBtn);
      actions.appendChild(clearBtn);

      item.appendChild(deleteBtn);
      item.appendChild(header);
      item.appendChild(actions);
      entryPointList.appendChild(item);
    });
  }

  function updateEntryPointUi() {
    if (!entryPointList) return;
    const hasSelection = getSelectedSeats().length > 0;
    entryPointList.querySelectorAll("[data-role='entry-point-add']").forEach((btn) => {
      btn.disabled = !hasSelection;
    });
    entryPointList.querySelectorAll("[data-role='entry-point-mark']").forEach((btn) => {
      const entryPointId = btn.dataset.entryPointId;
      const entryPoint = entryPoints.find(ep => ep.id === entryPointId);
      const hasItems = entryPoint ? getEntryPointSeatIds(entryPoint).size > 0 : false;
      btn.disabled = !hasItems;
    });
    entryPointList.querySelectorAll("[data-role='entry-point-clear']").forEach((btn) => {
      const entryPointId = btn.dataset.entryPointId;
      const entryPoint = entryPoints.find(ep => ep.id === entryPointId);
      const hasItems = entryPoint ? getEntryPointSeatIds(entryPoint).size > 0 : false;
      btn.disabled = !hasItems;
    });
  }

  function openEntryPointModal() {
    if (entryPointOverlay) entryPointOverlay.style.display = "flex";
    if (entryPointName) {
      entryPointName.value = "";
      setTimeout(() => entryPointName.focus(), 50);
    }
  }

  function closeEntryPointModal() {
    if (entryPointOverlay) entryPointOverlay.style.display = "none";
  }

  function updateGoodnessModalHint() {
    if (!goodnessModalHint) return;
    const count = getSelectedSeats().length;
    goodnessModalHint.textContent = `${count} seat(s) selected. Range size: ${GOODNESS_RANGE_SIZE}.`;
  }

  function openGoodnessModal() {
    const selected = getSelectedSeats();
    if (!selected.length) return;
    renderGoodnessRangeOptions();
    updateGoodnessModalHint();
    if (goodnessOverlay) goodnessOverlay.style.display = "flex";
  }

  function closeGoodnessModal() {
    if (goodnessOverlay) goodnessOverlay.style.display = "none";
    goodnessAnchorPoint = null;
  }

  function applyGoodnessFromPoint(rangeIndex) {
    const selected = getSelectedSeats();
    if (!selected.length) return false;
    if (!goodnessAnchorPoint) {
      alert("Pick a point on the canvas first.");
      return false;
    }
    const safeIndex = Number.isFinite(rangeIndex)
      ? Math.max(1, Math.min(normalizeGoodnessRangeCount(goodnessRangeCount), rangeIndex))
      : 1;
    const base = (safeIndex - 1) * GOODNESS_RANGE_SIZE + 1;
    const step = selected.length > 1 ? (GOODNESS_RANGE_SIZE - 1) / (selected.length - 1) : 0;
    const sorted = selected.slice().sort((a, b) => {
      const da = Math.hypot(a.vx - goodnessAnchorPoint.x, a.vy - goodnessAnchorPoint.y);
      const db = Math.hypot(b.vx - goodnessAnchorPoint.x, b.vy - goodnessAnchorPoint.y);
      if (da !== db) return da - db;
      return String(a.seatId).localeCompare(String(b.seatId));
    });
    sorted.forEach((seat, idx) => {
      seat.goodness = base + step * idx;
    });
    updateCodeFromSeats();
    renderCanvas();
    hasUnsavedChanges = true;
    updateSaveButton();
    saveSessionToLocalStorage();
    return true;
  }

  function addSelectionToEntryPoint(entryPointId) {
    const entryPoint = entryPoints.find(ep => ep.id === entryPointId);
    if (!entryPoint) return;
    const selected = getSelectedSeats();
    if (!selected.length) return;
    let changed = false;
    selected.forEach((s) => {
      if (s.entryVia !== entryPoint.name) {
        s.entryVia = entryPoint.name;
        changed = true;
      }
    });
    if (!changed) return;
    updateCodeFromSeats();
    renderCanvas();
    updateEntryPointUi();
  }

  function clearEntryPoint(entryPointId) {
    const entryPoint = entryPoints.find(ep => ep.id === entryPointId);
    if (!entryPoint) return;
    let changed = false;
    seats.forEach((s) => {
      if (s.entryVia === entryPoint.name) {
        s.entryVia = "-";
        changed = true;
      }
    });
    if (!changed) return;
    updateCodeFromSeats();
    renderCanvas();
    updateEntryPointUi();
  }

  function renameEntryPoint(entryPointId, nextNameRaw, inputEl) {
    const entryPoint = entryPoints.find(ep => ep.id === entryPointId);
    if (!entryPoint) return;
    const nextName = normalizeEntryPointName(nextNameRaw);
    const prevName = inputEl?.dataset?.prevName || entryPoint.name;
    if (!nextName) {
      if (inputEl) inputEl.value = prevName;
      return;
    }
    const duplicate = entryPoints.some(ep => ep.id !== entryPointId && ep.name === nextName);
    if (duplicate) {
      alert("That entry point name already exists.");
      if (inputEl) inputEl.value = prevName;
      return;
    }
    if (nextName === prevName) return;
    entryPoint.name = nextName;
    if (inputEl) inputEl.dataset.prevName = nextName;
    seats.forEach((s) => {
      if (s.entryVia === prevName) s.entryVia = nextName;
    });
    saveEntryPointsToStorage();
    updateCodeFromSeats();
    renderCanvas();
    updateEntryPointUi();
  }

  function deleteEntryPoint(entryPointId) {
    const entryPoint = entryPoints.find(ep => ep.id === entryPointId);
    if (!entryPoint) return;
    if (!confirm("Delete this entry point? Assigned seats will be cleared.")) return;
    seats.forEach((s) => {
      if (s.entryVia === entryPoint.name) s.entryVia = "-";
    });
    const idx = entryPoints.findIndex(ep => ep.id === entryPointId);
    if (idx >= 0) entryPoints.splice(idx, 1);
    saveEntryPointsToStorage();
    renderEntryPointList();
    updateEntryPointUi();
    updateCodeFromSeats();
    renderCanvas();
  }

  openFileBtnTop?.addEventListener("click", () => {
    openFile();
  });

  saveBtn?.addEventListener("click", () => {
    if (!hasUnsavedChanges && currentFileHandle) {
      fileInfo.textContent = currentFileName ? `Saved (${currentFileName})` : "Saved";
      return;
    }
    saveFile();
  });
  saveAsBtn?.addEventListener("click", () => {
    saveFileAs();
  });

  closeLayoutBtn?.addEventListener("click", closeLayout);

  fileInput?.addEventListener("change", (e) => {
    const file = e.target.files && e.target.files[0];
    if (file) {
      openFileFromInput(file);
    }
  });

  function openNewLayoutModal() {
    if (newLayoutOverlay) newLayoutOverlay.style.display = "flex";
    if (newProjectName) {
      newProjectName.value = "";
      setTimeout(() => newProjectName.focus(), 50);
    }
    if (newVenueId) newVenueId.value = "";
  }

  function closeNewLayoutModal() {
    if (newLayoutOverlay) newLayoutOverlay.style.display = "none";
  }

  function requestCloseAltSectionManager(confirmMessage = "You have unsaved changes. Close anyway?") {
    if (!altSectionManagerOverlay || altSectionManagerOverlay.style.display !== "flex") return true;
    if (!sectionDirty || confirm(confirmMessage)) {
      closeAltSectionManager();
      return true;
    }
    return false;
  }

  function closeAllModals(options = {}) {
    const confirmAltSectionManager = !!options.confirmAltSectionManager;
    const altSectionConfirmMessage = options.altSectionConfirmMessage || "You have unsaved changes. Close anyway?";
    closeSeatContextMenu();
    closeExportModal();
    closeHelpModal();
    closeAttributeModal();
    closeSeatEditModal();
    closeRowEditModal();
    closeSectionEditModal();
    closePriceRegionModal();
    closeEntryPointModal();
    closeGoodnessModal();
    closeCodeModal();
    if (confirmAltSectionManager) {
      requestCloseAltSectionManager(altSectionConfirmMessage);
    } else {
      closeAltSectionManager();
    }
    closeNewLayoutModal();
  }

  function closeLayout() {
    if (hasUnsavedChanges) {
      const ok = confirm("Unsaved changes will be lost. Close this layout?");
      if (!ok) return;
    }
    closeAllModals();
    clearLayoutState();
    setLayoutActive(false);
  }

  async function handleStartNewLayout() {
    const rawName = (newProjectName?.value || "").trim();
    if (!rawName) {
      alert("Enter a project name.");
      return;
    }
    const venueIdVal = (newVenueId?.value || "").trim();
    if (venueIdVal && !/^\d+$/.test(venueIdVal)) {
      alert("VenueId får bara innehålla siffror.");
      newVenueId?.focus();
      return;
    }
    const safeBase = rawName.replace(/[\\/:*?\"<>|]/g, "_");
    const defaultFileName = safeBase ? `${safeBase}.tlt` : "layout.tlt";

    resetLayoutState(safeBase, venueIdVal);
    updateCodeFromSeats(); // tom layout -> initline finns
    clearCurrentFileHandleInDB();

    let createdFile = false;
    if (typeof window.showDirectoryPicker === "function") {
      try {
        const dir = await window.showDirectoryPicker();
        if (dir) {
          lastDirectoryHandle = dir;
          let handle = null;
          try {
            const existing = await dir.getFileHandle(defaultFileName);
            const overwrite = confirm(`"${defaultFileName}" already exists. Overwrite it?`);
            if (overwrite) handle = existing;
          } catch (err) {
            if (err?.name === "NotFoundError") {
              handle = await dir.getFileHandle(defaultFileName, { create: true });
            } else {
              throw err;
            }
          }
          if (handle) {
            const writable = await handle.createWritable();
            await writable.write(codePane.value || "");
            await writable.close();
            currentFileHandle = handle;
            currentFileName = handle.name || defaultFileName;
            forceSaveAs = false;
            fileInfo.textContent = `Saved ${currentFileName}`;
            hasUnsavedChanges = false;
            updateSaveButton();
            saveCurrentFileHandleToDB(handle);
            createdFile = true;
          }
        }
      } catch (err) {
        if (err?.name !== "AbortError") {
          console.warn("Mappval for nytt projekt misslyckades:", err);
        }
      }
    }

    // Markera som osparad så användaren sparar manuellt
    if (!createdFile) {
      currentFileName = defaultFileName;
      fileInfo.textContent = "New layout (not saved)";
      hasUnsavedChanges = true;
      updateSaveButton();
    }
    loadPriceRegionsFromStorage();
    loadEntryPointsFromStorage();
    loadGoodnessSettingsFromStorage();
    setLayoutActive(true);
    closeNewLayoutModal();
    openAltSectionManager();
  }

  newLayoutBtn?.addEventListener("click", openNewLayoutModal);
  newLayoutCancel?.addEventListener("click", closeNewLayoutModal);
  newLayoutStart?.addEventListener("click", handleStartNewLayout);

  exportBtn?.addEventListener("click", openExportModal);
  exportCancel?.addEventListener("click", closeExportModal);
  exportConfirm?.addEventListener("click", async () => {
    await exportFiles();
    closeExportModal();
  });
  exportSvg?.addEventListener("change", updateSvgSupportOptionAvailability);
  exportName?.addEventListener("keydown", (e) => {
    if (e.key === "Enter") {
      e.preventDefault();
      exportConfirm?.click();
    }
  });

  helpBtn?.addEventListener("click", openHelpModal);
  helpClose?.addEventListener("click", closeHelpModal);

  createPriceRegionBtn?.addEventListener("click", openPriceRegionModal);
  selectSeatsNoPriceRegionBtn?.addEventListener("click", () => {
    selectSeatsWithoutPriceRegions();
  });
  priceRegionCancel?.addEventListener("click", closePriceRegionModal);
  loadPriceRegionBtn?.addEventListener("click", () => {
    if (!seats.length) {
      alert("Load a layout (TLT) before importing price regions.");
      return;
    }
    priceRegionFileInput?.click();
  });
  priceRegionFileInput?.addEventListener("change", async (e) => {
    const file = e.target.files && e.target.files[0];
    if (!file) return;
    const text = await file.text();
    const regions = parseTprText(text);
    if (!regions.length) {
      alert("No price regions found in file.");
      return;
    }
    regions.forEach((region) => {
      region.name = normalizePriceRegionName(region.name);
    });
    const importNames = regions.map(r => r.name).filter(Boolean);
    const { duplicates, tooLong } = getPriceRegionNameIssues(importNames, new Set());
    const issueMessage = buildPriceRegionIssueMessage(duplicates, tooLong);
    if (issueMessage) {
      alert(issueMessage);
      return;
    }
    priceRegions.length = 0;
    regions.forEach(r => priceRegions.push(r));
    savePriceRegionsToStorage();
    renderPriceRegionList();
    updatePriceRegionUi();
    if (showPriceRegions) renderCanvas();
    priceRegionFileInput.value = "";
  });
  priceRegionCreate?.addEventListener("click", () => {
    const raw = priceRegionName?.value || "";
    const names = raw.split(/\r?\n|,/).map(normalizePriceRegionName).filter(Boolean);
    if (!names.length) {
      alert("Enter at least one name for the price region.");
      return;
    }
    const existingKeys = new Set(priceRegions.map(region => normalizePriceRegionKey(region.name)));
    const { duplicates, tooLong } = getPriceRegionNameIssues(names, existingKeys);
    const issueMessage = buildPriceRegionIssueMessage(duplicates, tooLong);
    if (issueMessage) {
      alert(issueMessage);
      return;
    }
    names.forEach((name) => {
      const id = `${Date.now()}${Math.floor(Math.random() * 1000)}`;
      const color = generatePriceRegionColor(priceRegions.length);
      priceRegions.push({ id, name, color, sections: [], rows: [], seats: [] });
    });
    savePriceRegionsToStorage();
    renderPriceRegionList();
    updatePriceRegionUi();
    if (showPriceRegions) renderCanvas();
    closePriceRegionModal();
  });
  priceRegionName?.addEventListener("keydown", (e) => {
    if (e.key === "Enter" && (e.ctrlKey || e.metaKey)) {
      e.preventDefault();
      priceRegionCreate?.click();
    }
  });
  createEntryPointBtn?.addEventListener("click", openEntryPointModal);
  selectSeatsNoEntryPointBtn?.addEventListener("click", () => {
    selectSeatsWithoutEntryPoints();
  });
  entryPointCancel?.addEventListener("click", closeEntryPointModal);
  entryPointCreate?.addEventListener("click", () => {
    const name = normalizeEntryPointName(entryPointName?.value || "");
    if (!name) {
      alert("Enter a name for the entry point.");
      return;
    }
    const duplicate = entryPoints.some(ep => ep.name === name);
    if (duplicate) {
      alert("That entry point name already exists.");
      return;
    }
    const id = buildEntryPointId();
    entryPoints.push({ id, name });
    saveEntryPointsToStorage();
    renderEntryPointList();
    updateEntryPointUi();
    closeEntryPointModal();
  });
  entryPointName?.addEventListener("keydown", (e) => {
    if (e.key === "Enter") {
      e.preventDefault();
      entryPointCreate?.click();
    }
  });
  selectSeatsNoGoodnessBtn?.addEventListener("click", () => {
    selectSeatsWithoutGoodness();
  });
  goodnessRangeCountInput?.addEventListener("change", (e) => {
    setGoodnessRangeCount(e.target.value);
  });
  goodnessRangeCountInput?.addEventListener("blur", (e) => {
    setGoodnessRangeCount(e.target.value);
  });
  goodnessCancel?.addEventListener("click", closeGoodnessModal);
  goodnessApply?.addEventListener("click", () => {
    const rangeIndex = parseInt(goodnessRangeSelect?.value || "1", 10);
    const didApply = applyGoodnessFromPoint(Number.isFinite(rangeIndex) ? rangeIndex : 1);
    if (didApply) closeGoodnessModal();
  });
  priceRegionList?.addEventListener("click", (e) => {
    const btn = e.target.closest("[data-role='price-region-add']");
    if (btn) {
      const regionId = btn.dataset.regionId;
      if (regionId) addSelectionToPriceRegion(regionId);
      return;
    }
    const markBtn = e.target.closest("[data-role='price-region-mark']");
    if (markBtn) {
      const regionId = markBtn.dataset.regionId;
      const region = priceRegions.find(r => r.id === regionId);
      if (!region) return;
      const ids = getRegionSeatIds(region);
      let selectionChanged = false;
      for (const s of seats) {
        const shouldSelect = ids.has(s.seatId);
        if (s.selected !== shouldSelect) {
          s.selected = shouldSelect;
          selectionChanged = true;
        }
      }
      if (selectionChanged) {
        lastSelectionSource = "program";
        pushHistorySnapshot();
        updateMoveButtonState();
        renderCanvas();
        saveSessionToLocalStorage();
      }
      return;
    }
    const clearBtn = e.target.closest("[data-role='price-region-clear']");
    if (clearBtn) {
      const regionId = clearBtn.dataset.regionId;
      const region = priceRegions.find(r => r.id === regionId);
      if (!region) return;
      if (!confirm("Clear this price region?")) return;
      region.sections = [];
      region.rows = [];
      region.seats = [];
      savePriceRegionsToStorage();
      renderPriceRegionList();
      updatePriceRegionUi();
      if (showPriceRegions) renderCanvas();
      return;
    }
    const delBtn = e.target.closest("[data-role='price-region-delete']");
    if (!delBtn) return;
    const regionId = delBtn.dataset.regionId;
    if (!regionId) return;
    if (!confirm("Delete this price region?")) return;
    const idx = priceRegions.findIndex(r => r.id === regionId);
    if (idx === -1) return;
    priceRegions.splice(idx, 1);
    savePriceRegionsToStorage();
    renderPriceRegionList();
    updatePriceRegionUi();
    if (showPriceRegions) renderCanvas();
  });

  entryPointList?.addEventListener("click", (e) => {
    const addBtn = e.target.closest("[data-role='entry-point-add']");
    if (addBtn) {
      const entryPointId = addBtn.dataset.entryPointId;
      if (entryPointId) addSelectionToEntryPoint(entryPointId);
      return;
    }
    const markBtn = e.target.closest("[data-role='entry-point-mark']");
    if (markBtn) {
      const entryPointId = markBtn.dataset.entryPointId;
      const entryPoint = entryPoints.find(ep => ep.id === entryPointId);
      if (!entryPoint) return;
      const ids = getEntryPointSeatIds(entryPoint);
      let selectionChanged = false;
      for (const s of seats) {
        const shouldSelect = ids.has(s.seatId);
        if (s.selected !== shouldSelect) {
          s.selected = shouldSelect;
          selectionChanged = true;
        }
      }
      if (selectionChanged) {
        lastSelectionSource = "program";
        pushHistorySnapshot();
        updateMoveButtonState();
        renderCanvas();
        saveSessionToLocalStorage();
      }
      return;
    }
    const clearBtn = e.target.closest("[data-role='entry-point-clear']");
    if (clearBtn) {
      const entryPointId = clearBtn.dataset.entryPointId;
      if (!entryPointId) return;
      if (!confirm("Clear this entry point?")) return;
      clearEntryPoint(entryPointId);
      return;
    }
    const delBtn = e.target.closest("[data-role='entry-point-delete']");
    if (!delBtn) return;
    const entryPointId = delBtn.dataset.entryPointId;
    if (!entryPointId) return;
    deleteEntryPoint(entryPointId);
  });

  entryPointList?.addEventListener("change", (e) => {
    const nameInput = e.target.closest("[data-role='entry-point-name']");
    if (!nameInput) return;
    const entryPointId = nameInput.dataset.entryPointId;
    if (!entryPointId) return;
    renameEntryPoint(entryPointId, nameInput.value, nameInput);
  });

  entryPointList?.addEventListener("keydown", (e) => {
    if (e.key !== "Enter") return;
    const nameInput = e.target.closest("[data-role='entry-point-name']");
    if (!nameInput) return;
    e.preventDefault();
    nameInput.blur();
  });

  priceRegionList?.addEventListener("focusin", (e) => {
    const nameInput = e.target.closest("[data-role='price-region-name']");
    if (!nameInput) return;
    nameInput.dataset.prevValue = normalizePriceRegionName(nameInput.value);
  });

  priceRegionList?.addEventListener("focusout", (e) => {
    const nameInput = e.target.closest("[data-role='price-region-name']");
    if (!nameInput) return;
    const regionId = nameInput.dataset.regionId;
    const region = priceRegions.find(r => r.id === regionId);
    if (!region) return;
    const prevValue = nameInput.dataset.prevValue || "";
    const nextName = normalizePriceRegionName(nameInput.value);
    const prevKey = normalizePriceRegionKey(prevValue);
    const nextKey = normalizePriceRegionKey(nextName);
    if (!nextKey || nextKey === prevKey) return;
    const duplicate = priceRegions.some(r => r.id !== regionId && normalizePriceRegionKey(r.name) === nextKey);
    if (!duplicate) return;
    alert("That price region name already exists.");
    nameInput.value = prevValue;
    region.name = prevValue;
    savePriceRegionsToStorage();
    if (showPriceRegions) renderCanvas();
  });

  priceRegionList?.addEventListener("input", (e) => {
    const nameInput = e.target.closest("[data-role='price-region-name']");
    if (nameInput) {
      const regionId = nameInput.dataset.regionId;
      const region = priceRegions.find(r => r.id === regionId);
      if (!region) return;
      let nextName = normalizePriceRegionName(nameInput.value);
      if (nextName.length > PRICE_REGION_NAME_MAX) {
        nextName = nextName.slice(0, PRICE_REGION_NAME_MAX);
        nameInput.value = nextName;
      }
      region.name = nextName;
      savePriceRegionsToStorage();
      if (showPriceRegions) renderCanvas();
      return;
    }
    const input = e.target.closest("[data-role='price-region-color']");
    if (!input) return;
    const regionId = input.dataset.regionId;
    const region = priceRegions.find(r => r.id === regionId);
    if (!region) return;
    region.color = input.value;
    savePriceRegionsToStorage();
    if (showPriceRegions) renderCanvas();
  });

  // Försök återanvända senaste handle direkt vid start (utan att öppna filen automatiskt)
  loadCurrentFileHandleFromDB().then((handle) => {
    if (handle) {
      currentFileHandle = handle;
      currentFileName = handle.name || currentFileName;
    }
  });

  function updateSaveButton() {
    saveBtn.disabled = !layoutActive || !hasUnsavedChanges;
    if (saveAsBtn) saveAsBtn.disabled = !layoutActive;
  }

  function updateMoveButtonState() {
    const anySelected = seats.some(s => s.selected);
    const selectedRows = getSelectedRows();
    const selectedRowsCount = selectedRows.size;
    const allowTransform = anySelected;
    const allowResize = anySelected && (selectionMode === "section" || selectionMode === "row");
    const allowBend = selectionMode === "row" && selectedRowsCount === 1;
    const allowReshape = selectionMode === "row" && selectedRowsCount === 1;
    const allowResetRow = selectionMode === "row" && selectedRowsCount >= 1;
    const allowMakeTable = selectionMode === "row" && selectedRowsCount >= 1;

    moveToolBtn.disabled = !allowTransform;
    rotateToolBtn.disabled = !allowTransform;
    resizeToolBtn.disabled = !allowResize;
    bendToolBtn.disabled = !allowBend;
    reshapeRowBtn.disabled = !allowReshape;
    resetRowBtn.disabled = !allowResetRow;
    makeTableBtn.disabled = !allowMakeTable;

    if (
      (!allowTransform && (currentTool === "move" || currentTool === "rotate")) ||
      (!allowResize && currentTool === "resize") ||
      (!allowBend && currentTool === "bend") ||
      (!allowReshape && currentTool === "reshape")
    ) {
      setTool("select");
    }

    updateAlignButtons();
    updatePriceRegionUi();
    updateEntryPointUi();
  }

  function updateAlignButtons() {
    const groups = getAlignGroups();
    const enabled = groups.length >= 2;
    alignTopBtn.disabled = !enabled;
    alignBottomBtn.disabled = !enabled;
    alignLeftBtn.disabled = !enabled;
    alignRightBtn.disabled = !enabled;
    alignCenterHBtn.disabled = !enabled;
    alignCenterVBtn.disabled = !enabled;
    const hasSelection = seats.some(s => s.selected);
    if (flipVBtn) flipVBtn.disabled = !hasSelection;
    if (flipHBtn) flipHBtn.disabled = !hasSelection;
    if (rotateCcwBtn) rotateCcwBtn.disabled = !hasSelection;
    if (rotateCwBtn) rotateCwBtn.disabled = !hasSelection;
  }

  // Hjälpfunktioner för färgkontrast på etiketter
  const labelColorCache = new Map();
  function hexToRgb(hex) {
    const h = hex.replace("#", "").trim();
    if (h.length === 3) {
      return {
        r: parseInt(h[0] + h[0], 16),
        g: parseInt(h[1] + h[1], 16),
        b: parseInt(h[2] + h[2], 16)
      };
    }
    return {
      r: parseInt(h.slice(0, 2), 16),
      g: parseInt(h.slice(2, 4), 16),
      b: parseInt(h.slice(4, 6), 16)
    };
  }
  function clampValue(value, min, max) {
    if (value < min) return min;
    if (value > max) return max;
    return value;
  }
  function rgbToHex({ r, g, b }) {
    const toHex = (v) => clampValue(Math.round(v), 0, 255).toString(16).padStart(2, "0");
    return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
  }
  function mixHexColors(startHex, endHex, t) {
    const start = hexToRgb(startHex);
    const end = hexToRgb(endHex);
    const clamped = clampValue(t, 0, 1);
    return rgbToHex({
      r: start.r + (end.r - start.r) * clamped,
      g: start.g + (end.g - start.g) * clamped,
      b: start.b + (end.b - start.b) * clamped
    });
  }
  function getLabelTextColor(color) {
    if (!color) return "#fff";
    if (labelColorCache.has(color)) return labelColorCache.get(color);
    const { r, g, b } = hexToRgb(color);
    const lum = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
    const txt = lum > 0.55 ? "#0f1d2a" : "#ffffff";
    labelColorCache.set(color, txt);
    return txt;
  }

  function computeGoodnessStats() {
    let min = Infinity;
    let max = -Infinity;
    for (const s of seats) {
      const value = Number(s.goodness);
      if (!Number.isFinite(value) || value <= 0) continue;
      if (value < min) min = value;
      if (value > max) max = value;
    }
    if (min === Infinity) return null;
    return { min, max };
  }

  function getGoodnessHeatColor(value, stats) {
    if (!stats || !Number.isFinite(value) || value <= 0) return null;
    if (stats.min === stats.max) return GOODNESS_HEAT_START;
    const t = (value - stats.min) / (stats.max - stats.min);
    return mixHexColors(GOODNESS_HEAT_START, GOODNESS_HEAT_END, t);
  }

  function getSelectionStrokePalette() {
    const useRed = overlayMode === "none";
    return {
      outerColor: useRed ? "#ff3b30" : "#ffffff",
      innerColor: "#111111",
      outerWidth: 4,
      innerWidth: 2
    };
  }

  // --- Render ---
  function renderCanvas() {
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const worldMinX = (-translateX) / scale;
    const worldMaxX = (canvas.width - translateX) / scale;
    const worldMinY = (-translateY) / scale;
    const worldMaxY = (canvas.height - translateY) / scale;

    // Först: räkna synliga platser
    let visibleCount = 0;
    for (const s of seats) {
      if (
        s.vx < worldMinX || s.vx > worldMaxX ||
        s.vy < worldMinY || s.vy > worldMaxY
      ) continue;
      visibleCount++;
    }
    lastVisibleSeatCount = visibleCount;

    const useRectDots = visibleCount > RECT_DOT_THRESHOLD;
    const rectScreenSize = 2;
    const rectSizeWorld = rectScreenSize / scale;

    ctx.save();
    ctx.translate(translateX, translateY);
    ctx.scale(scale, scale);

    // Bakgrundsbild
    if (backgroundState.enabled && backgroundState.img) {
      const bgImg = backgroundState.img;
      const drawW = bgImg.naturalWidth * backgroundState.scale;
      const drawH = bgImg.naturalHeight * backgroundState.scale;
      ctx.save();
      ctx.globalAlpha = backgroundState.opacity;
      ctx.drawImage(bgImg, backgroundState.originX, backgroundState.originY, drawW, drawH);
      ctx.restore();
    }

    const priceRegionLookups = showPriceRegions ? buildPriceRegionLookups() : null;
    const goodnessStats = showGoodnessHeatmap ? computeGoodnessStats() : null;
    const selectionStroke = getSelectionStrokePalette();

    // Platser
    for (const s of seats) {
      if (
        s.vx < worldMinX || s.vx > worldMaxX ||
        s.vy < worldMinY || s.vy > worldMaxY
      ) continue;

      let baseColor = sectionColors.get(s.sectionId) || "#4a90e2";
      if (showGoodnessHeatmap && goodnessStats) {
        const heatColor = getGoodnessHeatColor(Number(s.goodness), goodnessStats);
        if (heatColor) baseColor = heatColor;
      } else if (showPriceRegions && priceRegionLookups) {
        const prColor = getSeatPriceRegionColor(s, priceRegionLookups);
        if (prColor) baseColor = prColor;
      }
      if (renderGrayscale) {
        baseColor = "#9ca8b7";
      }

      // Fyrkantsläge (massor av platser)
      if (useRectDots) {
        ctx.fillStyle = baseColor;
        ctx.fillRect(
          s.vx - rectSizeWorld / 2,
          s.vy - rectSizeWorld / 2,
          rectSizeWorld,
          rectSizeWorld
        );

        if (s.selected) {
          ctx.lineWidth = selectionStroke.outerWidth / scale;
          ctx.strokeStyle = selectionStroke.outerColor;
          ctx.strokeRect(
            s.vx - rectSizeWorld,
            s.vy - rectSizeWorld,
            rectSizeWorld * 2,
            rectSizeWorld * 2
          );
          ctx.lineWidth = selectionStroke.innerWidth / scale;
          ctx.strokeStyle = selectionStroke.innerColor;
          ctx.strokeRect(
            s.vx - rectSizeWorld,
            s.vy - rectSizeWorld,
            rectSizeWorld * 2,
            rectSizeWorld * 2
          );
        }
        if (s.attributes && s.attributes.length) {
          ctx.save();
          ctx.fillStyle = "rgba(0,0,0,0.35)";
          ctx.strokeStyle = "rgba(255,255,255,0.8)";
          drawHexMarker(ctx, s.vx, s.vy, rectSizeWorld * 0.7, 1.6 / scale);
          ctx.restore();
        }
        continue;
      }

        // Cirkel-läge
        let pxRadius = BASE_WORLD_RADIUS * scale;
        if (pxRadius < MIN_SEAT_SCREEN_RADIUS) {
          pxRadius = MIN_SEAT_SCREEN_RADIUS;
        }
        const worldRadius = pxRadius / scale;

      ctx.beginPath();
      ctx.arc(s.vx, s.vy, worldRadius, 0, Math.PI * 2);
      ctx.fillStyle = baseColor;
      ctx.fill();

        if (s.selected) {
          ctx.lineWidth = selectionStroke.outerWidth / scale;
          ctx.strokeStyle = selectionStroke.outerColor;
          ctx.stroke();
          ctx.lineWidth = selectionStroke.innerWidth / scale;
          ctx.strokeStyle = selectionStroke.innerColor;
          ctx.stroke();
      } else {
          ctx.lineWidth = 1.2 / scale;
          ctx.strokeStyle = "rgba(0,0,0,0.25)";
          ctx.stroke();
        }

        if (seatLabelMode !== "none") {
          let label = "";
          if (seatLabelMode === "seat") {
            label = s.name || "";
          } else if (seatLabelMode === "seatId") {
            const seatId = s.seatId || "";
            const suffix = getSeatIdSuffix(seatId);
            if (Number.isFinite(suffix)) {
              label = String(suffix);
            } else if (seatId) {
              const parts = seatId.split(".");
              label = parts[parts.length - 1] || seatId;
            }
          } else {
            label = s.rowName || s.rowId || s.row || "";
          }
          if (label) {
            const fontPx = Math.max(26, Math.min(48, 33 / Math.max(scale, 0.001)));
            const textColor = getLabelTextColor(baseColor);
            ctx.save();
            ctx.fillStyle = textColor;
            ctx.strokeStyle = "rgba(0,0,0,0.0)";
            ctx.lineWidth = 0 / Math.max(scale, 0.001);
            ctx.font = `${fontPx}px "Ubuntu Mono", "Segoe UI", system-ui, sans-serif`;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.strokeText(label, s.vx, s.vy);
            ctx.fillText(label, s.vx, s.vy);
            ctx.restore();
          }
        }

        if (s.attributes && s.attributes.length) {
          ctx.save();
          ctx.fillStyle = "rgba(0,0,0,0.15)";
          ctx.strokeStyle = "rgba(255,255,255,0.7)";
          drawHexMarker(ctx, s.vx, s.vy, worldRadius * 0.6, 1.6 / scale);
          ctx.restore();
        }
      }

      // Sektionsnamn (mitt i sektionen)
      if (showSectionNames) {
      const boundsBySection = new Map();
      for (const s of seats) {
        if (!s.sectionId) continue;
        let b = boundsBySection.get(s.sectionId);
        if (!b) {
          b = { minX: s.vx, maxX: s.vx, minY: s.vy, maxY: s.vy };
          boundsBySection.set(s.sectionId, b);
        } else {
          b.minX = Math.min(b.minX, s.vx);
          b.maxX = Math.max(b.maxX, s.vx);
          b.minY = Math.min(b.minY, s.vy);
          b.maxY = Math.max(b.maxY, s.vy);
        }
      }
      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,0.75)";
      ctx.strokeStyle = "rgba(255,255,255,0.8)";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      for (const [sectionId, b] of boundsBySection.entries()) {
        const cx = (b.minX + b.maxX) / 2;
        const cy = (b.minY + b.maxY) / 2;
        if (cx < worldMinX || cx > worldMaxX || cy < worldMinY || cy > worldMaxY) continue;
        const name = sectionNames.get(sectionId) || sectionId || "";
        if (!name) continue;
        const fontSize = 20 / Math.max(scale, 0.001);
        ctx.lineWidth = 3 / Math.max(scale, 0.001);
        ctx.font = `${fontSize}px "Ubuntu", system-ui, sans-serif`;
        ctx.strokeText(name, cx, cy);
        ctx.fillText(name, cx, cy);
      }
      ctx.restore();
    }

    // Reshape-pivot-indikator
    if (currentTool === "reshape" && reshapePivotSeatId) {
      const pivotSeat = seats.find(s => s.seatId === reshapePivotSeatId);
      if (pivotSeat) {
        const r = (BASE_WORLD_RADIUS * 1) / Math.max(scale, 1e-6);
        ctx.save();
        ctx.beginPath();
        ctx.arc(pivotSeat.vx, pivotSeat.vy, r, 0, Math.PI * 2);
        ctx.strokeStyle = "#e67e22";
        ctx.lineWidth = 2 / scale;
        ctx.setLineDash([4 / scale, 3 / scale]);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.fillStyle = "rgba(230,126,34,0.2)";
        ctx.fill();
        ctx.restore();
      }
    }

    if (!seats.length) {
      ctx.restore();
      ctx.fillStyle = "#777";
      ctx.font = "24px Ubuntu";
      ctx.fillText("No layout has been loaded or created. Click Open layout or Create new to get started.", 15, 30);
      lastVisibleSeatCount = 0;
      return;
    }

    // Ruta-markering overlay (i world + transform)
    if (selectionRectActive) {
      const x1 = Math.min(rectStartCanvasX, rectEndCanvasX);
      const y1 = Math.min(rectStartCanvasY, rectEndCanvasY);
      const x2 = Math.max(rectStartCanvasX, rectEndCanvasX);
      const y2 = Math.max(rectStartCanvasY, rectEndCanvasY);

      const w1 = (x1 - translateX) / scale;
      const h1 = (y1 - translateY) / scale;
      const w2 = (x2 - translateX) / scale;
      const h2 = (y2 - translateY) / scale;

      ctx.save();
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.beginPath();
      ctx.rect(x1, y1, x2 - x1, y2 - y1);
      ctx.strokeStyle = "rgba(47,128,237,0.9)";
      ctx.lineWidth = 1;
      ctx.setLineDash([4, 3]);
      ctx.stroke();
      ctx.fillStyle = "rgba(47,128,237,0.15)";
      ctx.fill();
      ctx.restore();
    }

    ctx.restore();

    // Tooltip-hantering utanför transform
    if (showHoverInfo && hoverSeat && lastVisibleSeatCount <= HOVER_VISIBLE_LIMIT) {
      tooltipEl.style.display = "block";
    } else {
      tooltipEl.style.display = "none";
    }

    // Resize-overlay (handtag) ritas ovanpå allt
    if (currentTool === "resize") {
      const selected = getSelectedSeats();
      if (selected.length) {
        const bounds = getSelectionBounds(selected);
        if (bounds) {
          ctx.save();
          ctx.translate(translateX, translateY);
          ctx.scale(scale, scale);

          ctx.lineWidth = 1.5 / scale;
          ctx.strokeStyle = "rgba(0,0,0,0.6)";
          ctx.setLineDash([6 / scale, 4 / scale]);
          ctx.strokeRect(bounds.minX, bounds.minY, bounds.maxX - bounds.minX, bounds.maxY - bounds.minY);

          ctx.setLineDash([]);
          const handleSize = 10 / scale;
          const handles = getResizeHandles(bounds);
          ctx.fillStyle = "#ffffff";
          ctx.strokeStyle = "#14a0f4";
          for (const h of handles) {
            ctx.beginPath();
            ctx.rect(h.x - handleSize / 2, h.y - handleSize / 2, handleSize, handleSize);
            ctx.fill();
            ctx.stroke();
          }

          ctx.restore();
        }
      }
    }

    // Bend-overlay: single anchor quadratic
    if (currentTool === "bend") {
      const rows = getSelectedRows();
      if (rows.size === 1) {
        const firstRow = rows.values().next().value;
        if (firstRow && firstRow.length >= 2) {
          const data = computeRowEndpoints(firstRow);
          const p0 = { x: data.first.vx, y: data.first.vy };
          const p2 = { x: data.last.vx, y: data.last.vy };
          const mid = { x: (p0.x + p2.x) / 2, y: (p0.y + p2.y) / 2 };
          const anchor = bendControlPoint || mid;

          ctx.save();
          ctx.translate(translateX, translateY);
          ctx.scale(scale, scale);

          ctx.strokeStyle = "#c12e44";
          ctx.lineWidth = 2 / scale;
          ctx.setLineDash([6 / scale, 4 / scale]);
          ctx.beginPath();
          if (anchor) {
            const tension = Math.max(-4, Math.min(1, Number.isFinite(bendTension) ? bendTension : 0));
            const len0 = Math.hypot(anchor.x - p0.x, anchor.y - p0.y);
            const len1 = Math.hypot(p2.x - anchor.x, p2.y - anchor.y);
            const polyTotal = len0 + len1 || 1e-6;
            const steps = 40;
            if (tension <= 0) {
              const weight = Math.max(0.01, Math.exp(tension));
              const arc = buildRationalQuadArcTable(p0, anchor, p2, weight);
              for (let i = 0; i <= steps; i++) {
                const tNorm = i / steps;
                const t = tAtArcLength(arc.total * tNorm, arc);
                const pt = rationalQuadPoint(t, p0, anchor, p2, weight);
                if (i === 0) ctx.moveTo(pt.x, pt.y);
                else ctx.lineTo(pt.x, pt.y);
              }
            } else {
              const arc = buildBezierArcTable(p0, anchor, p2);
              for (let i = 0; i <= steps; i++) {
                const tNorm = i / steps;
                const t = tAtArcLength(arc.total * tNorm, arc);
                const quadPt = bezierPoint(t, p0, anchor, p2);
                const polyPt = polylinePoint(p0, anchor, p2, polyTotal * tNorm, len0, len1);
                const pt = lerpPoint(quadPt, polyPt, tension);
                if (i === 0) ctx.moveTo(pt.x, pt.y);
                else ctx.lineTo(pt.x, pt.y);
              }
            }
          } else {
            ctx.moveTo(p0.x, p0.y);
            ctx.lineTo(p2.x, p2.y);
          }
          ctx.stroke();

          ctx.setLineDash([]);
          ctx.fillStyle = "#c12e44";
          ctx.strokeStyle = "#fff";
          const r = 6 / scale;

          if (anchor) {
            ctx.beginPath();
            ctx.arc(anchor.x, anchor.y, r, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
          }
          ctx.beginPath();
          ctx.arc(p0.x, p0.y, r * 0.8, 0, Math.PI * 2);
          ctx.arc(p2.x, p2.y, r * 0.8, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();

          ctx.restore();
        }
      }
    }
  }

  function zoomToFitAllSeats() {
  if (!seats || seats.length === 0) return;

  let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
  for (const s of seats) {
    if (s.vx < minX) minX = s.vx;
    if (s.vx > maxX) maxX = s.vx;
    if (s.vy < minY) minY = s.vy;
    if (s.vy > maxY) maxY = s.vy;
  }

  if (!Number.isFinite(minX) || !Number.isFinite(maxX)) return;

  const paddingWorld = 50;
  const widthWorld  = (maxX - minX) + paddingWorld * 2;
  const heightWorld = (maxY - minY) + paddingWorld * 2;
  const cxWorld = (minX + maxX) / 2;
  const cyWorld = (minY + maxY) / 2;

  const scaleX = canvas.width  / widthWorld;
  const scaleY = canvas.height / heightWorld;
  scale = Math.min(scaleX, scaleY);

  translateX = canvas.width  / 2 - cxWorld * scale;
  translateY = canvas.height / 2 - cyWorld * scale;

  renderCanvas();
}

  function selectAllSeats() {
  if (!seats || seats.length === 0) return;

  let changed = false;
  let lastAdded = null;
  for (const s of seats) {
    if (!s.selected) {
      s.selected = true;
      s.selectedAt = selectionOrderCounter++;
      changed = true;
      lastAdded = s;
    }
  }
  if (!changed) return;

  if (lastAdded) lastSelectedSeatId = lastAdded.seatId;
  lastSelectionSource = "program";

  // Aktivera Move-verktyget (det är bara knappen som ska bli aktiverbar)
  moveToolBtn.disabled = false;

  // Lägg detta i historiken så att Ctrl+Z även ångrar "markera alla"
  if (typeof pushHistorySnapshot === "function") {
    pushHistorySnapshot();
  }

    renderCanvas();
  }

function selectSeatsByPredicate(predicate) {
  if (!seats || seats.length === 0 || typeof predicate !== "function") return false;
  const matches = [];
  const matchIds = new Set();
  for (const seat of seats) {
    if (predicate(seat)) {
      matches.push(seat);
      matchIds.add(seat.seatId);
    }
  }

  let changed = false;
  for (const seat of seats) {
    const shouldSelect = matchIds.has(seat.seatId);
    if (seat.selected !== shouldSelect) {
      changed = true;
      break;
    }
  }
  if (!changed) return false;

  lastSelectionSource = "program";
  clearSelectionSeats(seats);
  if (matches.length) {
    markSeatsSelected(matches);
  } else {
    lastSelectedSeatId = null;
  }

  setSelectionMode("seat");
  updateMoveButtonState();
  renderCanvas();
  if (typeof pushHistorySnapshot === "function") {
    pushHistorySnapshot();
  }
  return true;
}

function selectSeatsWithoutPriceRegions() {
  const lookups = buildPriceRegionLookups();
  return selectSeatsByPredicate((seat) => !getSeatPriceRegionColor(seat, lookups));
}

function selectSeatsWithoutEntryPoints() {
  return selectSeatsByPredicate((seat) => {
    const entryVia = typeof seat.entryVia === "string" ? seat.entryVia.trim() : "";
    return !entryVia || entryVia === "-";
  });
}

function selectSeatsWithoutGoodness() {
  return selectSeatsByPredicate((seat) => {
    const goodnessValue = Number(seat.goodness);
    return !Number.isFinite(goodnessValue) || goodnessValue <= 0;
  });
}


  // --- Markeringsdata ---
  function getSelectedSeats() {
    return seats.filter(s => s.selected);
  }

  function clearSelectionSeats(seatsToClear) {
    for (const s of seatsToClear) {
      s.selected = false;
      s.selectedAt = null;
    }
  }

  function markSeatsSelected(seatsToSelect, anchorSeatId) {
    if (!seatsToSelect || seatsToSelect.length === 0) return;
    const order = selectionOrderCounter++;
    for (const s of seatsToSelect) {
      s.selected = true;
      s.selectedAt = order;
    }
    if (anchorSeatId) {
      lastSelectedSeatId = anchorSeatId;
    } else {
      const lastSeat = seatsToSelect[seatsToSelect.length - 1];
      lastSelectedSeatId = lastSeat ? lastSeat.seatId : null;
    }
  }

  function refreshSelectionAnchorFromOrder() {
    let anchor = null;
    let bestOrder = -Infinity;
    for (const s of seats) {
      if (!s.selected) continue;
      const order = typeof s.selectedAt === "number" ? s.selectedAt : 0;
      if (!anchor || order >= bestOrder) {
        anchor = s;
        bestOrder = order;
      }
    }
    lastSelectedSeatId = anchor ? anchor.seatId : null;
    if (Number.isFinite(bestOrder) && bestOrder >= selectionOrderCounter) {
      selectionOrderCounter = bestOrder + 1;
    }
  }

  function rebuildSelectionOrderFromSelection() {
    let order = 1;
    let anchor = null;
    for (const s of seats) {
      if (s.selected) {
        s.selectedAt = order++;
        anchor = s;
      } else {
        s.selectedAt = null;
      }
    }
    selectionOrderCounter = order;
    lastSelectedSeatId = anchor ? anchor.seatId : null;
  }

  function getSelectionAnchorSeat(selectedSeats) {
    if (!selectedSeats || !selectedSeats.length) return null;
    if (lastSelectedSeatId) {
      const anchor = selectedSeats.find(s => s.seatId === lastSelectedSeatId);
      if (anchor) return anchor;
    }
    let best = selectedSeats[0];
    let bestOrder = typeof best.selectedAt === "number" ? best.selectedAt : 0;
    for (const s of selectedSeats) {
      const order = typeof s.selectedAt === "number" ? s.selectedAt : 0;
      if (order >= bestOrder) {
        best = s;
        bestOrder = order;
      }
    }
    return best;
  }

  function removeSeatsById(seatIds) {
    if (!seatIds || seatIds.size === 0) return false;
    seats = seats.filter(s => !seatIds.has(s.seatId));
    const removedIndexes = [];
    originalLines = originalLines.filter((line, idx) => {
      if (!line.includes("|SeatAdd|")) return true;
      const seatIdMatch = line.match(/SeatId=([^|]+)/);
      if (!seatIdMatch) return true;
      if (seatIds.has(seatIdMatch[1])) {
        removedIndexes.push(idx);
        return false;
      }
      return true;
    });
    shiftOutlineLineIndexesAfterRemoval(removedIndexes);
    rebuildSeatLineIndex();
    return true;
  }

  function removeRowsById(rowIds) {
    if (!rowIds || rowIds.size === 0) return false;
    const seatIds = new Set();
    seats = seats.filter((s) => {
      if (rowIds.has(s.rowId)) {
        seatIds.add(s.seatId);
        return false;
      }
      return true;
    });
    const removedIndexes = [];
    originalLines = originalLines.filter((line, idx) => {
      if (line.includes("|RowAdd|")) {
        const rowMatch = line.match(/RowId=([^|]+)/);
        if (rowMatch && rowIds.has(rowMatch[1])) {
          removedIndexes.push(idx);
          return false;
        }
      }
      if (line.includes("|SeatAdd|")) {
        const seatMatch = line.match(/SeatId=([^|]+)/);
        if (seatMatch && seatIds.has(seatMatch[1])) {
          removedIndexes.push(idx);
          return false;
        }
      }
      return true;
    });
    shiftOutlineLineIndexesAfterRemoval(removedIndexes);
    rebuildSeatLineIndex();
    return true;
  }

  function updateCountsAfterSeatChange() {
    seatCountEl.textContent = seats.length.toString();
    const uniqueSections = new Set(seats.map(s => s.sectionId).filter(Boolean));
    sectionCountEl.textContent = uniqueSections.size.toString();
  }

  function deleteSelectionByMode() {
    const selected = getSelectedSeats();
    if (!selected.length) return;
    let removed = false;

    if (selectionMode === "section") {
      const sectionIds = new Set(selected.map(s => s.sectionId).filter(Boolean));
      if (!sectionIds.size) return;
      if (!confirm(`Delete ${sectionIds.size} section(s)?`)) return;
      sectionIds.forEach((sectionId) => {
        removeSectionData(sectionId);
        sectionNames.delete(sectionId);
        sectionColors.delete(sectionId);
      });
      removed = true;
    } else if (selectionMode === "row") {
      const rowIds = new Set(selected.map(s => s.rowId).filter(Boolean));
      if (!rowIds.size) return;
      if (!confirm(`Delete ${rowIds.size} row(s)?`)) return;
      removed = removeRowsById(rowIds);
    } else {
      const seatIds = new Set(selected.map(s => s.seatId));
      if (!seatIds.size) return;
      if (!confirm(`Delete ${seatIds.size} seat(s)?`)) return;
      removed = removeSeatsById(seatIds);
    }

    if (!removed) return;
    clearSelectionSeats(seats);
    lastSelectedSeatId = null;
    rebuildSeatLineIndex();
    prunePriceRegionsToExistingSeats();
    updateCountsAfterSeatChange();
    updatePriceRegionStatus();
    updateCodeFromSeats();
    renderCanvas();
    updateMoveButtonState();
    updateEntryPointUi();
    hasUnsavedChanges = true;
    updateSaveButton();
    pushHistorySnapshot();
  }

  function getSelectionBounds(selectedSeats) {
    if (!selectedSeats || !selectedSeats.length) return null;
    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
    for (const s of selectedSeats) {
      if (s.vx < minX) minX = s.vx;
      if (s.vx > maxX) maxX = s.vx;
      if (s.vy < minY) minY = s.vy;
      if (s.vy > maxY) maxY = s.vy;
    }
    if (!Number.isFinite(minX) || !Number.isFinite(minY) || !Number.isFinite(maxX) || !Number.isFinite(maxY)) {
      return null;
    }
    return {
      minX,
      minY,
      maxX,
      maxY,
      centerX: (minX + maxX) / 2,
      centerY: (minY + maxY) / 2
    };
  }

  function getSelectedRows() {
    const selected = getSelectedSeats();
    const rows = new Map();
    for (const s of selected) {
      if (!s.rowId) continue;
      if (!rows.has(s.rowId)) rows.set(s.rowId, []);
      rows.get(s.rowId).push(s);
    }
    return rows;
  }

  function sortSeatsInRow(rowSeats) {
    // Försök numerisk sort på name, annars seatId-suffix, annars vx/vy
    const parseKey = (seat) => {
      const num = parseFloat(seat.name);
      if (!Number.isNaN(num)) return { kind: "num", value: num };
      const parts = seat.seatId ? seat.seatId.split(".") : [];
      const last = parts[parts.length - 1];
      const lastNum = parseFloat(last);
      if (!Number.isNaN(lastNum)) return { kind: "num", value: lastNum };
      return { kind: "pos", value: seat.vx + seat.vy * 1e-3 };
    };
    return [...rowSeats].sort((a, b) => {
      const ka = parseKey(a);
      const kb = parseKey(b);
      if (ka.kind === "num" && kb.kind === "num") return ka.value - kb.value;
      if (ka.kind === "num") return -1;
      if (kb.kind === "num") return 1;
      return ka.value - kb.value;
    });
  }

  function getSeatDistanceRatios(rowSeats) {
    const sorted = sortSeatsInRow(rowSeats);
    const tMap = new Map();
    if (!sorted.length) return tMap;
    let total = 0;
    for (let i = 1; i < sorted.length; i++) {
      total += Math.hypot(sorted[i].vx - sorted[i - 1].vx, sorted[i].vy - sorted[i - 1].vy);
    }
    let dist = 0;
    tMap.set(sorted[0], 0);
    if (total <= 0) {
      return tMap;
    }
    for (let i = 1; i < sorted.length; i++) {
      dist += Math.hypot(sorted[i].vx - sorted[i - 1].vx, sorted[i].vy - sorted[i - 1].vy);
      tMap.set(sorted[i], dist / total);
    }
    return tMap;
  }

  function computeRowEndpoints(rowSeats) {
    const sorted = sortSeatsInRow(rowSeats);
    const first = sorted[0];
    const last = sorted[sorted.length - 1];
    return { first, last, order: sorted };
  }

  function redistributeRowLinear(rowData) {
    const { first, last, order } = rowData;
    const n = order.length;
    if (n <= 1) return;
    const dx = last.vx - first.vx;
    const dy = last.vy - first.vy;
    const denom = Math.max(n - 1, 1);
    for (let i = 0; i < n; i++) {
      const t = denom === 0 ? 0 : i / denom;
      const x = first.vx + dx * t;
      const y = first.vy + dy * t;
      const seat = order[i];
      seat.vx = x;
      seat.vy = y;
      seat.centerX = x;
      seat.centerY = y;
    }
  }

  function applyRowBend(rowData, rowId) {
    if (!bendControlPoint) {
      redistributeRowLinear(rowData);
      return;
    }
    bendRowsWithControl(bendControlPoint, [rowData]);
  }

  function bezierPoint(t, p0, p1, p2) {
    const u = 1 - t;
    const tt = t * t;
    const uu = u * u;
    const x = uu * p0.x + 2 * u * t * p1.x + tt * p2.x;
    const y = uu * p0.y + 2 * u * t * p1.y + tt * p2.y;
    return { x, y };
  }

  function lerpPoint(a, b, t) {
    return { x: a.x + (b.x - a.x) * t, y: a.y + (b.y - a.y) * t };
  }

  function polylinePoint(p0, p1, p2, targetLen, len0, len1) {
    const total = len0 + len1;
    if (total <= 0) return { x: p0.x, y: p0.y };
    if (len0 <= 0) {
      const t = len1 > 0 ? targetLen / len1 : 0;
      return lerpPoint(p1, p2, Math.max(0, Math.min(1, t)));
    }
    if (len1 <= 0) {
      const t = len0 > 0 ? targetLen / len0 : 0;
      return lerpPoint(p0, p1, Math.max(0, Math.min(1, t)));
    }
    if (targetLen <= len0) {
      const t = targetLen / len0;
      return lerpPoint(p0, p1, Math.max(0, Math.min(1, t)));
    }
    const t = (targetLen - len0) / len1;
    return lerpPoint(p1, p2, Math.max(0, Math.min(1, t)));
  }

  function rationalQuadPoint(t, p0, p1, p2, w) {
    const u = 1 - t;
    const b0 = u * u;
    const b1 = 2 * u * t * w;
    const b2 = t * t;
    const denom = b0 + b1 + b2 || 1e-6;
    const x = (b0 * p0.x + b1 * p1.x + b2 * p2.x) / denom;
    const y = (b0 * p0.y + b1 * p1.y + b2 * p2.y) / denom;
    return { x, y };
  }

  function buildRationalQuadArcTable(p0, p1, p2, w, steps = 160) {
    const table = [];
    let prev = p0;
    let length = 0;
    table.push({ t: 0, len: 0 });
    for (let i = 1; i <= steps; i++) {
      const t = i / steps;
      const pt = rationalQuadPoint(t, p0, p1, p2, w);
      const dx = pt.x - prev.x;
      const dy = pt.y - prev.y;
      length += Math.hypot(dx, dy);
      table.push({ t, len: length });
      prev = pt;
    }
    return { table, total: length };
  }

  function cubicPoint(t, p0, p1, p2, p3) {
    const u = 1 - t;
    const tt = t * t;
    const uu = u * u;
    const uuu = uu * u;
    const ttt = tt * t;
    const x = uuu * p0.x + 3 * uu * t * p1.x + 3 * u * tt * p2.x + ttt * p3.x;
    const y = uuu * p0.y + 3 * uu * t * p1.y + 3 * u * tt * p2.y + ttt * p3.y;
    return { x, y };
  }

  function buildBezierArcTable(p0, p1, p2, steps = 150) {
    const table = [];
    let prev = p0;
    let length = 0;
    table.push({ t: 0, len: 0 });
    for (let i = 1; i <= steps; i++) {
      const t = i / steps;
      const pt = bezierPoint(t, p0, p1, p2);
      const dx = pt.x - prev.x;
      const dy = pt.y - prev.y;
      length += Math.hypot(dx, dy);
      table.push({ t, len: length });
      prev = pt;
    }
    return { table, total: length };
  }

  function buildCubicArcTable(p0, p1, p2, p3, steps = 180) {
    const table = [];
    let prev = p0;
    let length = 0;
    table.push({ t: 0, len: 0 });
    for (let i = 1; i <= steps; i++) {
      const t = i / steps;
      const pt = cubicPoint(t, p0, p1, p2, p3);
      const dx = pt.x - prev.x;
      const dy = pt.y - prev.y;
      length += Math.hypot(dx, dy);
      table.push({ t, len: length });
      prev = pt;
    }
    return { table, total: length };
  }

  function tAtArcLength(targetLen, arcTable) {
    const { table, total } = arcTable;
    if (targetLen <= 0) return 0;
    if (targetLen >= total) return 1;
    // binary search
    let lo = 0, hi = table.length - 1;
    while (lo + 1 < hi) {
      const mid = Math.floor((lo + hi) / 2);
      if (table[mid].len < targetLen) lo = mid;
      else hi = mid;
    }
    const a = table[lo], b = table[hi];
    const span = b.len - a.len || 1e-6;
    const f = (targetLen - a.len) / span;
    return a.t + (b.t - a.t) * f;
  }

  function bendRowsWithControl(controlPoint, rowsData) {
    for (const rowData of rowsData) {
      const { first, last, order } = rowData;
      const n = order.length;
      if (n <= 2) continue;
      if (!controlPoint) {
        redistributeRowLinear(rowData);
        continue;
      }
      // single anchor -> quadratic curve
      const pts = [
        { x: first.vx, y: first.vy },
        { x: controlPoint.x, y: controlPoint.y },
        { x: last.vx, y: last.vy }
      ];
      const tension = Math.max(-4, Math.min(1, Number.isFinite(bendTension) ? bendTension : 0));
      const len0 = Math.hypot(pts[1].x - pts[0].x, pts[1].y - pts[0].y);
      const len1 = Math.hypot(pts[2].x - pts[1].x, pts[2].y - pts[1].y);
      const polyTotal = len0 + len1 || 1e-6;
      if (tension <= 0) {
        const weight = Math.max(0.01, Math.exp(tension));
        const arc = buildRationalQuadArcTable(pts[0], pts[1], pts[2], weight);
        for (let i = 0; i < n; i++) {
          const tNorm = (n - 1) === 0 ? 0 : i / (n - 1);
          const targetLen = arc.total * tNorm;
          const t = tAtArcLength(targetLen, arc);
          const pt = rationalQuadPoint(t, pts[0], pts[1], pts[2], weight);
          const seat = order[i];
          seat.vx = pt.x;
          seat.vy = pt.y;
          seat.centerX = pt.x;
          seat.centerY = pt.y;
        }
      } else {
        const arc = buildBezierArcTable(pts[0], pts[1], pts[2]);
        for (let i = 0; i < n; i++) {
          const tNorm = (n - 1) === 0 ? 0 : i / (n - 1);
          const targetQuadLen = arc.total * tNorm;
          const t = tAtArcLength(targetQuadLen, arc);
          const quadPt = bezierPoint(t, pts[0], pts[1], pts[2]);
          const targetPolyLen = polyTotal * tNorm;
          const polyPt = polylinePoint(pts[0], pts[1], pts[2], targetPolyLen, len0, len1);
          const pt = lerpPoint(quadPt, polyPt, tension);
          const seat = order[i];
          seat.vx = pt.x;
          seat.vy = pt.y;
          seat.centerX = pt.x;
          seat.centerY = pt.y;
        }
      }
    }
  }

  function resetSelectedRowsLinear() {
    const rows = getSelectedRows();
    if (!rows.size) return false;
    let changed = false;
    for (const [, rowSeats] of rows) {
      if (rowSeats.length < 2) continue;
      const data = computeRowEndpoints(rowSeats);
      redistributeRowLinear(data);
      changed = true;
    }
    return changed;
  }

  function applyReshapeDrag(target, newX, newY, shiftSnap = false) {
    if (!reshapeRowSeats || !reshapeRowSeats.length || !reshapeSnapshotById) return;
    const sorted = sortSeatsInRow(reshapeRowSeats);
    if (!sorted.length) return;

    const cumulative = shiftSnap ? getRowCumulativeDistances(sorted, reshapeSnapshotById) : null;

    const pivotIndex = reshapePivotSeatId
      ? sorted.findIndex(s => s.seatId === reshapePivotSeatId)
      : -1;

    const startSnap = reshapeSnapshotById.get(sorted[0].seatId);
    const endSnap = reshapeSnapshotById.get(sorted[sorted.length - 1].seatId);
    if (!startSnap || !endSnap) return;

    if (target === "start") {
      const anchorSnap = pivotIndex >= 0
        ? reshapeSnapshotById.get(sorted[pivotIndex].seatId) || endSnap
        : endSnap;
      const segLen = pivotIndex >= 0 ? pivotIndex : sorted.length - 1;
      let endX = newX;
      let endY = newY;
      if (shiftSnap) {
        const dx = newX - anchorSnap.vx;
        const dy = newY - anchorSnap.vy;
        const angle = Math.atan2(dy, dx);
        const dist = Math.hypot(dx, dy);
        const snapStep = (5 * Math.PI) / 180;
        const snapped = Math.round(angle / snapStep) * snapStep;
        const anchorIndex = pivotIndex >= 0 ? pivotIndex : (sorted.length - 1);
        const totalDist = cumulative
          ? Math.abs(cumulative[0] - cumulative[anchorIndex])
          : dist;
        endX = anchorSnap.vx + Math.cos(snapped) * totalDist;
        endY = anchorSnap.vy + Math.sin(snapped) * totalDist;
      }
      const dirX = endX - anchorSnap.vx;
      const dirY = endY - anchorSnap.vy;
      const dirLen = Math.hypot(dirX, dirY) || 1e-6;
      const dirUnitX = dirX / dirLen;
      const dirUnitY = dirY / dirLen;
      for (let i = 0; i < sorted.length; i++) {
        if (pivotIndex >= 0 && i > pivotIndex) {
          const snap = reshapeSnapshotById.get(sorted[i].seatId);
          if (snap) {
            sorted[i].vx = snap.vx;
            sorted[i].vy = snap.vy;
            sorted[i].centerX = snap.vx;
            sorted[i].centerY = snap.vy;
          }
          continue;
        }
        let x;
        let y;
        if (shiftSnap && cumulative) {
          const anchorIndex = pivotIndex >= 0 ? pivotIndex : (sorted.length - 1);
          const distFromAnchor = Math.abs(cumulative[i] - cumulative[anchorIndex]);
          x = anchorSnap.vx + dirUnitX * distFromAnchor;
          y = anchorSnap.vy + dirUnitY * distFromAnchor;
        } else {
          const t = segLen === 0 ? 0 : i / segLen;
          x = endX + (anchorSnap.vx - endX) * t;
          y = endY + (anchorSnap.vy - endY) * t;
        }
        sorted[i].vx = x;
        sorted[i].vy = y;
        sorted[i].centerX = x;
        sorted[i].centerY = y;
      }
    } else if (target === "end") {
      const anchorSnap = pivotIndex >= 0
        ? reshapeSnapshotById.get(sorted[pivotIndex].seatId) || startSnap
        : startSnap;
      const startIndex = pivotIndex >= 0 ? pivotIndex : 0;
      const segLen = pivotIndex >= 0 ? (sorted.length - 1 - pivotIndex) : (sorted.length - 1);
      let endX = newX;
      let endY = newY;
      if (shiftSnap) {
        const dx = newX - anchorSnap.vx;
        const dy = newY - anchorSnap.vy;
        const angle = Math.atan2(dy, dx);
        const dist = Math.hypot(dx, dy);
        const snapStep = (5 * Math.PI) / 180;
        const snapped = Math.round(angle / snapStep) * snapStep;
        const anchorIndex = pivotIndex >= 0 ? pivotIndex : 0;
        const endIndex = sorted.length - 1;
        const totalDist = cumulative
          ? Math.abs(cumulative[endIndex] - cumulative[anchorIndex])
          : dist;
        endX = anchorSnap.vx + Math.cos(snapped) * totalDist;
        endY = anchorSnap.vy + Math.sin(snapped) * totalDist;
      }
      const dirX = endX - anchorSnap.vx;
      const dirY = endY - anchorSnap.vy;
      const dirLen = Math.hypot(dirX, dirY) || 1e-6;
      const dirUnitX = dirX / dirLen;
      const dirUnitY = dirY / dirLen;
      for (let i = 0; i < sorted.length; i++) {
        if (i < startIndex) {
          const snap = reshapeSnapshotById.get(sorted[i].seatId);
          if (snap) {
            sorted[i].vx = snap.vx;
            sorted[i].vy = snap.vy;
            sorted[i].centerX = snap.vx;
            sorted[i].centerY = snap.vy;
          }
          continue;
        }
        let x;
        let y;
        if (shiftSnap && cumulative) {
          const anchorIndex = pivotIndex >= 0 ? pivotIndex : 0;
          const distFromAnchor = Math.abs(cumulative[i] - cumulative[anchorIndex]);
          x = anchorSnap.vx + dirUnitX * distFromAnchor;
          y = anchorSnap.vy + dirUnitY * distFromAnchor;
        } else {
          const t = segLen === 0 ? 0 : (i - startIndex) / segLen;
          x = anchorSnap.vx + (endX - anchorSnap.vx) * t;
          y = anchorSnap.vy + (endY - anchorSnap.vy) * t;
        }
        sorted[i].vx = x;
        sorted[i].vy = y;
        sorted[i].centerX = x;
        sorted[i].centerY = y;
      }
    }
  }

  function getRowCumulativeDistances(sorted, snapshotMap) {
    const cumulative = new Array(sorted.length).fill(0);
    for (let i = 1; i < sorted.length; i++) {
      const prev = snapshotMap.get(sorted[i - 1].seatId);
      const curr = snapshotMap.get(sorted[i].seatId);
      if (!prev || !curr) {
        cumulative[i] = cumulative[i - 1];
        continue;
      }
      const d = Math.hypot(curr.vx - prev.vx, curr.vy - prev.vy);
      cumulative[i] = cumulative[i - 1] + d;
    }
    return cumulative;
  }

  function getAlignGroups() {
    const selected = getSelectedSeats();
    if (!selected.length) return [];

    const groups = [];
    const pushGroup = (seatsArr) => {
      const b = getSelectionBounds(seatsArr);
      if (!b) return;
      let order = 0;
      for (const s of seatsArr) {
        const value = typeof s.selectedAt === "number" ? s.selectedAt : 0;
        if (value > order) order = value;
      }
      groups.push({ seats: seatsArr, bounds: b, order });
    };

    if (selectionMode === "section") {
      const bySection = new Map();
      for (const s of selected) {
        if (!s.sectionId) continue;
        if (!bySection.has(s.sectionId)) bySection.set(s.sectionId, []);
        bySection.get(s.sectionId).push(s);
      }
      for (const seatsArr of bySection.values()) {
        pushGroup(seatsArr);
      }
    } else if (selectionMode === "row") {
      const byRow = new Map();
      for (const s of selected) {
        if (!s.rowId) continue;
        if (!byRow.has(s.rowId)) byRow.set(s.rowId, []);
        byRow.get(s.rowId).push(s);
      }
      for (const seatsArr of byRow.values()) {
        pushGroup(seatsArr);
      }
    } else {
      for (const s of selected) {
        groups.push({
          seats: [s],
          bounds: { minX: s.vx, maxX: s.vx, minY: s.vy, maxY: s.vy, centerX: s.vx, centerY: s.vy },
          order: typeof s.selectedAt === "number" ? s.selectedAt : 0
        });
      }
    }
    return groups;
  }

  function getAlignAnchorGroupByMode(groups, mode, selectionBounds) {
    if (!groups.length) return null;
    const pickValue = (group) => {
      switch (mode) {
        case "left":
          return group.bounds.minX;
        case "right":
          return group.bounds.maxX;
        case "top":
          return group.bounds.minY;
        case "bottom":
          return group.bounds.maxY;
        case "centerH":
          return group.bounds.centerX;
        case "centerV":
          return group.bounds.centerY;
        default:
          return null;
      }
    };
    const targetValue = (mode === "centerH" || mode === "centerV")
      ? (selectionBounds ? (mode === "centerH" ? selectionBounds.centerX : selectionBounds.centerY) : null)
      : null;
    let best = groups[0];
    let bestValue = pickValue(best);
    let bestDistance = null;
    if (targetValue != null && Number.isFinite(bestValue)) {
      bestDistance = Math.abs(bestValue - targetValue);
    }
    for (let i = 1; i < groups.length; i++) {
      const current = groups[i];
      const value = pickValue(current);
      if (!Number.isFinite(value) || !Number.isFinite(bestValue)) {
        if (Number.isFinite(value) && !Number.isFinite(bestValue)) {
          best = current;
          bestValue = value;
          if (targetValue != null) {
            bestDistance = Math.abs(value - targetValue);
          }
        }
        continue;
      }
      if (mode === "centerH" || mode === "centerV") {
        const distance = targetValue != null ? Math.abs(value - targetValue) : null;
        if (
          distance != null &&
          (bestDistance == null || distance < bestDistance || (distance === bestDistance && current.order >= best.order))
        ) {
          best = current;
          bestValue = value;
          bestDistance = distance;
        }
      } else if (mode === "left" || mode === "top") {
        if (value < bestValue || (value === bestValue && current.order >= best.order)) {
          best = current;
          bestValue = value;
        }
      } else {
        if (value > bestValue || (value === bestValue && current.order >= best.order)) {
          best = current;
          bestValue = value;
        }
      }
    }
    return best;
  }

  function alignSelectedSeats(mode) {
    const selected = getSelectedSeats();
    if (selected.length < 2) return false;

    const groups = getAlignGroups();
    if (groups.length < 2) return false;

    let anchorGroup = null;
    const isBoxMode = mode === "left" || mode === "right" || mode === "top" || mode === "bottom" || mode === "centerH" || mode === "centerV";
    if (lastSelectionSource === "box" && isBoxMode) {
      const selectionBounds = getSelectionBounds(selected);
      anchorGroup = getAlignAnchorGroupByMode(groups, mode, selectionBounds);
    } else {
      const anchorSeat = getSelectionAnchorSeat(selected);
      if (anchorSeat) {
        anchorGroup = groups.find(g => g.seats.some(s => s.seatId === anchorSeat.seatId)) || null;
      }
      if (!anchorGroup) {
        anchorGroup = groups.reduce((best, g) => (g.order >= best.order ? g : best), groups[0]);
      }
    }
    if (!anchorGroup) return false;

    const target = anchorGroup.bounds;

    if (alignGroupingMode === "group") {
      const movableSeats = [];
      for (const g of groups) {
        if (g === anchorGroup) continue;
        movableSeats.push(...g.seats);
      }
      if (!movableSeats.length) return false;
      const movableBounds = getSelectionBounds(movableSeats);
      if (!movableBounds) return false;

      let deltaX = 0;
      let deltaY = 0;
      switch (mode) {
        case "top":
          deltaY = target.minY - movableBounds.minY;
          break;
        case "bottom":
          deltaY = target.maxY - movableBounds.maxY;
          break;
        case "left":
          deltaX = target.minX - movableBounds.minX;
          break;
        case "right":
          deltaX = target.maxX - movableBounds.maxX;
          break;
        case "centerH":
          deltaX = target.centerX - movableBounds.centerX;
          break;
        case "centerV":
          deltaY = target.centerY - movableBounds.centerY;
          break;
        default:
          break;
      }
      if (deltaX !== 0 || deltaY !== 0) {
        for (const s of movableSeats) {
          s.vx += deltaX;
          s.vy += deltaY;
          s.centerX += deltaX;
          s.centerY += deltaY;
        }
        return true;
      }
      return false;
    }

    let changed = false;
    for (const g of groups) {
      if (g === anchorGroup) continue;
      let deltaX = 0;
      let deltaY = 0;
      switch (mode) {
        case "top":
          deltaY = target.minY - g.bounds.minY;
          break;
        case "bottom":
          deltaY = target.maxY - g.bounds.maxY;
          break;
        case "left":
          deltaX = target.minX - g.bounds.minX;
          break;
        case "right":
          deltaX = target.maxX - g.bounds.maxX;
          break;
        case "centerH":
          deltaX = target.centerX - g.bounds.centerX;
          break;
        case "centerV":
          deltaY = target.centerY - g.bounds.centerY;
          break;
        default:
          break;
      }
      if (deltaX !== 0 || deltaY !== 0) {
        changed = true;
        for (const s of g.seats) {
          s.vx += deltaX;
          s.vy += deltaY;
          s.centerX += deltaX;
          s.centerY += deltaY;
        }
      }
    }
    return changed;
  }
function nudgeSelection(dxScreen, dyScreen) {
    const selected = getSelectedSeats();
    if (!selected.length) return false;
    const dxWorld = dxScreen / scale;
    const dyWorld = dyScreen / scale;
    let moved = false;
    for (const s of selected) {
      const newX = s.vx + dxWorld;
      const newY = s.vy + dyWorld;
      if (newX !== s.vx || newY !== s.vy) {
        s.vx = newX;
        s.vy = newY;
        s.centerX = newX;
        s.centerY = newY;
        moved = true;
      }
    }
    return moved;
  }

  function makeTableFromSelectedRows() {
    const rows = getSelectedRows();
    if (!rows.size) return false;
    let changed = false;
    for (const [, rowSeats] of rows) {
      if (rowSeats.length < 2) continue;
      const sorted = sortSeatsInRow(rowSeats);
      const first = sorted[0];
      let dirX = 1, dirY = 0, spacing = 50;
      if (sorted.length > 1) {
        const second = sorted[1];
        const dx = second.vx - first.vx;
        const dy = second.vy - first.vy;
        const dist = Math.hypot(dx, dy);
        if (dist > 1e-3) {
          dirX = dx / dist;
          dirY = dy / dist;
          spacing = dist;
        }
      }
      const perpX = -dirY;
      const perpY = dirX;
      const stepDown = spacing * 1.2;

      for (let i = 0; i < sorted.length; i++) {
        const col = i % 2;
        const row = Math.floor(i / 2);
        const x = first.vx + dirX * spacing * col + perpX * stepDown * row;
        const y = first.vy + dirY * spacing * col + perpY * stepDown * row;
        const seat = sorted[i];
        seat.vx = x;
        seat.vy = y;
        seat.centerX = x;
        seat.centerY = y;
      }
      changed = true;
    }
    return changed;
  }

  function equalizeRowDistanceForSelection() {
    const rows = getSelectedRows();
    if (rows.size < 2) return false;

    const rowInfos = [];
    let sumX = 0;
    let sumY = 0;
    let dirCount = 0;
    let refDir = null;

    for (const [rowId, rowSeats] of rows.entries()) {
      if (!rowSeats || !rowSeats.length) continue;
      const center = computeRowCenter(rowSeats);
      const dir = computeRowDirection(rowSeats);
      if (dir) {
        if (!refDir) {
          refDir = { ...dir };
        } else if (dir.x * refDir.x + dir.y * refDir.y < 0) {
          dir.x = -dir.x;
          dir.y = -dir.y;
        }
        sumX += dir.x;
        sumY += dir.y;
        dirCount += 1;
      }
      rowInfos.push({ rowId, seats: rowSeats, center });
    }

    if (rowInfos.length < 2) return false;

    let dirX = 1;
    let dirY = 0;
    if (dirCount > 0) {
      dirX = sumX / dirCount;
      dirY = sumY / dirCount;
      const len = Math.hypot(dirX, dirY);
      if (len > 1e-3) {
        dirX /= len;
        dirY /= len;
      } else {
        dirX = 1;
        dirY = 0;
      }
    }
    const normX = -dirY;
    const normY = dirX;

    rowInfos.forEach((info) => {
      info.projection = info.center.x * normX + info.center.y * normY;
    });
    rowInfos.sort((a, b) => a.projection - b.projection);

    const first = rowInfos[0].projection;
    const last = rowInfos[rowInfos.length - 1].projection;
    const span = last - first;
    if (!Number.isFinite(span) || Math.abs(span) < 1e-6) return false;
    const gap = span / (rowInfos.length - 1);
    if (!Number.isFinite(gap)) return false;

    let changed = false;
    rowInfos.forEach((info, idx) => {
      const target = first + gap * idx;
      const delta = target - info.projection;
      if (Math.abs(delta) < 1e-6) return;
      const dx = normX * delta;
      const dy = normY * delta;
      info.seats.forEach((seat) => {
        seat.vx += dx;
        seat.vy += dy;
        seat.centerX += dx;
        seat.centerY += dy;
      });
      changed = true;
    });

    return changed;
  }

  function buildRowShapeTemplate(rowSeats) {
    if (!rowSeats || rowSeats.length < 2) return null;
    const sorted = sortSeatsInRow(rowSeats);
    const first = sorted[0];
    const last = sorted[sorted.length - 1];
    const dx = last.vx - first.vx;
    const dy = last.vy - first.vy;
    const length = Math.hypot(dx, dy);
    if (!Number.isFinite(length) || length < 1e-6) return null;
    const dir = { x: dx / length, y: dy / length };
    const perp = { x: -dir.y, y: dir.x };
    const points = sorted.map((seat) => {
      const relX = seat.vx - first.vx;
      const relY = seat.vy - first.vy;
      const t = (relX * dir.x + relY * dir.y) / length;
      const offset = relX * perp.x + relY * perp.y;
      return { t, offset };
    }).sort((a, b) => a.t - b.t);
    return { points, length };
  }

  function getOffsetAt(points, t) {
    if (!points || points.length === 0) return 0;
    if (t <= points[0].t) return points[0].offset;
    const last = points[points.length - 1];
    if (t >= last.t) return last.offset;
    for (let i = 1; i < points.length; i++) {
      const prev = points[i - 1];
      const next = points[i];
      if (t <= next.t) {
        const span = next.t - prev.t || 1e-6;
        const f = (t - prev.t) / span;
        return prev.offset + (next.offset - prev.offset) * f;
      }
    }
    return last.offset;
  }

  function applyRowShapeTemplate(template, rowSeats) {
    if (!template || !rowSeats || rowSeats.length < 2) return false;
    const sorted = sortSeatsInRow(rowSeats);
    const tMap = getSeatDistanceRatios(sorted);
    const first = sorted[0];
    const last = sorted[sorted.length - 1];
    const dx = last.vx - first.vx;
    const dy = last.vy - first.vy;
    const length = Math.hypot(dx, dy);
    if (!Number.isFinite(length) || length < 1e-6) return false;
    const dir = { x: dx / length, y: dy / length };
    const perp = { x: -dir.y, y: dir.x };
    const scale = template.length > 1e-6 ? (length / template.length) : 1;
    let changed = false;
    for (const seat of sorted) {
      let t = tMap.get(seat);
      if (!Number.isFinite(t)) {
        const relX = seat.vx - first.vx;
        const relY = seat.vy - first.vy;
        t = (relX * dir.x + relY * dir.y) / length;
      }
      if (!Number.isFinite(t)) t = 0;
      t = Math.max(0, Math.min(1, t));
      const offset = getOffsetAt(template.points, t) * scale;
      const baseX = first.vx + dir.x * (t * length);
      const baseY = first.vy + dir.y * (t * length);
      const newX = baseX + perp.x * offset;
      const newY = baseY + perp.y * offset;
      if (Math.abs(seat.vx - newX) > 1e-6 || Math.abs(seat.vy - newY) > 1e-6) {
        seat.vx = newX;
        seat.vy = newY;
        seat.centerX = newX;
        seat.centerY = newY;
        changed = true;
      }
    }
    return changed;
  }

  function mimicShapeOfFirstSelectedRow() {
    if (selectionMode !== "row") return false;
    const rows = getSelectedRows();
    if (rows.size < 2) return false;
    const ordered = [];
    rows.forEach((rowSeats, rowId) => {
      const minSelected = rowSeats.reduce((acc, seat) => {
        const val = Number.isFinite(seat.selectedAt) ? seat.selectedAt : Infinity;
        return Math.min(acc, val);
      }, Infinity);
      ordered.push({ rowId, rowSeats, minSelected });
    });
    ordered.sort((a, b) => {
      if (a.minSelected !== b.minSelected) return a.minSelected - b.minSelected;
      return String(a.rowId).localeCompare(String(b.rowId));
    });
    const source = ordered[0];
    const template = buildRowShapeTemplate(source?.rowSeats || []);
    if (!template) return false;
    let changed = false;
    for (let i = 1; i < ordered.length; i++) {
      const entry = ordered[i];
      if (!entry.rowSeats || entry.rowSeats.length < 2) continue;
      const didApply = applyRowShapeTemplate(template, entry.rowSeats);
      if (didApply) changed = true;
    }
    return changed;
  }

  function mergeSelectedRows() {
    if (selectionMode !== "row") return false;
    const rows = getSelectedRows();
    if (rows.size < 2) return false;

    let sectionId = null;
    let sameSection = true;
    rows.forEach((rowSeats) => {
      const rowSection = rowSeats[0]?.sectionId || "";
      if (!rowSection) sameSection = false;
      if (!sectionId) sectionId = rowSection;
      else if (sectionId !== rowSection) sameSection = false;
    });
    if (!sameSection || !sectionId) return false;

    const rowInfos = [];
    rows.forEach((rowSeats, rowId) => {
      rowInfos.push({
        rowId,
        seats: rowSeats,
        order: getRowSelectionOrder(rowSeats)
      });
    });
    rowInfos.sort((a, b) => {
      if (a.order !== b.order) return a.order - b.order;
      return a.rowId.localeCompare(b.rowId);
    });

    const keepInfo = rowInfos[0];
    if (!keepInfo) return false;
    const keepRowId = keepInfo.rowId;
    const keepRowSeats = keepInfo.seats;
    const keepRowName = keepRowSeats[0]?.rowName || keepRowId;
    const keepSectionName = keepRowSeats[0]?.sectionName || sectionNames.get(sectionId) || sectionId;

    let maxSeatSuffix = 0;
    keepRowSeats.forEach((seat) => {
      const parts = seat.seatId ? seat.seatId.split(".") : [];
      const last = parts[parts.length - 1];
      const num = parseInt(last, 10);
      if (Number.isFinite(num)) maxSeatSuffix = Math.max(maxSeatSuffix, num);
    });
    if (!maxSeatSuffix) maxSeatSuffix = keepRowSeats.length;
    let nextSuffix = maxSeatSuffix + 1;

    const seatIdMap = new Map();
    const rowIdMap = new Map();
    const rowsToRemove = new Set();
    const orderedMovedSeats = [];

    rowInfos.slice(1).forEach((info) => {
      rowsToRemove.add(info.rowId);
      rowIdMap.set(info.rowId, keepRowId);
      const sorted = sortSeatsInRow(info.seats);
      sorted.forEach((seat) => {
        const oldId = seat.seatId;
        const newId = `${keepRowId}.${nextSuffix++}`;
        seatIdMap.set(oldId, newId);
        seat.seatId = newId;
        seat.rowId = keepRowId;
        seat.rowName = keepRowName;
        seat.sectionId = sectionId;
        seat.sectionName = keepSectionName;
        orderedMovedSeats.push(seat);
      });
    });

    if (!orderedMovedSeats.length) return false;

    const removedIndexes = [];
    originalLines = originalLines.filter((line, idx) => {
      if (line.includes("|RowAdd|")) {
        const rowMatch = line.match(/RowId=([^|]+)/);
        if (rowMatch && rowsToRemove.has(rowMatch[1])) {
          removedIndexes.push(idx);
          return false;
        }
      }
      if (line.includes("|SeatAdd|")) {
        const seatMatch = line.match(/SeatId=([^|]+)/);
        if (seatMatch && seatIdMap.has(seatMatch[1])) {
          removedIndexes.push(idx);
          return false;
        }
      }
      return true;
    });
    shiftOutlineLineIndexesAfterRemoval(removedIndexes);
    rebuildSeatLineIndex();

    const insertIndex = findRowInsertIndex(keepRowId, keepRowSeats);
    const insertAt = insertIndex >= 0 ? insertIndex + 1 : originalLines.length;
    const newLines = orderedMovedSeats.map(seat => buildSeatLine(seat));
    shiftOutlineLineIndexes(insertAt, newLines.length);
    originalLines.splice(insertAt, 0, ...newLines);

    if (lastSelectedSeatId && seatIdMap.has(lastSelectedSeatId)) {
      lastSelectedSeatId = seatIdMap.get(lastSelectedSeatId);
    }

    rebuildSeatLineIndex();

    let priceRegionChanged = false;
    if (seatIdMap.size || rowIdMap.size) {
      const remapValues = (values, map) => {
        if (!Array.isArray(values) || !values.length) return { next: values, changed: false };
        const seen = new Set();
        const next = [];
        let changed = false;
        values.forEach((val) => {
          const mapped = map.get(val) || val;
          if (mapped !== val) changed = true;
          if (!seen.has(mapped)) {
            seen.add(mapped);
            next.push(mapped);
          } else if (mapped !== val) {
            changed = true;
          }
        });
        return { next, changed };
      };
      priceRegions.forEach((region) => {
        const seatRes = remapValues(region.seats, seatIdMap);
        if (seatRes.changed) {
          region.seats = seatRes.next;
          priceRegionChanged = true;
        }
        const rowRes = remapValues(region.rows, rowIdMap);
        if (rowRes.changed) {
          region.rows = rowRes.next;
          priceRegionChanged = true;
        }
      });
    }

    if (priceRegionChanged) {
      savePriceRegionsToStorage();
      renderPriceRegionList();
      updatePriceRegionUi();
    }
    updatePriceRegionStatus();
    updateCodeFromSeats();
    const newText = originalLines.join("\n");
    if (codePane.value !== newText) {
      codePane.value = newText;
    }
    renderCanvas();
    updateEntryPointUi();
    hasUnsavedChanges = true;
    updateSaveButton();
    saveSessionToLocalStorage();
    pushHistorySnapshot();
    return true;
  }

  function splitRowAtSelection() {
    if (selectionMode !== "seat") return false;
    const selected = getSelectedSeats();
    const info = getSplitRowSelectionInfo(selected);
    if (!info) return false;

    const rowParts = parseRowIdParts(info.rowId);
    if (!Number.isFinite(rowParts.row)) return false;
    const rowNumber = rowParts.row;
    const newRowNumber = rowNumber + 1;
    const sectionId = info.sectionId;
    const newRowId = `${sectionId}.${newRowNumber}`;

    const rowSeats = seats.filter(s => s.rowId === info.rowId);
    if (!rowSeats.length) return false;

    const seatsToMove = rowSeats.filter((seat) => {
      const suffix = getSeatIdSuffix(seat.seatId);
      return Number.isFinite(suffix) && suffix >= info.highSeatSuffix;
    });
    if (!seatsToMove.length) return false;
    const rowName = rowSeats[0]?.rowName || info.rowId;
    const sectionName = rowSeats[0]?.sectionName || sectionNames.get(sectionId) || sectionId;

    const rowNumberById = new Map();
    seats.forEach((seat) => {
      if (seat.sectionId !== sectionId || !seat.rowId) return;
      if (rowNumberById.has(seat.rowId)) return;
      const parts = parseRowIdParts(seat.rowId);
      if (Number.isFinite(parts.row)) rowNumberById.set(seat.rowId, parts.row);
    });

    const rowIdMap = new Map();
    rowNumberById.forEach((num, rowId) => {
      if (num >= newRowNumber) {
        rowIdMap.set(rowId, `${sectionId}.${num + 1}`);
      }
    });

    const seatIdMap = new Map();
    seats.forEach((seat) => {
      if (seat.sectionId !== sectionId || !seat.rowId) return;
      const suffix = getSeatIdSuffix(seat.seatId);
      if (!Number.isFinite(suffix)) return;
      if (seat.rowId === info.rowId && suffix >= info.highSeatSuffix) {
        seatIdMap.set(seat.seatId, `${newRowId}.${suffix}`);
      } else if (rowIdMap.has(seat.rowId)) {
        const mappedRowId = rowIdMap.get(seat.rowId);
        seatIdMap.set(seat.seatId, `${mappedRowId}.${suffix}`);
      }
    });

    seats.forEach((seat) => {
      if (seat.sectionId !== sectionId || !seat.rowId) return;
      const suffix = getSeatIdSuffix(seat.seatId);
      if (!Number.isFinite(suffix)) return;
      if (seat.rowId === info.rowId && suffix >= info.highSeatSuffix) {
        const nextSeatId = seatIdMap.get(seat.seatId) || seat.seatId;
        seat.rowId = newRowId;
        seat.rowName = rowName;
        seat.sectionName = sectionName;
        seat.seatId = nextSeatId;
      } else if (rowIdMap.has(seat.rowId)) {
        const nextRowId = rowIdMap.get(seat.rowId);
        const nextSeatId = seatIdMap.get(seat.seatId) || seat.seatId;
        seat.rowId = nextRowId;
        seat.sectionName = sectionName;
        seat.seatId = nextSeatId;
      }
    });

    rebuildSectionRowsInLines(sectionId);

    if (lastSelectedSeatId && seatIdMap.has(lastSelectedSeatId)) {
      lastSelectedSeatId = seatIdMap.get(lastSelectedSeatId);
    }

    let priceRegionChanged = false;
    if (seatIdMap.size || rowIdMap.size) {
      const remapValues = (values, map) => {
        if (!Array.isArray(values) || !values.length) return { next: values, changed: false };
        const seen = new Set();
        const next = [];
        let changed = false;
        values.forEach((val) => {
          const mapped = map.get(val) || val;
          if (mapped !== val) changed = true;
          if (!seen.has(mapped)) {
            seen.add(mapped);
            next.push(mapped);
          } else if (mapped !== val) {
            changed = true;
          }
        });
        return { next, changed };
      };
      priceRegions.forEach((region) => {
        const seatRes = remapValues(region.seats, seatIdMap);
        if (seatRes.changed) {
          region.seats = seatRes.next;
          priceRegionChanged = true;
        }
        const rowRes = remapValues(region.rows, rowIdMap);
        if (rowRes.changed) {
          region.rows = rowRes.next;
          priceRegionChanged = true;
        }
        if (Array.isArray(region.rows) && region.rows.includes(info.rowId) && !region.rows.includes(newRowId)) {
          region.rows.push(newRowId);
          priceRegionChanged = true;
        }
      });
    }

    if (priceRegionChanged) {
      savePriceRegionsToStorage();
      renderPriceRegionList();
      updatePriceRegionUi();
    }
    updatePriceRegionStatus();
    updateEntryPointUi();
    updateCodeFromSeats();
    const newText = originalLines.join("\n");
    if (codePane.value !== newText) {
      codePane.value = newText;
    }
    renderCanvas();
    hasUnsavedChanges = true;
    updateSaveButton();
    saveSessionToLocalStorage();
    pushHistorySnapshot();
    return true;
  }

  function ensureBendDefaults() {
    if (currentTool !== "bend") return;
    const rows = getSelectedRows();
    if (rows.size !== 1) return;
    const rowSeats = rows.values().next().value;
    if (!rowSeats || rowSeats.length < 2) return;
    const data = computeRowEndpoints(rowSeats);
    const rowId = rowSeats[0].rowId || null;
    const mid = { x: (data.first.vx + data.last.vx) / 2, y: (data.first.vy + data.last.vy) / 2 };

    if (bendActiveRowId !== rowId) {
      bendControlPoint = mid;
      bendActiveRowId = rowId;
    } else {
      if (!bendControlPoint) bendControlPoint = mid;
    }
  }

  function getRowAxisVectors(rowData) {
    if (!rowData) return null;
    const dx = rowData.last.vx - rowData.first.vx;
    const dy = rowData.last.vy - rowData.first.vy;
    const len = Math.hypot(dx, dy);
    if (!Number.isFinite(len) || len === 0) return null;
    const dir = { x: dx / len, y: dy / len };
    const perp = { x: -dir.y, y: dir.x };
    const mid = { x: (rowData.first.vx + rowData.last.vx) / 2, y: (rowData.first.vy + rowData.last.vy) / 2 };
    return { mid, dir, perp };
  }

  function getResizeHandles(bounds) {
    const { minX, maxX, minY, maxY, centerX, centerY } = bounds;
    return [
      { id: "nw", x: minX, y: minY },
      { id: "n",  x: centerX, y: minY },
      { id: "ne", x: maxX, y: minY },
      { id: "e",  x: maxX, y: centerY },
      { id: "se", x: maxX, y: maxY },
      { id: "s",  x: centerX, y: maxY },
      { id: "sw", x: minX, y: maxY },
      { id: "w",  x: minX, y: centerY }
    ];
  }



  // --- Hit-test ---
  function hitTestSeat(worldX, worldY) {
    if (!seats.length) return null;
    const baseR = BASE_WORLD_RADIUS;
    const maxDist = baseR * 1.5;
    let best = null;
    let bestDist2 = Infinity;

    for (const s of seats) {
      const dx = worldX - s.vx;
      const dy = worldY - s.vy;
      const d2 = dx * dx + dy * dy;
      if (d2 < maxDist * maxDist && d2 < bestDist2) {
        bestDist2 = d2;
        best = s;
      }
    }
    return best;
  }

  // --- Markerings-läge: vilken grupp hör en klickad plats till? ---
  function getGroupForSeat(seat) {
    if (!seat) return [];
    if (selectionMode === "seat") {
      return [seat];
    } else if (selectionMode === "row") {
      return seats.filter(s => s.rowId && s.rowId === seat.rowId);
    } else if (selectionMode === "section") {
      return seats.filter(s => s.sectionId && s.sectionId === seat.sectionId);
    }
    return [seat];
  }

  // --- Markerings-ruta beroende på läge ---
  function selectByRect(rectWorld, additive) {
    const { minX, maxX, minY, maxY } = rectWorld;

    let selectionChanged = false;
    if (!additive) {
      const hadSelection = seats.some(s => s.selected);
      clearSelectionSeats(seats);
      lastSelectedSeatId = null;
      selectionChanged = hadSelection;
    }

    if (selectionMode === "seat") {
      for (const s of seats) {
        if (
          s.vx >= minX && s.vx <= maxX &&
          s.vy >= minY && s.vy <= maxY
        ) {
          if (!s.selected) {
            s.selected = true;
            s.selectedAt = selectionOrderCounter++;
            selectionChanged = true;
          }
        }
      }
    } else if (selectionMode === "row") {
      const rowsInside = new Set();
      for (const s of seats) {
        if (
          s.vx >= minX && s.vx <= maxX &&
          s.vy >= minY && s.vy <= maxY &&
          s.rowId
        ) {
          rowsInside.add(s.rowId);
        }
      }
      for (const s of seats) {
        if (rowsInside.has(s.rowId)) {
          if (!s.selected) {
            s.selected = true;
            s.selectedAt = selectionOrderCounter++;
            selectionChanged = true;
          }
        }
      }
    } else if (selectionMode === "section") {
      const sectInside = new Set();
      for (const s of seats) {
        if (
          s.vx >= minX && s.vx <= maxX &&
          s.vy >= minY && s.vy <= maxY &&
          s.sectionId
        ) {
          sectInside.add(s.sectionId);
        }
      }
      for (const s of seats) {
        if (sectInside.has(s.sectionId)) {
          if (!s.selected) {
            s.selected = true;
            s.selectedAt = selectionOrderCounter++;
            selectionChanged = true;
          }
        }
      }
    }

    if (selectionChanged) {
      lastSelectionSource = "box";
      refreshSelectionAnchorFromOrder();
      pushHistorySnapshot();     // markering i historiken
      updateMoveButtonState();
      renderCanvas();
    }
  }
// --- Zoom ---
  canvas.addEventListener("wheel", (e) => {
    if (currentTool === "bend" && !e.ctrlKey) {
      const rows = getSelectedRows();
      if (rows.size !== 1) return;
      const rowSeats = rows.values().next().value;
      if (!rowSeats || rowSeats.length < 2) return;
      const rowData = computeRowEndpoints(rowSeats);
      if (!bendControlPoint) ensureBendDefaults();
      e.preventDefault();
      const direction = e.deltaY < 0 ? -1 : 1;
      const step = 0.05 * direction;
      bendTension = Math.max(-4, Math.min(1, bendTension + step));
      applyRowBend(rowData, rowSeats[0]?.rowId || "");
      updateCodeFromSeats();
      pushHistorySnapshot();
      renderCanvas();
      return;
    }
    if (!e.ctrlKey) return;
    e.preventDefault();

    const rect = canvas.getBoundingClientRect();
    const canvasX = e.clientX - rect.left;
    const canvasY = e.clientY - rect.top;

    const zoomIntensity = 1.1;
    const wheel = e.deltaY < 0 ? 1 : -1;
    const oldScale = scale;
    const newScale = wheel > 0 ? scale * zoomIntensity : scale / zoomIntensity;

    const { worldX, worldY } = screenToWorld(canvasX, canvasY);

    scale = Math.max(0.01, Math.min(20, newScale));

    translateX = canvasX - worldX * scale;
    translateY = canvasY - worldY * scale;

    renderCanvas();
  }, { passive: false });

  // --- Musinteraktion ---
  canvas.addEventListener("mousedown", (e) => {
    if (e.button !== 0) return;

    const rect = canvas.getBoundingClientRect();
    const canvasX = e.clientX - rect.left;
    const canvasY = e.clientY - rect.top;
    const { worldX, worldY } = screenToWorld(canvasX, canvasY);

    if (backgroundMoveMode && backgroundState.img) {
      isDraggingBackground = true;
      backgroundDragStartWorldX = worldX;
      backgroundDragStartWorldY = worldY;
      backgroundDragOriginX = backgroundState.originX;
      backgroundDragOriginY = backgroundState.originY;
      return;
    }

    const shouldPan = currentTool === "pan" || (e.ctrlKey && currentTool !== "rotate");
    if (shouldPan) {
      isPanning = true;
      panStartX = e.clientX;
      panStartY = e.clientY;
      panStartTranslateX = translateX;
      panStartTranslateY = translateY;
      canvasContainer.classList.add("panning");
      return;
    }

    if (currentTool === "rotate") {
      const selectedSeats = getSelectedSeats();
      if (!selectedSeats.length) return;

      hasRotatedDuringDrag = false;
      rotateStartSnapshot = captureSeatState();
      rotateSnapshotById = new Map();
      for (const snap of rotateStartSnapshot) {
        rotateSnapshotById.set(snap.seatId, snap);
      }

      const bounds = getSelectionBounds(selectedSeats);
      if (!bounds) return;
      rotatePivot = { x: bounds.centerX, y: bounds.centerY };
      rotateStartAngle = Math.atan2(worldY - rotatePivot.y, worldX - rotatePivot.x);
      isRotatingSelection = true;
      return;
    }

    if (currentTool === "bend") {
      const rows = getSelectedRows();
      if (rows.size !== 1) return; // endast en rad åt gången för stabil riktning

      const [, rowSeats] = rows.entries().next().value || [];
      const thisRowId = rowSeats && rowSeats.length ? rowSeats[0].rowId : null;

      bendStartSnapshot = captureSeatState();
      bendRowsData = [];
      for (const [, rowSeats] of rows) {
        if (rowSeats.length < 2) continue;
        bendRowsData.push(computeRowEndpoints(rowSeats));
        break; // bara första (enda) raden
      }
      if (!bendRowsData.length) return;

      ensureBendDefaults();
      const rowData = bendRowsData[0];
      const startSeat = rowData.first;
      const endSeat = rowData.last;
      const hitRadius = 10;
      const startScreen = worldToScreen(startSeat.vx, startSeat.vy);
      const endScreen = worldToScreen(endSeat.vx, endSeat.vy);
      const distStart = Math.hypot(startScreen.x - canvasX, startScreen.y - canvasY);
      const distEnd = Math.hypot(endScreen.x - canvasX, endScreen.y - canvasY);
      const anchorPoint = bendControlPoint || {
        x: (startSeat.vx + endSeat.vx) / 2,
        y: (startSeat.vy + endSeat.vy) / 2
      };
      const anchorScreen = worldToScreen(anchorPoint.x, anchorPoint.y);
      const distAnchor = Math.hypot(anchorScreen.x - canvasX, anchorScreen.y - canvasY);

      bendDragTarget = null;
      if (distStart <= hitRadius) {
        bendDragTarget = "start";
      } else if (distEnd <= hitRadius) {
        bendDragTarget = "end";
      } else if (distAnchor <= hitRadius) {
        bendDragTarget = "anchor";
      }

      if (!bendDragTarget) return;
      hasBentDuringDrag = true;
      isBendingSelection = true;

      // Initial böjning direkt vid klick
      applyRowBend(rowData, thisRowId);
      renderCanvas();
      return;
    }

    if (currentTool === "reshape") {
      const rows = getSelectedRows();
      if (rows.size !== 1) return;
      const [, rowSeats] = rows.entries().next().value || [];
      if (!rowSeats || rowSeats.length < 2) return;

      const sorted = sortSeatsInRow(rowSeats);
      const startSeat = sorted[0];
      const endSeat = sorted[sorted.length - 1];
      const hitRadius = 12;
      const startScreen = worldToScreen(startSeat.vx, startSeat.vy);
      const endScreen = worldToScreen(endSeat.vx, endSeat.vy);
      const distStart = Math.hypot(startScreen.x - canvasX, startScreen.y - canvasY);
      const distEnd = Math.hypot(endScreen.x - canvasX, endScreen.y - canvasY);

      reshapeDragTarget = null;
      if (distStart <= hitRadius) {
        reshapeDragTarget = "start";
      } else if (distEnd <= hitRadius) {
        reshapeDragTarget = "end";
      }
      if (!reshapeDragTarget) return;

      reshapeStartSnapshot = captureSeatState();
      reshapeSnapshotById = new Map(reshapeStartSnapshot.map(s => [s.seatId, s]));
      reshapeRowSeats = rowSeats;
      isReshapingRow = true;
      applyReshapeDrag(reshapeDragTarget, worldX, worldY, e.shiftKey);
      renderCanvas();
      return;
    }

    if (currentTool === "resize") {
      const selectedSeats = getSelectedSeats();
      if (!selectedSeats.length) return;
      const bounds = getSelectionBounds(selectedSeats);
      if (!bounds) return;
      const handles = getResizeHandles(bounds);

      const handleSizePx = 12;
      const hitHandle = handles.find(h => {
        const screen = worldToScreen(h.x, h.y);
        return Math.abs(screen.x - canvasX) <= handleSizePx / 2 && Math.abs(screen.y - canvasY) <= handleSizePx / 2;
      });
      if (!hitHandle) return;

      isResizingSelection = true;
      hasResizedDuringDrag = false;
      resizeHandleId = hitHandle.id;
      resizeStartBounds = bounds;
      resizeStartSnapshot = captureSeatState();
      resizeSnapshotById = new Map();
      for (const snap of resizeStartSnapshot) resizeSnapshotById.set(snap.seatId, snap);

      // pivot beror pГҐ vilket handtag vi drar
      const { minX, maxX, minY, maxY, centerX, centerY } = bounds;
      const pivotMap = {
        nw: { x: maxX, y: maxY },
        n:  { x: centerX, y: maxY },
        ne: { x: minX, y: maxY },
        e:  { x: minX, y: centerY },
        se: { x: minX, y: minY },
        s:  { x: centerX, y: minY },
        sw: { x: maxX, y: minY },
        w:  { x: maxX, y: centerY }
      };
      resizePivot = pivotMap[hitHandle.id];

      const handlePoint = { x: hitHandle.x, y: hitHandle.y };
      resizeStartVector = { x: handlePoint.x - resizePivot.x, y: handlePoint.y - resizePivot.y };
      return;
    }

    if (currentTool === "select") {
      const hit = hitTestSeat(worldX, worldY);
      const additiveClick = e.metaKey || e.shiftKey || e.altKey; // enkel: ctrl används för pan, så låt t.ex. Shift/Alt/Cmd bli additive

      let selectionChanged = false;

      if (hit) {
        const group = getGroupForSeat(hit);

        if (!additiveClick) {
          // ersatt markering
          const hadSelection = seats.some(s => s.selected);
          clearSelectionSeats(seats);
          lastSelectedSeatId = null;
          if (group.length) {
            markSeatsSelected(group, hit.seatId);
            selectionChanged = true;
          } else if (hadSelection) {
            selectionChanged = true;
          }
        } else {
          // toggla grupp
          const groupSelected = group.every(s => s.selected);
          if (groupSelected) {
            clearSelectionSeats(group);
            selectionChanged = true;
            if (group.some(s => s.seatId === lastSelectedSeatId)) {
              refreshSelectionAnchorFromOrder();
            }
          } else {
            markSeatsSelected(group, hit.seatId);
            selectionChanged = true;
          }
        }

        if (selectionChanged) {
          lastSelectionSource = "click";
          pushHistorySnapshot();   // markering i historiken
          updateMoveButtonState();
          renderCanvas();
        }

        return;
      }

      // Ingen träff: starta ruta-markering
      selectionRectActive = true;
      rectStartCanvasX = canvasX;
      rectStartCanvasY = canvasY;
      rectEndCanvasX = canvasX;
      rectEndCanvasY = canvasY;

      // additive rect: om shift/meta/alt = lägg till
      selectionRectAdditive = !!(e.metaKey || e.shiftKey || e.altKey);
      return;
    }

    if (currentTool === "move") {
      // Starta drag om det finns markerade platser
      const anySelected = seats.some(s => s.selected);
      if (!anySelected) return;

      isDraggingSelection = true;
      dragStartWorldX = worldX;
      dragStartWorldY = worldY;
      dragStartSnapshot = captureSeatState(); // för relativ flytt
      return;
    }
  });

    const ATTRIBUTE_OPTIONS = [
    { label: "Wheelchair", value: "Wheelchair" },
    { label: "Accompanying person", value: "AccompanyingPerson" },
    { label: "Obstructed view", value: "ObstructedView" },
    { label: "Partially obstructed view", value: "SomewhatObstructedView" },
    { label: "View limited by thin pillar", value: "SomewhatObstructedViewPole" },
    { label: "View limited by railing", value: "SomewhatObstructedViewRail" },
    { label: "Listening position", value: "ListeningLocations" },
    { label: "No visibility", value: "NoVisibility" },
    { label: "Hearing loop", value: "HearingLoop" },
    { label: "No hearing loop", value: "NoHearingLoop" },
    { label: "Limited legroom", value: "SomewhatRestrictedLegroom" },
    { label: "Extra legroom", value: "ExtraLegroom" },
    { label: "Sämre komfortnivå", value: "LessComfortable" },
    { label: "Hög scenkant", value: "HighStageEdge" },
    { label: "Något hög scenkant", value: "SomewhatHighStageEdge" },
    { label: "Extra trappsteg", value: "ExtraStep" },
    { label: "Singelplats", value: "SingleSeat" },
    { label: "Singelplats vid räcke", value: "SingleSeatByRails" },
    { label: "Aktiv sittplats", value: "ActiveSeat" },
    { label: "Ljudvolym kan upplevas hög", value: "VolumeMayBeLoud" }
  ];

  function closeSeatContextMenu() {
    if (!seatContextMenu) return;
    seatContextMenu.classList.remove("open");
    seatContextMenu.setAttribute("aria-hidden", "true");
  }

  function openSeatContextMenu(x, y) {
    if (!seatContextMenu) return;
    const selectedSeats = getSelectedSeats();
    seatContextMenu.style.left = `${x}px`;
    seatContextMenu.style.top = `${y}px`;
    seatContextMenu.classList.add("open");
    seatContextMenu.setAttribute("aria-hidden", "false");
    if (deleteSelectionMenuItem) {
      if (selectionMode === "section") deleteSelectionMenuItem.textContent = "Delete selected section(s)";
      else if (selectionMode === "row") deleteSelectionMenuItem.textContent = "Delete selected row(s)";
      else deleteSelectionMenuItem.textContent = "Delete selected seat(s)";
      deleteSelectionMenuItem.disabled = selectedSeats.length === 0;
    }
    if (editSeatsMenuItem) {
      editSeatsMenuItem.disabled = selectedSeats.length === 0;
    }
    if (editRowsMenuItem) {
      editRowsMenuItem.disabled = selectionMode !== "row" || getSelectedRows().size === 0;
    }
    const rows = getSelectedRows();
    let sameSection = true;
    let rowSectionId = "";
    if (rows.size >= 2) {
      rows.forEach((rowSeats) => {
        const rowSection = rowSeats[0]?.sectionId || "";
        if (!rowSection) sameSection = false;
        if (!rowSectionId) rowSectionId = rowSection;
        else if (rowSectionId !== rowSection) sameSection = false;
      });
    }
    if (mergeRowsMenuItem) {
      mergeRowsMenuItem.disabled = selectionMode !== "row" || rows.size < 2 || !sameSection;
    }
    if (splitRowMenuItem) {
      const splitInfo = selectionMode === "seat" ? getSplitRowSelectionInfo(selectedSeats) : null;
      splitRowMenuItem.disabled = !splitInfo;
    }
    if (equalizeRowsMenuItem) {
      equalizeRowsMenuItem.disabled = selectionMode !== "row" || rows.size < 2;
    }
    if (mimicRowShapeMenuItem) {
      const validRows = [...rows.values()].filter(r => r.length >= 2);
      mimicRowShapeMenuItem.disabled = selectionMode !== "row" || validRows.length < 2;
    }
    if (editSectionsMenuItem) {
      const sections = new Set(selectedSeats.map(s => s.sectionId).filter(Boolean));
      editSectionsMenuItem.disabled = selectionMode !== "section" || sections.size !== 1;
    }
    if (goodnessFromPointMenuItem) {
      goodnessFromPointMenuItem.disabled = selectedSeats.length === 0;
    }
    const padding = 8;
    const rect = seatContextMenu.getBoundingClientRect();
    let left = x;
    let top = y;
    if (left + rect.width > window.innerWidth - padding) {
      left = window.innerWidth - rect.width - padding;
    }
    if (top + rect.height > window.innerHeight - padding) {
      top = window.innerHeight - rect.height - padding;
    }
    if (left < padding) left = padding;
    if (top < padding) top = padding;
    seatContextMenu.style.left = `${left}px`;
    seatContextMenu.style.top = `${top}px`;
  }

  function getSeatDirectPriceRegionId(seat) {
    for (const region of priceRegions) {
      if (Array.isArray(region.seats) && region.seats.includes(seat.seatId)) {
        return region.id;
      }
    }
    return "";
  }

  function setSeatDirectPriceRegion(seatId, regionId) {
    let changed = false;
    priceRegions.forEach((region) => {
      if (!Array.isArray(region.seats)) region.seats = [];
      const hasSeat = region.seats.includes(seatId);
      if (region.id === regionId) {
        if (!hasSeat) {
          region.seats.push(seatId);
          changed = true;
        }
      } else if (hasSeat) {
        region.seats = region.seats.filter(id => id !== seatId);
        changed = true;
      }
    });
    return changed;
  }

  function buildSeatEditList() {
    if (!seatEditList) return;
    const selected = getSelectedSeats();
    seatEditList.innerHTML = "";
    if (!selected.length) return;

    const lookups = buildPriceRegionLookups();
    const priceRegionOptions = priceRegions.map(region => ({
      id: region.id,
      name: region.name || region.id
    }));
    const entryPointNames = entryPoints.map(ep => ep.name).filter(Boolean);

    selected.forEach((seat) => {
      const item = document.createElement("div");
      item.className = "edit-item";
      item.dataset.seatId = seat.seatId;
      item.dataset.attrOriginal = JSON.stringify(Array.isArray(seat.attributes) ? seat.attributes : []);

      const title = document.createElement("div");
      title.className = "edit-item__title";
      const rowLabel = seat.rowName || seat.rowId || "-";
      title.textContent = `Seat ${seat.name || "-"} on row ${rowLabel} | SeatId ${seat.seatId}`;

      const grid = document.createElement("div");
      grid.className = "edit-item__grid";

      const nameField = document.createElement("label");
      nameField.className = "edit-field";
      const nameLabel = document.createElement("span");
      nameLabel.textContent = "Seat name";
      const nameInput = document.createElement("input");
      nameInput.type = "text";
      nameInput.value = seat.name || "";
      nameInput.dataset.role = "seat-name";
      nameField.appendChild(nameLabel);
      nameField.appendChild(nameInput);

      const attrField = document.createElement("label");
      attrField.className = "edit-field";
      const attrLabel = document.createElement("span");
      attrLabel.textContent = "Attribute";
      const attrSelect = document.createElement("select");
      attrSelect.dataset.role = "seat-attribute";
      const attrs = Array.isArray(seat.attributes) ? seat.attributes : [];
      const hasMultiple = attrs.length > 1;
      const attrValue = attrs.length === 1 ? attrs[0] : (hasMultiple ? "__multiple__" : "");
      const optionValues = new Set();
      const pushOption = (value, label) => {
        const opt = document.createElement("option");
        opt.value = value;
        opt.textContent = label;
        attrSelect.appendChild(opt);
        optionValues.add(value);
      };
      if (hasMultiple) {
        pushOption("__multiple__", "Multiple (unchanged)");
      }
      pushOption("", "None");
      ATTRIBUTE_OPTIONS.forEach((opt) => {
        pushOption(opt.value, opt.label);
        pushOption(`.${opt.value}`, `${opt.label} (internal)`);
      });
      if (attrValue && !optionValues.has(attrValue)) {
        pushOption(attrValue, `${attrValue} (custom)`);
      }
      attrSelect.value = attrValue;
      attrField.appendChild(attrLabel);
      attrField.appendChild(attrSelect);

      const priceField = document.createElement("label");
      priceField.className = "edit-field";
      const priceLabel = document.createElement("span");
      priceLabel.textContent = "Price region";
      const priceSelect = document.createElement("select");
      priceSelect.dataset.role = "seat-price-region";
      const computedName = getSeatPriceRegionName(seat, lookups) || "-";
      const directRegionId = getSeatDirectPriceRegionId(seat);
      const inheritLabel = priceRegionOptions.length
        ? `Inherited (${computedName})`
        : "No price regions";
      const inheritOpt = document.createElement("option");
      inheritOpt.value = "";
      inheritOpt.textContent = inheritLabel;
      priceSelect.appendChild(inheritOpt);
      priceRegionOptions.forEach((region) => {
        const opt = document.createElement("option");
        opt.value = region.id;
        opt.textContent = region.name;
        priceSelect.appendChild(opt);
      });
      priceSelect.value = directRegionId || "";
      if (!priceRegionOptions.length) {
        priceSelect.disabled = true;
      }
      priceField.appendChild(priceLabel);
      priceField.appendChild(priceSelect);

      const entryField = document.createElement("label");
      entryField.className = "edit-field";
      const entryLabel = document.createElement("span");
      entryLabel.textContent = "Entry point";
      const entrySelect = document.createElement("select");
      entrySelect.dataset.role = "seat-entry";
      const entryOptions = new Set();
      const addEntryOption = (value, label) => {
        const opt = document.createElement("option");
        opt.value = value;
        opt.textContent = label;
        entrySelect.appendChild(opt);
        entryOptions.add(value);
      };
      addEntryOption("-", "None");
      entryPointNames.forEach((name) => addEntryOption(name, name));
      const entryValue = seat.entryVia || "-";
      if (entryValue && !entryOptions.has(entryValue)) {
        addEntryOption(entryValue, `${entryValue} (custom)`);
      }
      entrySelect.value = entryValue;
      entryField.appendChild(entryLabel);
      entryField.appendChild(entrySelect);

      grid.appendChild(nameField);
      grid.appendChild(attrField);
      grid.appendChild(priceField);
      grid.appendChild(entryField);

      item.appendChild(title);
      item.appendChild(grid);
      seatEditList.appendChild(item);
    });
  }

  function openSeatEditModal() {
    buildSeatEditList();
    if (seatEditOverlay) seatEditOverlay.style.display = "flex";
  }

  function closeSeatEditModal() {
    if (seatEditOverlay) seatEditOverlay.style.display = "none";
  }

  function getRowNumberingDefaults(rowSeats) {
    const sorted = sortSeatsInRow(rowSeats);
    const nums = sorted.map((s) => parseInt(s.name, 10)).filter((n) => Number.isFinite(n));
    const start = nums.length ? nums[0] : 1;
    let direction = "asc";
    if (nums.length >= 2) {
      direction = nums[nums.length - 1] >= nums[0] ? "asc" : "desc";
    }
    return { start, direction };
  }

  function buildRowEditList() {
    if (!rowEditList) return;
    const rows = getSelectedRows();
    rowEditList.innerHTML = "";
    rowEditState = new Map();
    if (!rows.size) return;

    rows.forEach((rowSeats, rowId) => {
      const rowName = rowSeats[0]?.rowName || rowId;
      const defaults = getRowNumberingDefaults(rowSeats);
      rowEditState.set(rowId, { addCount: 0 });

      const item = document.createElement("div");
      item.className = "edit-item";
      item.dataset.rowId = rowId;
      item.dataset.startDefault = String(defaults.start);
      item.dataset.dirDefault = defaults.direction;

      const title = document.createElement("div");
      title.className = "edit-item__title";
      title.textContent = `Row ${rowName} contains ${rowSeats.length} seats | RowId ${rowId}`;

      const grid = document.createElement("div");
      grid.className = "edit-item__grid";

      const nameField = document.createElement("label");
      nameField.className = "edit-field";
      const nameLabel = document.createElement("span");
      nameLabel.textContent = "Row name";
      const nameInput = document.createElement("input");
      nameInput.type = "text";
      nameInput.value = rowName;
      nameInput.dataset.role = "row-name";
      nameField.appendChild(nameLabel);
      nameField.appendChild(nameInput);

      const startField = document.createElement("label");
      startField.className = "edit-field";
      const startLabel = document.createElement("span");
      startLabel.textContent = "Seat start #";
      const startInput = document.createElement("input");
      startInput.type = "number";
      startInput.value = String(defaults.start);
      startInput.dataset.role = "row-start";
      startField.appendChild(startLabel);
      startField.appendChild(startInput);

      const dirField = document.createElement("label");
      dirField.className = "edit-field";
      const dirLabel = document.createElement("span");
      dirLabel.textContent = "Direction";
      const dirSelect = document.createElement("select");
      dirSelect.dataset.role = "row-direction";
      const ascOpt = document.createElement("option");
      ascOpt.value = "asc";
      ascOpt.textContent = "Ascending";
      const descOpt = document.createElement("option");
      descOpt.value = "desc";
      descOpt.textContent = "Descending";
      dirSelect.appendChild(ascOpt);
      dirSelect.appendChild(descOpt);
      dirSelect.value = defaults.direction;
      dirField.appendChild(dirLabel);
      dirField.appendChild(dirSelect);

      const actions = document.createElement("div");
      actions.className = "edit-item__actions";
      const addBtn = document.createElement("button");
      addBtn.type = "button";
      addBtn.className = "c-button c-button--ghost c-button--small";
      addBtn.textContent = "Add seat";
      addBtn.dataset.role = "row-add-seat";
      const meta = document.createElement("span");
      meta.className = "edit-item__meta";
      meta.dataset.role = "row-add-meta";
      meta.textContent = "Pending: 0";
      actions.appendChild(addBtn);
      actions.appendChild(meta);

      grid.appendChild(nameField);
      grid.appendChild(startField);
      grid.appendChild(dirField);

      item.appendChild(title);
      item.appendChild(grid);
      item.appendChild(actions);
      rowEditList.appendChild(item);
    });
  }

  function openRowEditModal() {
    buildRowEditList();
    if (rowEditOverlay) rowEditOverlay.style.display = "flex";
  }

  function closeRowEditModal() {
    if (rowEditOverlay) rowEditOverlay.style.display = "none";
  }

  function normalizeSectionName(name) {
    return String(name || "").trim().toLowerCase();
  }

  function getDuplicateDraftSectionNames(drafts) {
    const duplicates = new Set();
    const existingKeys = new Map();
    sectionNames.forEach((name, id) => {
      const key = normalizeSectionName(name || id);
      if (!key) return;
      existingKeys.set(key, id);
    });
    const draftKeys = new Map();
    drafts.forEach((draft, idx) => {
      const display = (draft.sectionName || draft.sectionId || "").trim();
      if (!display) return;
      const key = normalizeSectionName(display);
      const draftId = draft.sectionId || `draft-${idx + 1}`;
      const existingId = existingKeys.get(key);
      if (existingId && existingId !== draft.sectionId) {
        duplicates.add(display);
      }
      const priorDraftId = draftKeys.get(key);
      if (priorDraftId && priorDraftId !== draftId) {
        duplicates.add(display);
      } else if (!priorDraftId) {
        draftKeys.set(key, draftId);
      }
    });
    return Array.from(duplicates);
  }

  function isDuplicateSectionName(sectionId, nextName) {
    const key = normalizeSectionName(nextName || sectionId);
    if (!key) return false;
    for (const [id, name] of sectionNames.entries()) {
      if (id === sectionId) continue;
      if (normalizeSectionName(name || id) === key) return true;
    }
    return false;
  }

  function updateSectionName(sectionId, nextName) {
    const name = (nextName || sectionId).trim();
    sectionNames.set(sectionId, name);
    seats.forEach((s) => {
      if (s.sectionId === sectionId) {
        s.sectionName = name;
      }
    });
    let found = false;
    let changed = false;
    originalLines = originalLines.map((line) => {
      if (!line.includes("|SectionAdd|")) return line;
      const sectionMatch = line.match(/SectionId=([^|]+)/);
      if (!sectionMatch || sectionMatch[1] !== sectionId) return line;
      found = true;
      if (line.includes("Name=")) {
        const updated = line.replace(/Name=([^|]*)/i, `Name=${name}`);
        if (updated !== line) changed = true;
        return updated;
      }
      changed = true;
      return `${line}|Name=${name}`;
    });
    if (!found) {
      originalLines.push(`${buildTimestamp()}|SectionAdd|SectionId=${sectionId}|Name=${name}`);
      changed = true;
    }
    return changed;
  }

  function resetSectionEditDrafts() {
    sectionEditRowCounter = 0;
    if (sectionNewRowsList) sectionNewRowsList.innerHTML = "";
  }

  function computeRowCenter(rowSeats) {
    if (!rowSeats || !rowSeats.length) return { x: 0, y: 0 };
    let sumX = 0;
    let sumY = 0;
    rowSeats.forEach((seat) => {
      sumX += seat.vx;
      sumY += seat.vy;
    });
    return { x: sumX / rowSeats.length, y: sumY / rowSeats.length };
  }

  function computeRowDirection(rowSeats) {
    if (!rowSeats || rowSeats.length < 2) return null;
    const sorted = sortSeatsInRow(rowSeats);
    const first = sorted[0];
    const last = sorted[sorted.length - 1];
    if (!first || !last) return null;
    const dx = last.vx - first.vx;
    const dy = last.vy - first.vy;
    const dist = Math.hypot(dx, dy);
    if (dist < 1e-3) return null;
    return { x: dx / dist, y: dy / dist };
  }

  function getRowSelectionOrder(rowSeats) {
    if (!rowSeats || !rowSeats.length) return Infinity;
    let minOrder = Infinity;
    for (const seat of rowSeats) {
      const order = typeof seat.selectedAt === "number" ? seat.selectedAt : Infinity;
      if (order < minOrder) minOrder = order;
    }
    return minOrder;
  }

  function getSeatIdSuffix(seatId) {
    const parts = parseSeatIdParts(seatId);
    return Number.isFinite(parts.seat) ? parts.seat : null;
  }

  function getSplitRowSelectionInfo(selectedSeats) {
    if (!selectedSeats || selectedSeats.length !== 2) return null;
    const [first, second] = selectedSeats;
    if (!first || !second) return null;
    if (!first.rowId || first.rowId !== second.rowId) return null;
    if (!first.sectionId || first.sectionId !== second.sectionId) return null;
    const firstNum = getSeatIdSuffix(first.seatId);
    const secondNum = getSeatIdSuffix(second.seatId);
    if (!Number.isFinite(firstNum) || !Number.isFinite(secondNum)) return null;
    if (Math.abs(firstNum - secondNum) !== 1) return null;
    const lowSeatSuffix = Math.min(firstNum, secondNum);
    const highSeatSuffix = Math.max(firstNum, secondNum);
    const lowSeatId = firstNum < secondNum ? first.seatId : second.seatId;
    const highSeatId = firstNum > secondNum ? first.seatId : second.seatId;
    return {
      rowId: first.rowId,
      sectionId: first.sectionId,
      lowSeatSuffix,
      highSeatSuffix,
      lowSeatId,
      highSeatId
    };
  }

  function rebuildSectionRowsInLines(sectionId) {
    if (!sectionId) return false;
    const rowsById = new Map();
    seats.forEach((seat) => {
      if (seat.sectionId !== sectionId || !seat.rowId) return;
      if (!rowsById.has(seat.rowId)) rowsById.set(seat.rowId, []);
      rowsById.get(seat.rowId).push(seat);
    });
    if (!rowsById.size) return false;

    const rowEntries = [];
    rowsById.forEach((rowSeats, rowId) => {
      const parts = parseRowIdParts(rowId);
      const rowNum = Number.isFinite(parts.row) ? parts.row : null;
      const rowName = rowSeats[0]?.rowName || rowId;
      const sortedSeats = [...rowSeats].sort((a, b) => {
        const aNum = getSeatIdSuffix(a.seatId);
        const bNum = getSeatIdSuffix(b.seatId);
        if (Number.isFinite(aNum) && Number.isFinite(bNum)) return aNum - bNum;
        return String(a.seatId || "").localeCompare(String(b.seatId || ""));
      });
      rowEntries.push({ rowId, rowNum, rowName, seats: sortedSeats });
    });
    rowEntries.sort((a, b) => {
      if (a.rowNum != null && b.rowNum != null) return a.rowNum - b.rowNum;
      if (a.rowNum != null) return -1;
      if (b.rowNum != null) return 1;
      return a.rowId.localeCompare(b.rowId);
    });

    const rowTimestampById = new Map();
    originalLines.forEach((line) => {
      if (!line.includes("|RowAdd|")) return;
      const rowMatch = line.match(/RowId=([^|]+)/);
      if (!rowMatch) return;
      const rowId = rowMatch[1];
      if (!rowId.startsWith(`${sectionId}.`)) return;
      const timestamp = line.split("|")[0] || "";
      if (timestamp) rowTimestampById.set(rowId, timestamp);
    });

    const newLines = [];
    rowEntries.forEach((entry) => {
      const ts = rowTimestampById.get(entry.rowId) || buildTimestamp();
      newLines.push(`${ts}|RowAdd|RowId=${entry.rowId}|Name=${entry.rowName}`);
      entry.seats.forEach((seat) => {
        newLines.push(buildSeatLine(seat));
      });
    });

    const removedIndexes = [];
    originalLines = originalLines.filter((line, idx) => {
      if (line.includes("|RowAdd|")) {
        const rowMatch = line.match(/RowId=([^|]+)/);
        if (rowMatch && rowMatch[1].startsWith(`${sectionId}.`)) {
          removedIndexes.push(idx);
          return false;
        }
      }
      if (line.includes("|SeatAdd|")) {
        const seatMatch = line.match(/SeatId=([^|]+)/);
        if (seatMatch && seatMatch[1].startsWith(`${sectionId}.`)) {
          removedIndexes.push(idx);
          return false;
        }
      }
      return true;
    });
    shiftOutlineLineIndexesAfterRemoval(removedIndexes);

    let insertAt = -1;
    for (let i = 0; i < originalLines.length; i++) {
      const line = originalLines[i];
      if (!line.includes("|SectionAdd|")) continue;
      const sectionMatch = line.match(/SectionId=([^|]+)/);
      if (sectionMatch && sectionMatch[1] === sectionId) {
        insertAt = i + 1;
        break;
      }
    }
    if (insertAt < 0) insertAt = originalLines.length;
    shiftOutlineLineIndexes(insertAt, newLines.length);
    originalLines.splice(insertAt, 0, ...newLines);
    rebuildSeatLineIndex();
    return true;
  }

  function getSectionRowLayout(sectionId) {
    if (!sectionId) return null;
    const rowsById = new Map();
    seats.forEach((seat) => {
      if (seat.sectionId !== sectionId) return;
      if (!seat.rowId) return;
      if (!rowsById.has(seat.rowId)) rowsById.set(seat.rowId, []);
      rowsById.get(seat.rowId).push(seat);
    });
    if (!rowsById.size) return null;
    const entries = [];
    let maxRowNumber = 0;
    rowsById.forEach((rowSeats, rowId) => {
      const parts = parseRowIdParts(rowId);
      const rowNum = Number.isFinite(parts.row) ? parts.row : null;
      if (rowNum != null) maxRowNumber = Math.max(maxRowNumber, rowNum);
      entries.push({ rowId, rowNum, seats: rowSeats });
    });
    entries.sort((a, b) => {
      if (a.rowNum != null && b.rowNum != null) return a.rowNum - b.rowNum;
      if (a.rowNum != null) return -1;
      if (b.rowNum != null) return 1;
      return a.rowId.localeCompare(b.rowId);
    });
    if (!maxRowNumber) maxRowNumber = entries.length;
    const lastEntry = entries[entries.length - 1] || null;
    const prevEntry = entries.length > 1 ? entries[entries.length - 2] : null;
    return { rowsById, entries, maxRowNumber, lastEntry, prevEntry };
  }

  function inferRowNumberDirection(rowSeats) {
    if (!rowSeats || rowSeats.length < 2) return "asc";
    const sorted = sortSeatsInRow(rowSeats);
    const firstNum = parseFloat(sorted[0]?.name);
    const lastNum = parseFloat(sorted[sorted.length - 1]?.name);
    if (Number.isFinite(firstNum) && Number.isFinite(lastNum) && firstNum !== lastNum) {
      return lastNum > firstNum ? "asc" : "desc";
    }
    return "asc";
  }

  function getSectionRowDefaults(sectionId) {
    const layout = getSectionRowLayout(sectionId);
    if (!layout || !layout.lastEntry) {
      return { seatCount: 10, startNumber: 1, direction: "asc" };
    }
    const seatCount = layout.lastEntry.seats.length || 10;
    return {
      seatCount,
      startNumber: 1,
      direction: inferRowNumberDirection(layout.lastEntry.seats)
    };
  }

  function addSectionRowDraft() {
    if (!sectionNewRowsList) return;
    const defaults = getSectionRowDefaults(sectionEditTargetId);
    sectionEditRowCounter += 1;

    const item = document.createElement("div");
    item.className = "edit-item";
    item.dataset.draftId = `row-${sectionEditRowCounter}`;

    const title = document.createElement("div");
    title.className = "edit-item__title";
    title.textContent = `New row ${sectionEditRowCounter}`;

    const grid = document.createElement("div");
    grid.className = "edit-item__grid";

    const nameField = document.createElement("label");
    nameField.className = "edit-field";
    const nameLabel = document.createElement("span");
    nameLabel.textContent = "Row name";
    const nameInput = document.createElement("input");
    nameInput.type = "text";
    nameInput.placeholder = "e.g. 4";
    nameInput.dataset.role = "section-row-name";
    nameField.appendChild(nameLabel);
    nameField.appendChild(nameInput);

    const countField = document.createElement("label");
    countField.className = "edit-field";
    const countLabel = document.createElement("span");
    countLabel.textContent = "Seat count";
    const countInput = document.createElement("input");
    countInput.type = "number";
    countInput.min = "1";
    countInput.step = "1";
    countInput.value = String(defaults.seatCount || 1);
    countInput.dataset.role = "section-row-count";
    countField.appendChild(countLabel);
    countField.appendChild(countInput);

    const startField = document.createElement("label");
    startField.className = "edit-field";
    const startLabel = document.createElement("span");
    startLabel.textContent = "Start number";
    const startInput = document.createElement("input");
    startInput.type = "number";
    startInput.step = "1";
    startInput.value = String(defaults.startNumber || 1);
    startInput.dataset.role = "section-row-start";
    startField.appendChild(startLabel);
    startField.appendChild(startInput);

    const dirField = document.createElement("label");
    dirField.className = "edit-field";
    const dirLabel = document.createElement("span");
    dirLabel.textContent = "Direction";
    const dirSelect = document.createElement("select");
    dirSelect.dataset.role = "section-row-direction";
    const ascOpt = document.createElement("option");
    ascOpt.value = "asc";
    ascOpt.textContent = "Ascending";
    const descOpt = document.createElement("option");
    descOpt.value = "desc";
    descOpt.textContent = "Descending";
    dirSelect.appendChild(ascOpt);
    dirSelect.appendChild(descOpt);
    dirSelect.value = defaults.direction || "asc";
    dirField.appendChild(dirLabel);
    dirField.appendChild(dirSelect);

    grid.appendChild(nameField);
    grid.appendChild(countField);
    grid.appendChild(startField);
    grid.appendChild(dirField);

    item.appendChild(title);
    item.appendChild(grid);
    sectionNewRowsList.appendChild(item);
  }

  function collectSectionRowDrafts() {
    if (!sectionNewRowsList) return { drafts: [], errors: [] };
    const drafts = [];
    const errors = [];
    const items = sectionNewRowsList.querySelectorAll(".edit-item");
    items.forEach((item, idx) => {
      const nameInput = item.querySelector("input[data-role='section-row-name']");
      const countInput = item.querySelector("input[data-role='section-row-count']");
      const startInput = item.querySelector("input[data-role='section-row-start']");
      const dirSelect = item.querySelector("select[data-role='section-row-direction']");

      const seatCount = parseInt(countInput?.value, 10);
      if (!Number.isFinite(seatCount) || seatCount <= 0) {
        errors.push(`Row ${idx + 1}: seat count must be 1 or more.`);
        return;
      }
      const startNumberRaw = parseInt(startInput?.value, 10);
      const startNumber = Number.isFinite(startNumberRaw) ? startNumberRaw : 1;
      const direction = dirSelect?.value === "desc" ? "desc" : "asc";
      drafts.push({
        name: (nameInput?.value || "").trim(),
        seatCount,
        startNumber,
        direction
      });
    });
    return { drafts, errors };
  }

  function buildSectionEditList() {
    if (!sectionEditList) return;
    const selected = getSelectedSeats();
    sectionEditList.innerHTML = "";
    sectionEditTargetId = null;
    resetSectionEditDrafts();
    if (sectionAddRowBtn) sectionAddRowBtn.disabled = true;
    if (!selected.length) return;
    const sections = new Map();
    selected.forEach((seat) => {
      if (!seat.sectionId) return;
      if (!sections.has(seat.sectionId)) {
        sections.set(seat.sectionId, {
          sectionId: seat.sectionId,
          name: sectionNames.get(seat.sectionId) || seat.sectionName || seat.sectionId,
          seatCount: 0
        });
      }
      sections.get(seat.sectionId).seatCount += 1;
    });
    if (sections.size !== 1) return;
    const section = Array.from(sections.values())[0];
    sectionEditTargetId = section.sectionId;
    if (sectionAddRowBtn) sectionAddRowBtn.disabled = false;

    const item = document.createElement("div");
    item.className = "edit-item";
    item.dataset.sectionId = section.sectionId;
    item.dataset.nameOriginal = section.name || "";

    const title = document.createElement("div");
    title.className = "edit-item__title";
    title.textContent = `${section.name || section.sectionId} - ${section.sectionId} - ${section.seatCount} seats`;

    const grid = document.createElement("div");
    grid.className = "edit-item__grid";

    const nameField = document.createElement("label");
    nameField.className = "edit-field";
    const nameLabel = document.createElement("span");
    nameLabel.textContent = "Section name";
    const nameInput = document.createElement("input");
    nameInput.type = "text";
    nameInput.maxLength = SECTION_NAME_MAX;
    nameInput.value = section.name || "";
    nameInput.dataset.role = "section-name";
    nameField.appendChild(nameLabel);
    nameField.appendChild(nameInput);

    grid.appendChild(nameField);

    item.appendChild(title);
    item.appendChild(grid);
    sectionEditList.appendChild(item);
  }

  function openSectionEditModal() {
    buildSectionEditList();
    if (!sectionEditTargetId) return;
    if (sectionEditOverlay) sectionEditOverlay.style.display = "flex";
  }

  function closeSectionEditModal() {
    if (sectionEditOverlay) sectionEditOverlay.style.display = "none";
    sectionEditTargetId = null;
    if (sectionAddRowBtn) sectionAddRowBtn.disabled = true;
    resetSectionEditDrafts();
  }

  function updateRowName(rowId, nextName) {
    const name = nextName || rowId;
    seats.forEach((s) => {
      if (s.rowId === rowId) {
        s.rowName = name;
      }
    });
    let found = false;
    let changed = false;
    originalLines = originalLines.map((line) => {
      if (!line.includes("|RowAdd|")) return line;
      const rowMatch = line.match(/RowId=([^|]+)/);
      if (!rowMatch || rowMatch[1] !== rowId) return line;
      found = true;
      if (line.includes("Name=")) {
        const updated = line.replace(/Name=([^|]*)/i, `Name=${name}`);
        if (updated !== line) changed = true;
        return updated;
      }
      changed = true;
      return `${line}|Name=${name}`;
    });
    if (!found) {
      originalLines.push(`${buildTimestamp()}|RowAdd|RowId=${rowId}|Name=${name}`);
      changed = true;
    }
    return changed;
  }

  function applyRowNumbering(rowSeats, start, direction) {
    const sorted = sortSeatsInRow(rowSeats);
    const step = direction === "desc" ? -1 : 1;
    sorted.forEach((seat, idx) => {
      seat.name = String(start + idx * step);
    });
  }

  function computeRowSpacing(sortedSeats) {
    if (sortedSeats.length < 2) return 50;
    const distances = [];
    for (let i = 1; i < sortedSeats.length; i++) {
      const dx = sortedSeats[i].vx - sortedSeats[i - 1].vx;
      const dy = sortedSeats[i].vy - sortedSeats[i - 1].vy;
      const dist = Math.hypot(dx, dy);
      if (dist > 1e-3) distances.push(dist);
    }
    if (!distances.length) return 50;
    distances.sort((a, b) => a - b);
    const mid = Math.floor(distances.length / 2);
    if (distances.length % 2 === 1) {
      return distances[mid];
    }
    return (distances[mid - 1] + distances[mid]) / 2;
  }

  function buildNextSeatId(rowId, existing) {
    const used = new Set(existing.map(s => s.seatId));
    let maxSuffix = 0;
    existing.forEach((s) => {
      const parts = s.seatId ? s.seatId.split(".") : [];
      const last = parts[parts.length - 1];
      const num = parseInt(last, 10);
      if (Number.isFinite(num)) maxSuffix = Math.max(maxSuffix, num);
    });
    let next = maxSuffix + 1;
    let candidate = `${rowId}.${next}`;
    while (used.has(candidate)) {
      next += 1;
      candidate = `${rowId}.${next}`;
    }
    return candidate;
  }

  function findRowInsertIndex(rowId, rowSeats) {
    let maxLineIndex = -1;
    rowSeats.forEach((s) => {
      if (Number.isFinite(s.lineIndex)) {
        maxLineIndex = Math.max(maxLineIndex, s.lineIndex);
      }
    });
    if (maxLineIndex >= 0) return maxLineIndex;
    for (let i = 0; i < originalLines.length; i++) {
      const line = originalLines[i];
      if (!line.includes("|RowAdd|")) continue;
      const rowMatch = line.match(/RowId=([^|]+)/);
      if (rowMatch && rowMatch[1] === rowId) return i;
    }
    return -1;
  }

  function shiftOutlineLineIndexes(insertAt, delta) {
    if (!delta) return;
    outlines.forEach((o) => {
      if (typeof o.lineIndex === "number" && o.lineIndex >= insertAt) {
        o.lineIndex += delta;
      }
    });
  }

  function shiftOutlineLineIndexesAfterRemoval(removedIndexes) {
    if (!removedIndexes || !removedIndexes.length) return;
    const sorted = [...removedIndexes].sort((a, b) => a - b);
    outlines.forEach((o) => {
      if (typeof o.lineIndex !== "number") return;
      let shift = 0;
      for (const idx of sorted) {
        if (idx < o.lineIndex) shift += 1;
        else break;
      }
      if (shift) o.lineIndex -= shift;
    });
  }

  function addSeatsToRow(rowId, rowSeats, addCount, rowNameOverride) {
    if (!addCount || addCount <= 0) return false;
    const sorted = sortSeatsInRow(rowSeats);
    const base = sorted[sorted.length - 1];
    if (!base) return false;
    const prev = sorted.length > 1 ? sorted[sorted.length - 2] : base;
    let dirX = 1;
    let dirY = 0;
    const dx = base.vx - prev.vx;
    const dy = base.vy - prev.vy;
    const dist = Math.hypot(dx, dy);
    if (dist > 1e-3) {
      dirX = dx / dist;
      dirY = dy / dist;
    }
    const spacing = computeRowSpacing(sorted);
    const baseGoodness = Number(base.goodness);
    let changed = false;
    const insertIndex = findRowInsertIndex(rowId, rowSeats);
    const newSeats = [];
    const newLines = [];

    for (let i = 0; i < addCount; i++) {
      const seatId = buildNextSeatId(rowId, rowSeats);
      const nameNums = rowSeats
        .map(s => parseInt(s.name, 10))
        .filter(n => Number.isFinite(n));
      const nextName = nameNums.length ? String(Math.max(...nameNums) + 1) : String(rowSeats.length + 1);
      const offset = spacing * (i + 1);
      const x = base.vx + dirX * offset;
      const y = base.vy + dirY * offset;
      const seat = {
        seatId,
        name: nextName,
        sectionId: base.sectionId,
        rowId,
        sectionName: base.sectionName || "",
        rowName: rowNameOverride || base.rowName || rowId,
        centerX: x,
        centerY: y,
        vx: x,
        vy: y,
        radius: base.radius || 10,
        rotation: base.rotation || 0,
        width: base.width || 100,
        entryVia: base.entryVia || "-",
        goodness: Number.isFinite(baseGoodness) ? baseGoodness : 0,
        attributes: [],
        timestamp: buildTimestamp(),
        selected: true,
        lineIndex: -1
      };
      newSeats.push(seat);
      rowSeats.push(seat);
      newLines.push(buildSeatLine(seat));
    }
    if (newSeats.length) {
      const insertAt = insertIndex >= 0 ? insertIndex + 1 : originalLines.length;
      shiftOutlineLineIndexes(insertAt, newLines.length);
      originalLines.splice(insertAt, 0, ...newLines);
      seats.push(...newSeats);
      rebuildSeatLineIndex();
      changed = true;
    }
    return changed;
  }

  function addRowsToSection(sectionId, rowDrafts) {
    if (!sectionId || !rowDrafts || !rowDrafts.length) return false;
    const layout = getSectionRowLayout(sectionId);
    if (!layout || !layout.lastEntry || !layout.lastEntry.seats.length) return false;

    const lastEntry = layout.lastEntry;
    const prevEntry = layout.prevEntry;
    const lastSorted = sortSeatsInRow(lastEntry.seats);
    const baseSeat = lastSorted[0] || lastEntry.seats[0];
    if (!baseSeat) return false;

    let dirX = 1;
    let dirY = 0;
    const dirSource = lastSorted.length > 1
      ? lastSorted
      : (prevEntry && prevEntry.seats.length > 1 ? sortSeatsInRow(prevEntry.seats) : null);
    if (dirSource && dirSource.length > 1) {
      const first = dirSource[0];
      const last = dirSource[dirSource.length - 1];
      const dx = last.vx - first.vx;
      const dy = last.vy - first.vy;
      const dist = Math.hypot(dx, dy);
      if (dist > 1e-3) {
        dirX = dx / dist;
        dirY = dy / dist;
      }
    }

    let seatSpacing = computeRowSpacing(lastSorted);
    if (lastSorted.length < 2) {
      const baseWidth = baseSeat.width || 100;
      seatSpacing = baseWidth * 1.2;
    }
    if (!Number.isFinite(seatSpacing) || seatSpacing <= 0) seatSpacing = 120;

    let rowOffsetX = 0;
    let rowOffsetY = 0;
    if (prevEntry && prevEntry.seats.length) {
      const prevCenter = computeRowCenter(prevEntry.seats);
      const lastCenter = computeRowCenter(lastEntry.seats);
      rowOffsetX = lastCenter.x - prevCenter.x;
      rowOffsetY = lastCenter.y - prevCenter.y;
    }
    if (Math.hypot(rowOffsetX, rowOffsetY) < 1e-3) {
      const defaultRowSpacing = 180;
      rowOffsetX = -dirY * defaultRowSpacing;
      rowOffsetY = dirX * defaultRowSpacing;
    }

    let nextRowNumber = layout.maxRowNumber || 0;
    const sectionName = sectionNames.get(sectionId) || baseSeat.sectionName || sectionId;
    const baseGoodness = Number(baseSeat.goodness);

    const insertIndex = findRowInsertIndex(lastEntry.rowId, lastEntry.seats);
    const insertAt = insertIndex >= 0 ? insertIndex + 1 : originalLines.length;
    const newLines = [];
    const newSeats = [];

    rowDrafts.forEach((draft, idx) => {
      if (!draft || !draft.seatCount || draft.seatCount <= 0) return;
      nextRowNumber += 1;
      const rowId = `${sectionId}.${nextRowNumber}`;
      const rowName = (draft.name || "").trim() || String(nextRowNumber);
      const direction = draft.direction === "desc" ? "desc" : "asc";
      const step = direction === "desc" ? -1 : 1;
      const startNumber = Number.isFinite(draft.startNumber) ? draft.startNumber : 1;
      const rowStartX = baseSeat.vx + rowOffsetX * (idx + 1);
      const rowStartY = baseSeat.vy + rowOffsetY * (idx + 1);
      const timestamp = buildTimestamp();

      newLines.push(`${timestamp}|RowAdd|RowId=${rowId}|Name=${rowName}`);

      for (let i = 0; i < draft.seatCount; i++) {
        const seatId = `${rowId}.${i + 1}`;
        const seatName = String(startNumber + i * step);
        const x = rowStartX + dirX * seatSpacing * i;
        const y = rowStartY + dirY * seatSpacing * i;
        const seat = {
          seatId,
          name: seatName,
          sectionId,
          rowId,
          sectionName,
          rowName,
          centerX: x,
          centerY: y,
          vx: x,
          vy: y,
          radius: baseSeat.radius || 10,
          rotation: baseSeat.rotation || 0,
          width: baseSeat.width || 100,
          entryVia: baseSeat.entryVia || "-",
          goodness: Number.isFinite(baseGoodness) ? baseGoodness : 0,
          attributes: [],
          timestamp,
          selected: true,
          lineIndex: -1
        };
        newSeats.push(seat);
        newLines.push(buildSeatLine(seat));
      }
    });

    if (!newLines.length) return false;
    shiftOutlineLineIndexes(insertAt, newLines.length);
    originalLines.splice(insertAt, 0, ...newLines);
    seats.push(...newSeats);
    rebuildSeatLineIndex();
    return true;
  }

  function buildAttributeModalList() {
    if (!attributeModalList) return;
    attributeModalList.innerHTML = "";
    for (const opt of ATTRIBUTE_OPTIONS) {
      const row = document.createElement("div");
      row.className = "attribute-option";

      const mainLabel = document.createElement("label");
      mainLabel.className = "attribute-option__main";
      const checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.dataset.attributeToken = opt.value;
      const text = document.createElement("span");
      text.textContent = opt.label;
      mainLabel.appendChild(checkbox);
      mainLabel.appendChild(text);

      const internalLabel = document.createElement("label");
      internalLabel.className = "attribute-option__internal";
      const internalCheckbox = document.createElement("input");
      internalCheckbox.type = "checkbox";
      internalCheckbox.dataset.attributeToken = `.${opt.value}`;
      const internalText = document.createElement("span");
      internalText.textContent = "Internal";
      internalLabel.appendChild(internalCheckbox);
      internalLabel.appendChild(internalText);

      row.appendChild(mainLabel);
      row.appendChild(internalLabel);
      attributeModalList.appendChild(row);
    }
  }

  function openAttributeModal() {
    const selected = getSelectedSeats();
    if (!selected.length) return;
    buildAttributeModalList();
    const union = new Set();
    for (const s of selected) {
      const attrs = Array.isArray(s.attributes) ? s.attributes : [];
      for (const attr of attrs) union.add(attr);
    }
    attributeModalList?.querySelectorAll("input[data-attribute-token]").forEach((input) => {
      const token = input.dataset.attributeToken || "";
      input.checked = union.has(token);
    });
    if (attributeModalOverlay) attributeModalOverlay.style.display = "flex";
  }

  function closeAttributeModal() {
    if (attributeModalOverlay) attributeModalOverlay.style.display = "none";
  }

  function applyAttributesToSelection(attributes) {
    const selected = getSelectedSeats();
    if (!selected.length) return;
    let changed = false;
    for (const s of selected) {
      const next = [...attributes];
      s.attributes = next;
      changed = true;
    }
    if (changed) {
      updateCodeFromSeats();
      renderCanvas();
    }
  }

  attributeMenuItem?.addEventListener("click", () => {
    closeSeatContextMenu();
    openAttributeModal();
  });
  goodnessFromPointMenuItem?.addEventListener("click", () => {
    closeSeatContextMenu();
    openGoodnessModal();
  });
  editSeatsMenuItem?.addEventListener("click", () => {
    closeSeatContextMenu();
    openSeatEditModal();
  });
  editRowsMenuItem?.addEventListener("click", () => {
    closeSeatContextMenu();
    openRowEditModal();
  });
  mergeRowsMenuItem?.addEventListener("click", () => {
    closeSeatContextMenu();
    const changed = mergeSelectedRows();
    if (!changed) return;
  });
  splitRowMenuItem?.addEventListener("click", () => {
    closeSeatContextMenu();
    splitRowAtSelection();
  });
  equalizeRowsMenuItem?.addEventListener("click", () => {
    closeSeatContextMenu();
    const changed = equalizeRowDistanceForSelection();
    if (changed) {
      pushHistorySnapshot();
      hasUnsavedChanges = true;
      updateCodeFromSeats();
      updateSaveButton();
      renderCanvas();
    }
  });
  mimicRowShapeMenuItem?.addEventListener("click", () => {
    closeSeatContextMenu();
    const changed = mimicShapeOfFirstSelectedRow();
    if (changed) {
      pushHistorySnapshot();
      hasUnsavedChanges = true;
      updateCodeFromSeats();
      updateSaveButton();
      renderCanvas();
    }
  });
  editSectionsMenuItem?.addEventListener("click", () => {
    closeSeatContextMenu();
    openSectionEditModal();
  });
  deleteSelectionMenuItem?.addEventListener("click", () => {
    closeSeatContextMenu();
    deleteSelectionByMode();
  });

  attributeModalClose?.addEventListener("click", closeAttributeModal);
  attributeModalCancel?.addEventListener("click", closeAttributeModal);

  attributeModalSave?.addEventListener("click", () => {
    if (!attributeModalList) return;
    const selectedAttrs = [];
    attributeModalList.querySelectorAll("input[data-attribute-token]").forEach((input) => {
      if (input.checked && input.dataset.attributeToken) {
        selectedAttrs.push(input.dataset.attributeToken);
      }
    });
    applyAttributesToSelection(selectedAttrs);
    closeAttributeModal();
  });

  seatEditClose?.addEventListener("click", closeSeatEditModal);
  seatEditCancel?.addEventListener("click", closeSeatEditModal);
  seatEditSave?.addEventListener("click", () => {
    if (!seatEditList) return;
    const seatMap = new Map(seats.map(s => [s.seatId, s]));
    let changed = false;
    let priceRegionChanged = false;
    seatEditList.querySelectorAll(".edit-item").forEach((item) => {
      const seatId = item.dataset.seatId;
      const seat = seatMap.get(seatId);
      if (!seat) return;

      const nameInput = item.querySelector("input[data-role='seat-name']");
      const attrSelect = item.querySelector("select[data-role='seat-attribute']");
      const priceSelect = item.querySelector("select[data-role='seat-price-region']");
      const entrySelect = item.querySelector("select[data-role='seat-entry']");

      const nextName = (nameInput?.value || "").trim();
      if ((seat.name || "") !== nextName) {
        seat.name = nextName;
        changed = true;
      }

      const attrValue = attrSelect?.value || "";
      const originalAttrs = JSON.parse(item.dataset.attrOriginal || "[]");
      if (attrValue !== "__multiple__") {
        const nextAttrs = attrValue ? [attrValue] : [];
        const same = JSON.stringify(nextAttrs) === JSON.stringify(originalAttrs);
        if (!same) {
          seat.attributes = nextAttrs;
          changed = true;
        }
      }

      const entryValue = entrySelect?.value || "-";
      if ((seat.entryVia || "-") !== entryValue) {
        seat.entryVia = entryValue;
        changed = true;
      }

      if (priceSelect) {
        const nextRegionId = priceSelect.value || "";
        const currentRegionId = getSeatDirectPriceRegionId(seat);
        if (nextRegionId !== currentRegionId) {
          priceRegionChanged = setSeatDirectPriceRegion(seatId, nextRegionId) || priceRegionChanged;
        }
      }
    });

    if (priceRegionChanged) {
      savePriceRegionsToStorage();
      renderPriceRegionList();
      updatePriceRegionUi();
      updatePriceRegionStatus();
      if (showPriceRegions) renderCanvas();
    }
    if (changed) {
      updateCodeFromSeats();
      updateEntryPointUi();
      renderCanvas();
    }
    closeSeatEditModal();
  });

  rowEditClose?.addEventListener("click", closeRowEditModal);
  rowEditCancel?.addEventListener("click", closeRowEditModal);
  sectionEditClose?.addEventListener("click", closeSectionEditModal);
  sectionEditCancel?.addEventListener("click", closeSectionEditModal);
  sectionAddRowBtn?.addEventListener("click", () => {
    if (!sectionEditTargetId) return;
    addSectionRowDraft();
  });
  sectionEditSave?.addEventListener("click", () => {
    if (!sectionEditList) return;
    let changed = false;
    let seatsChanged = false;
    const sectionItem = sectionEditList.querySelector(".edit-item");
    const sectionId = sectionItem?.dataset.sectionId || sectionEditTargetId;
    if (sectionId) {
      const nameInput = sectionItem?.querySelector("input[data-role='section-name']");
      const nextName = (nameInput?.value || "").trim() || sectionId;
      if (nextName.length > SECTION_NAME_MAX) {
        alert(`Section name must be ${SECTION_NAME_MAX} characters or fewer.`);
        return;
      }
      if (isDuplicateSectionName(sectionId, nextName)) {
        alert(`Section name "${nextName}" is already in use.`);
        return;
      }
      if (nextName !== (sectionItem?.dataset?.nameOriginal || "")) {
        changed = updateSectionName(sectionId, nextName) || changed;
      }
    }
    const { drafts, errors } = collectSectionRowDrafts();
    if (errors.length) {
      alert(errors.join("\n"));
      return;
    }
    if (sectionId && drafts.length) {
      seatsChanged = addRowsToSection(sectionId, drafts);
      changed = seatsChanged || changed;
    }
    if (changed) {
      if (seatsChanged) {
        updateCountsAfterSeatChange();
        updatePriceRegionStatus();
        updateEntryPointUi();
      }
      updateCodeFromSeats();
      const newText = originalLines.join("\n");
      if (codePane.value !== newText) {
        codePane.value = newText;
      }
      renderCanvas();
      hasUnsavedChanges = true;
      updateSaveButton();
      saveSessionToLocalStorage();
      pushHistorySnapshot();
    }
    closeSectionEditModal();
  });
  rowEditList?.addEventListener("click", (e) => {
    const btn = e.target.closest("[data-role='row-add-seat']");
    if (!btn) return;
    const rowEl = btn.closest(".edit-item");
    const rowId = rowEl?.dataset?.rowId;
    if (!rowId) return;
    const state = rowEditState.get(rowId);
    if (!state) return;
    state.addCount += 1;
    const meta = rowEl.querySelector("[data-role='row-add-meta']");
    if (meta) meta.textContent = `Pending: ${state.addCount}`;
  });
  rowEditSave?.addEventListener("click", () => {
    if (!rowEditList) return;
    const rows = getSelectedRows();
    if (!rows.size) return;
    let changed = false;

    rowEditList.querySelectorAll(".edit-item").forEach((rowEl) => {
      const rowId = rowEl.dataset.rowId;
      const rowSeats = rows.get(rowId);
      if (!rowSeats) return;

      const nameInput = rowEl.querySelector("input[data-role='row-name']");
      const startInput = rowEl.querySelector("input[data-role='row-start']");
      const dirSelect = rowEl.querySelector("select[data-role='row-direction']");

      const nextName = (nameInput?.value || "").trim() || rowId;
      if (nextName && rowSeats[0]?.rowName !== nextName) {
        changed = updateRowName(rowId, nextName) || changed;
      }

      const startValue = parseInt(startInput?.value, 10);
      const state = rowEditState.get(rowId);
      if (state && state.addCount > 0) {
        const added = addSeatsToRow(rowId, rowSeats, state.addCount, nextName);
        changed = added || changed;
      }

      const startDefault = parseInt(rowEl.dataset.startDefault || "0", 10);
      const dirDefault = rowEl.dataset.dirDefault || "asc";
      const dirValue = dirSelect?.value || "asc";
      const shouldRenumber = (state && state.addCount > 0)
        || (!Number.isNaN(startDefault) && startValue !== startDefault)
        || dirValue !== dirDefault;
      if (shouldRenumber && Number.isFinite(startValue)) {
        applyRowNumbering(rowSeats, startValue, dirValue);
        changed = true;
      }
    });

    if (changed) {
      updateCountsAfterSeatChange();
      updatePriceRegionStatus();
      updateEntryPointUi();
      updateCodeFromSeats();
      const newText = originalLines.join("\n");
      if (codePane.value !== newText) {
        codePane.value = newText;
      }
      renderCanvas();
      hasUnsavedChanges = true;
      updateSaveButton();
      saveSessionToLocalStorage();
      pushHistorySnapshot();
    }
    closeRowEditModal();
  });

  document.addEventListener("click", (e) => {
    if (!seatContextMenu || !seatContextMenu.classList.contains("open")) return;
    if (seatContextMenu.contains(e.target)) return;
    closeSeatContextMenu();
  });

  document.addEventListener("keydown", (e) => {
    if (e.key === "Escape") {
      closeAllModals({
        confirmAltSectionManager: true,
        altSectionConfirmMessage: "You have unsaved changes. Close anyway?"
      });
    }
  });

  window.addEventListener("blur", closeSeatContextMenu);
  window.addEventListener("resize", closeSeatContextMenu);

  canvas.addEventListener("contextmenu", (e) => {
    const rect = canvas.getBoundingClientRect();
    const canvasX = e.clientX - rect.left;
    const canvasY = e.clientY - rect.top;
    const { worldX, worldY } = screenToWorld(canvasX, canvasY);

    if (currentTool === "reshape") {
      const hit = hitTestSeat(worldX, worldY);
      if (!hit || !hit.rowId) return;
      const rows = getSelectedRows();
      if (rows.size !== 1 || !rows.has(hit.rowId)) return;
      reshapePivotSeatId = hit.seatId;
      e.preventDefault();
      return;
    }

    const selected = getSelectedSeats();
    if (!selected.length) return;
    e.preventDefault();
    goodnessAnchorPoint = { x: worldX, y: worldY };
    openSeatContextMenu(e.clientX, e.clientY);
  });

  let selectionRectAdditive = false;

  canvas.addEventListener("mousemove", (e) => {
    const rect = canvas.getBoundingClientRect();
    const canvasX = e.clientX - rect.left;
    const canvasY = e.clientY - rect.top;
    const { worldX, worldY } = screenToWorld(canvasX, canvasY);

    if (isDraggingBackground) {
      backgroundState.originX = backgroundDragOriginX + (worldX - backgroundDragStartWorldX);
      backgroundState.originY = backgroundDragOriginY + (worldY - backgroundDragStartWorldY);
      renderCanvas();
      return;
    }

    // Pan
    if (isPanning) {
      const dx = e.clientX - panStartX;
      const dy = e.clientY - panStartY;
      translateX = panStartTranslateX + dx;
      translateY = panStartTranslateY + dy;
      renderCanvas();
      return;
    }

    // Rotation-drag
    if (isRotatingSelection && rotateStartSnapshot && rotatePivot) {
      const snapshotMap = rotateSnapshotById || new Map(rotateStartSnapshot.map(s => [s.seatId, s]));
      if (!rotateSnapshotById) {
        rotateSnapshotById = snapshotMap;
      }
      const currentAngle = Math.atan2(worldY - rotatePivot.y, worldX - rotatePivot.x);
      const snapStep = (5 * Math.PI) / 180;
      let delta = currentAngle - rotateStartAngle;
      if (e.ctrlKey) {
        delta = Math.round(delta / snapStep) * snapStep;
      }
      if (Math.abs(delta) > 1e-6) {
        hasRotatedDuringDrag = true;
      }
      const cosA = Math.cos(delta);
      const sinA = Math.sin(delta);

      for (const s of seats) {
        if (!s.selected) continue;
        const start = snapshotMap.get(s.seatId);
        if (!start) continue;
        const dx = start.vx - rotatePivot.x;
        const dy = start.vy - rotatePivot.y;
        const rotatedX = rotatePivot.x + dx * cosA - dy * sinA;
        const rotatedY = rotatePivot.y + dx * sinA + dy * cosA;
        s.vx = rotatedX;
        s.vy = rotatedY;
        s.centerX = rotatedX;
        s.centerY = rotatedY;
      }

      renderCanvas();
      return;
    }

    // Bend-drag
    if (isBendingSelection && bendRowsData && bendRowsData.length) {
      const rowData = bendRowsData[0];
      const rowId = bendActiveRowId || rowData.first.rowId || rowData.last.rowId || "";

      if (bendDragTarget === "start") {
        rowData.first.vx = worldX;
        rowData.first.vy = worldY;
        rowData.first.centerX = worldX;
        rowData.first.centerY = worldY;
      } else if (bendDragTarget === "end") {
        rowData.last.vx = worldX;
        rowData.last.vy = worldY;
        rowData.last.centerX = worldX;
        rowData.last.centerY = worldY;
      } else if (bendDragTarget === "anchor") {
        const axes = getRowAxisVectors(rowData);
        if (e.shiftKey && axes) {
          const { mid, perp } = axes;
          const offset = (worldX - mid.x) * perp.x + (worldY - mid.y) * perp.y;
          bendControlPoint = { x: mid.x + perp.x * offset, y: mid.y + perp.y * offset };
        } else {
          bendControlPoint = { x: worldX, y: worldY };
        }
      }

      hasBentDuringDrag = true;
      applyRowBend(rowData, rowId);
      renderCanvas();
      return;
    }

    // Reshape-drag
    if (isReshapingRow && reshapeRowSeats && reshapeDragTarget && reshapeSnapshotById) {
      applyReshapeDrag(reshapeDragTarget, worldX, worldY, e.shiftKey);
      renderCanvas();
      return;
    }

    // Resize-drag
    if (isResizingSelection && resizeStartSnapshot && resizePivot && resizeStartVector) {
      const snapshotMap = resizeSnapshotById || new Map(resizeStartSnapshot.map(s => [s.seatId, s]));
      if (!resizeSnapshotById) resizeSnapshotById = snapshotMap;

      const dx = worldX - resizePivot.x;
      const dy = worldY - resizePivot.y;
      let scaleX = resizeStartVector.x === 0 ? 1 : dx / resizeStartVector.x;
      let scaleY = resizeStartVector.y === 0 ? 1 : dy / resizeStartVector.y;

      // LСҖs axlar fСЧr kant-handtag
      if (resizeHandleId === "n" || resizeHandleId === "s") {
        scaleX = 1;
      } else if (resizeHandleId === "e" || resizeHandleId === "w") {
        scaleY = 1;
      }

      // Skydda mot 0/NaN
      if (!Number.isFinite(scaleX) || Math.abs(scaleX) < 0.0001) scaleX = 0.0001 * Math.sign(scaleX || 1);
      if (!Number.isFinite(scaleY) || Math.abs(scaleY) < 0.0001) scaleY = 0.0001 * Math.sign(scaleY || 1);

      if (Math.abs(scaleX - 1) > 1e-6 || Math.abs(scaleY - 1) > 1e-6) {
        hasResizedDuringDrag = true;
      }

      for (const s of seats) {
        if (!s.selected) continue;
        const start = snapshotMap.get(s.seatId);
        if (!start) continue;
        const relX = start.vx - resizePivot.x;
        const relY = start.vy - resizePivot.y;
        const newX = resizePivot.x + relX * scaleX;
        const newY = resizePivot.y + relY * scaleY;
        s.vx = newX;
        s.vy = newY;
        s.centerX = newX;
        s.centerY = newY;
      }

      renderCanvas();
      return;
    }

    // Move-drag
    if (isDraggingSelection && dragStartSnapshot) {
      const dxWorld = worldX - dragStartWorldX;
      const dyWorld = worldY - dragStartWorldY;

      const snapshotById = new Map();
      for (const snap of dragStartSnapshot) {
        snapshotById.set(snap.seatId, snap);
      }

      for (const s of seats) {
        if (!s.selected) continue;
        const start = snapshotById.get(s.seatId);
        if (!start) continue;
        s.vx = start.vx + dxWorld;
        s.vy = start.vy + dyWorld;
        s.centerX = start.centerX + dxWorld;
        s.centerY = start.centerY + dyWorld;
      }

      renderCanvas();
      return;
    }

    // Ruta-markering live
    if (selectionRectActive) {
      rectEndCanvasX = canvasX;
      rectEndCanvasY = canvasY;
      renderCanvas();
      return;
    }

    // Hover-seat
    if (showHoverInfo && lastVisibleSeatCount <= HOVER_VISIBLE_LIMIT) {
      const hit = hitTestSeat(worldX, worldY);
      hoverSeat = hit || null;

      if (hoverSeat) {
        const priceRegionLookups = buildPriceRegionLookups();
        const priceRegionName = getSeatPriceRegionName(hoverSeat, priceRegionLookups);
        const attributesText = (hoverSeat.attributes && hoverSeat.attributes.length)
          ? hoverSeat.attributes.join(", ")
          : "-";
        const tooltipLines = [];
        if (hoverSeat.sectionId || hoverSeat.sectionName) {
          tooltipLines.push(
            `<strong>Section:</strong> ${hoverSeat.sectionName || hoverSeat.sectionId}`
          );
        }
        if (hoverSeat.rowName || hoverSeat.rowId) {
          tooltipLines.push(
            `<strong>Row:</strong> ${hoverSeat.rowName || hoverSeat.rowId}`
          );
        }
        tooltipLines.push(
          `<strong>Seat:</strong> ${hoverSeat.name}`
        );
        tooltipLines.push(
          `<strong>SeatId:</strong> ${hoverSeat.seatId || "-"}`
        );
        const entryViaText = (hoverSeat.entryVia && hoverSeat.entryVia !== "-") ? hoverSeat.entryVia : "-";
        tooltipLines.push(`<strong>Entry:</strong> ${entryViaText}`);
        tooltipLines.push(`<strong>Price region:</strong> ${priceRegionName || "-"}`);
        const goodnessValue = Number(hoverSeat.goodness);
        const goodnessText = Number.isFinite(goodnessValue) ? formatNumber(goodnessValue) : "0";
        tooltipLines.push(`<strong>Goodness:</strong> ${goodnessText}`);
        tooltipLines.push(`<strong>Attributes:</strong> ${attributesText}`);

        tooltipEl.innerHTML = tooltipLines.join("<br/>");
        tooltipEl.style.left = (e.clientX + 8) + "px";
        tooltipEl.style.top = (e.clientY + 8) + "px";
      }

      renderCanvas();
    } else {
      hoverSeat = null;
    }
  });

  canvas.addEventListener("mouseup", (e) => {
    if (isDraggingBackground) {
      isDraggingBackground = false;
      saveSessionToLocalStorage();
      return;
    }
    if (isPanning) {
      isPanning = false;
      canvasContainer.classList.remove("panning");
    }

    if (isRotatingSelection) {
      const didRotate = hasRotatedDuringDrag;
      isRotatingSelection = false;
      hasRotatedDuringDrag = false;
      rotateStartSnapshot = null;
      rotateSnapshotById = null;
      rotatePivot = null;
      rotateStartAngle = 0;

      if (didRotate) {
        // Rotation klar -> historik + kod + save-knapp
        pushHistorySnapshot();
        hasUnsavedChanges = true;
        updateCodeFromSeats();
        updateSaveButton();
      }
    }

    if (isBendingSelection) {
      const didBend = hasBentDuringDrag;
      isBendingSelection = false;
      hasBentDuringDrag = false;
      bendStartSnapshot = null;
      // Behåll anchor/handle mellan interaktioner; nollställ bara drag-target
      bendDragTarget = null;

      if (didBend) {
        pushHistorySnapshot();
        hasUnsavedChanges = true;
        updateCodeFromSeats();
        updateSaveButton();
      }
    }

    if (isReshapingRow) {
      const didReshape = !!reshapeDragTarget;
      isReshapingRow = false;
      reshapeDragTarget = null;
      reshapeStartSnapshot = null;
      reshapeSnapshotById = null;
      reshapeRowSeats = null;

      if (didReshape) {
        pushHistorySnapshot();
        hasUnsavedChanges = true;
        updateCodeFromSeats();
        updateSaveButton();
      }
    }

    if (isResizingSelection) {
      const didResize = hasResizedDuringDrag;
      isResizingSelection = false;
      hasResizedDuringDrag = false;
      resizeStartSnapshot = null;
      resizeSnapshotById = null;
      resizePivot = null;
      resizeStartBounds = null;
      resizeHandleId = null;
      resizeStartVector = null;

      if (didResize) {
        pushHistorySnapshot();
        hasUnsavedChanges = true;
        updateCodeFromSeats();
        updateSaveButton();
      }
    }

    if (isDraggingSelection) {
      isDraggingSelection = false;
      dragStartSnapshot = null;

      // Flytten är klar -> historik + kod + save-knapp
      pushHistorySnapshot();
      hasUnsavedChanges = true;
      updateCodeFromSeats();
      updateSaveButton();
      return;
    }

    if (selectionRectActive) {
      selectionRectActive = false;

      const x1 = Math.min(rectStartCanvasX, rectEndCanvasX);
      const y1 = Math.min(rectStartCanvasY, rectEndCanvasY);
      const x2 = Math.max(rectStartCanvasX, rectEndCanvasX);
      const y2 = Math.max(rectStartCanvasY, rectEndCanvasY);

      const worldMinX = (x1 - translateX) / scale;
      const worldMaxX = (x2 - translateX) / scale;
      const worldMinY = (y1 - translateY) / scale;
      const worldMaxY = (y2 - translateY) / scale;

      selectByRect(
        { minX: worldMinX, maxX: worldMaxX, minY: worldMinY, maxY: worldMaxY },
        selectionRectAdditive
      );
      selectionRectAdditive = false;
    }
  });

  canvas.addEventListener("mouseleave", () => {
    hoverSeat = null;
    if (isDraggingBackground) {
      isDraggingBackground = false;
      saveSessionToLocalStorage();
    }
    if (isPanning) {
      isPanning = false;
      canvasContainer.classList.remove("panning");
    }
    if (isRotatingSelection) {
      const didRotate = hasRotatedDuringDrag;
      isRotatingSelection = false;
      hasRotatedDuringDrag = false;
      rotateStartSnapshot = null;
      rotateSnapshotById = null;
      rotatePivot = null;
      rotateStartAngle = 0;

      if (didRotate) {
        pushHistorySnapshot();
        hasUnsavedChanges = true;
        updateCodeFromSeats();
        updateSaveButton();
      }
    }
    if (isBendingSelection) {
      const didBend = hasBentDuringDrag;
      isBendingSelection = false;
      hasBentDuringDrag = false;
      bendStartSnapshot = null;
      bendDragTarget = null;

      if (didBend) {
        pushHistorySnapshot();
        hasUnsavedChanges = true;
        updateCodeFromSeats();
        updateSaveButton();
      }
    }
    if (isReshapingRow) {
      const didReshape = !!reshapeDragTarget;
      isReshapingRow = false;
      reshapeDragTarget = null;
      reshapeStartSnapshot = null;
      reshapeSnapshotById = null;
      reshapeRowSeats = null;

      if (didReshape) {
        pushHistorySnapshot();
        hasUnsavedChanges = true;
        updateCodeFromSeats();
        updateSaveButton();
      }
    }
    if (isResizingSelection) {
      const didResize = hasResizedDuringDrag;
      isResizingSelection = false;
      hasResizedDuringDrag = false;
      resizeStartSnapshot = null;
      resizeSnapshotById = null;
      resizePivot = null;
      resizeStartBounds = null;
      resizeHandleId = null;
      resizeStartVector = null;

      if (didResize) {
        pushHistorySnapshot();
        hasUnsavedChanges = true;
        updateCodeFromSeats();
        updateSaveButton();
      }
    }
    if (isDraggingSelection) {
      isDraggingSelection = false;
      dragStartSnapshot = null;

      pushHistorySnapshot();
      hasUnsavedChanges = true;
      updateCodeFromSeats();
      updateSaveButton();
    }
    if (selectionRectActive) {
      selectionRectActive = false;
    }
    renderCanvas();
  });

  canvas.addEventListener("dblclick", (e) => {
    if (currentTool !== "bend") return;
    const rows = getSelectedRows();
    if (rows.size !== 1) return;

    const rowSeats = rows.values().next().value;
    if (!rowSeats || rowSeats.length < 2) return;

    const rect = canvas.getBoundingClientRect();
    const canvasX = e.clientX - rect.left;
    const canvasY = e.clientY - rect.top;
    const { worldX, worldY } = screenToWorld(canvasX, canvasY);

    const anchor = bendControlPoint;
    if (!anchor) return;
    const screenAnchor = worldToScreen(anchor.x, anchor.y);
    const hitRadius = 10;
    const dist = Math.hypot(screenAnchor.x - canvasX, screenAnchor.y - canvasY);
    if (dist > hitRadius) return;

    bendControlPoint = null;
    const rowData = computeRowEndpoints(rowSeats);
    redistributeRowLinear(rowData);

    pushHistorySnapshot();
    hasUnsavedChanges = true;
    updateCodeFromSeats();
    updateSaveButton();
    renderCanvas();
  });

  // --- Tangentbord / genvägar ---
  window.addEventListener("keydown", (e) => {
    const key = e.key.toLowerCase();
    const activeEl = document.activeElement;
    const isTextInput =
      activeEl &&
      (activeEl.tagName === "INPUT" ||
        activeEl.tagName === "TEXTAREA" ||
        activeEl.isContentEditable);

    // Ctrl/Cmd-kombinationer
    if (e.ctrlKey || e.metaKey) {
      if (key === "s") {
        e.preventDefault();
        if (!saveBtn.disabled) saveBtn.click();
        return;
      }
      if (key === "o") {
        e.preventDefault();
        openFileBtnTop.click();
        return;
      }
      if (key === "d") {
        e.preventDefault();
        deselectToolBtn.click();
        return;
      }
      if (key === "a") {
        e.preventDefault();
        selectAllSeats();
        return;
      }
      if (!e.shiftKey && key === "z") {
        e.preventDefault();
        undoLast();
        return;
      }
      return;
    }

    // Om man skriver i textfält: inga fler genvägar
    if (isTextInput) return;

    if (key === "h") {
      e.preventDefault();
      if (helpOverlay && helpOverlay.style.display === "flex") {
        closeHelpModal();
      } else {
        openHelpModal();
      }
      return;
    }

    if (key === "m") {
      if (openSectionManagerBtn?.disabled) return;
      e.preventDefault();
      if (altSectionManagerOverlay && altSectionManagerOverlay.style.display === "flex") {
        altSectionManagerClose?.click();
      } else {
        openAltSectionManager();
      }
      return;
    }

    // Piltangenter: nudge
    if (e.key === "ArrowUp" || e.key === "ArrowDown" || e.key === "ArrowLeft" || e.key === "ArrowRight") {
      e.preventDefault();
      const step = e.shiftKey ? 10 : 1;
      let dx = 0, dy = 0;
      if (e.key === "ArrowUp") dy = -step;
      if (e.key === "ArrowDown") dy = step;
      if (e.key === "ArrowLeft") dx = -step;
      if (e.key === "ArrowRight") dx = step;
      const didMove = nudgeSelection(dx, dy);
      if (didMove) {
        pushHistorySnapshot();
        hasUnsavedChanges = true;
        updateCodeFromSeats();
        updateSaveButton();
        renderCanvas();
      }
      return;
    }

    // Home = zooma så att allt syns
    if (e.key === "Home") {
      e.preventDefault();
      zoomToFitAllSeats();
      return;
    }
    // Tangent 1 = zoom-to-fit (bekväm snabbe)
    if (key === "1") {
      e.preventDefault();
      zoomToFitAllSeats();
      return;
    }

    // Enkeltangenter
    switch (key) {
      case "s":
        e.preventDefault();
        modeSectionBtn.click();
        break;
      case "d":
        e.preventDefault();
        modeRowBtn.click();
        break;
      case "f":
        e.preventDefault();
        modeSeatBtn.click();
        break;
      case "i":
        e.preventDefault();
        if (seatLabelMode === "none") setSeatLabelMode("row");
        else if (seatLabelMode === "row") setSeatLabelMode("seat");
        else if (seatLabelMode === "seat") setSeatLabelMode("seatId");
        else setSeatLabelMode("none");
        break;
      case "o":
        e.preventDefault();
        if (overlayMode === "none") setOverlayMode("price");
        else if (overlayMode === "price") setOverlayMode("goodness");
        else setOverlayMode("none");
        break;
      case "v":
        e.preventDefault();
        if (!moveToolBtn.disabled) moveToolBtn.click();
        break;
      case "p":
        e.preventDefault();
        panToolBtn.click();
        break;
      case "r":
        e.preventDefault();
        if (!rotateToolBtn.disabled) rotateToolBtn.click();
        break;
      case "z":
        e.preventDefault();
        if (!resizeToolBtn.disabled) resizeToolBtn.click();
        break;
      case "b":
        e.preventDefault();
        if (!bendToolBtn.disabled) bendToolBtn.click();
        break;
      case "c":
        e.preventDefault();
        selectToolBtn.click();
        break;
      case "q":
        e.preventDefault();
        resetRowBtn.click();
        break;
      case "t":
        e.preventDefault();
        makeTableBtn.click();
        break;
      case "e":
        e.preventDefault();
        if (!reshapeRowBtn.disabled) reshapeRowBtn.click();
        break;
      default:
        break;
    }
  });

  // --- Verktyg-knappar ---
  function setButtonActive(btn, isActive) {
    btn.classList.toggle("active", isActive);
    btn.classList.toggle("c-button--active", isActive);
  }

  function setTool(tool) {
    currentTool = tool;
    setButtonActive(selectToolBtn, tool === "select");
    setButtonActive(panToolBtn, tool === "pan");
    setButtonActive(moveToolBtn, tool === "move");
    setButtonActive(rotateToolBtn, tool === "rotate");
    setButtonActive(resizeToolBtn, tool === "resize");
    setButtonActive(bendToolBtn, tool === "bend");
    setButtonActive(reshapeRowBtn, tool === "reshape");
    if (tool === "bend") {
      ensureBendDefaults();
      renderCanvas();
    }
  }

  selectToolBtn.addEventListener("click", () => setTool("select"));
  panToolBtn.addEventListener("click", () => setTool("pan"));
  moveToolBtn.addEventListener("click", () => {
    if (!moveToolBtn.disabled) setTool("move");
  });
  rotateToolBtn.addEventListener("click", () => {
    if (!rotateToolBtn.disabled) setTool("rotate");
  });
  resizeToolBtn.addEventListener("click", () => {
    if (!resizeToolBtn.disabled) setTool("resize");
  });
  bendToolBtn.addEventListener("click", () => {
    if (!bendToolBtn.disabled) setTool("bend");
  });
  reshapeRowBtn.addEventListener("click", () => {
    if (!reshapeRowBtn.disabled) setTool("reshape");
  });
  resetRowBtn.addEventListener("click", () => {
    if (resetRowBtn.disabled) return;
    const didReset = resetSelectedRowsLinear();
    if (didReset) {
      pushHistorySnapshot();
      hasUnsavedChanges = true;
      updateCodeFromSeats();
      updateSaveButton();
      renderCanvas();
    }
  });
  makeTableBtn.addEventListener("click", () => {
    if (makeTableBtn.disabled) return;
    const didMake = makeTableFromSelectedRows();
    if (didMake) {
      pushHistorySnapshot();
      hasUnsavedChanges = true;
      updateCodeFromSeats();
      updateSaveButton();
      renderCanvas();
    }
  });

  deselectToolBtn.addEventListener("click", () => {
    let changed = false;
    for (const s of seats) {
      if (s.selected) {
        s.selected = false;
        s.selectedAt = null;
        changed = true;
      }
    }
    if (changed) {
      lastSelectedSeatId = null;
    }
    if (changed) {
      pushHistorySnapshot();    // ångra deselect
      updateMoveButtonState();
      renderCanvas();
    }
    setTool("select");
  });

  updateOutlinesBtn.addEventListener("click", () => {
    updateOutlinesFromSeats();
  });
  updateRowIdsBtn.addEventListener("click", () => {
    updateRowIdsFromSeats();
  });

  // --- Markeringsnivå-knappar ---
  function setSelectionMode(mode) {
    selectionMode = mode;
    setButtonActive(modeSectionBtn, mode === "section");
    setButtonActive(modeRowBtn, mode === "row");
    setButtonActive(modeSeatBtn, mode === "seat");
  }

  modeSectionBtn.addEventListener("click", () => setSelectionMode("section"));
  modeRowBtn.addEventListener("click", () => setSelectionMode("row"));
  modeSeatBtn.addEventListener("click", () => setSelectionMode("seat"));

  // --- Bakgrundsbild ---
  bgLoadBtn.addEventListener("click", () => bgFileInput.click());
  bgFileInput.addEventListener("change", () => {
    const file = bgFileInput.files && bgFileInput.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = async (e) => {
      const dataUrl = e.target?.result;
      if (typeof dataUrl === "string") {
        await loadBackgroundFromDataUrl(dataUrl);
      }
    };
    reader.readAsDataURL(file);
  });
  bgToggleBtn?.addEventListener("click", () => {
    setBackgroundEnabled(!backgroundState.enabled);
  });
  bgMoveBtn?.addEventListener("click", () => {
    setBackgroundMoveMode(!backgroundMoveMode);
  });
  bgDeleteBtn?.addEventListener("click", () => {
    clearBackgroundImage();
  });
  bgOpacityRange.addEventListener("input", (e) => {
    const val = parseFloat(e.target.value);
    setBackgroundOpacity(val);
  });
  bgScaleRange.addEventListener("input", (e) => {
    const val = parseFloat(e.target.value);
    setBackgroundScale(val);
  });
  viewHoverToggle?.addEventListener("change", (e) => {
    showHoverInfo = e.target.checked;
    if (!showHoverInfo) {
      hoverSeat = null;
      tooltipEl.style.display = "none";
    }
    renderCanvas();
    saveSessionToLocalStorage();
  });
  viewSectionNamesToggle?.addEventListener("change", (e) => {
    showSectionNames = e.target.checked;
    renderCanvas();
    saveSessionToLocalStorage();
  });
  [viewOverlayNone, viewOverlayPrice, viewOverlayGoodness].forEach((el) => {
    el?.addEventListener("change", (e) => {
      if (!e.target.checked) return;
      setOverlayMode(e.target.value, false, true);
    });
  });
  [viewSeatLabelNone, viewSeatLabelRow, viewSeatLabelSeat, viewSeatLabelSeatId].forEach((el) => {
    el?.addEventListener("change", (e) => {
      if (!e.target.checked) return;
      setSeatLabelMode(e.target.value || "none", false);
      saveSessionToLocalStorage();
    });
  });

  // --- Align-knappar ---
  function rotateSelectionByDegrees(degrees) {
    if (!Number.isFinite(degrees) || degrees === 0) return false;
    const selected = getSelectedSeats();
    if (!selected.length) return false;
    const bounds = getSelectionBounds(selected);
    if (!bounds) return false;

    const radians = (degrees * Math.PI) / 180;
    const cosA = Math.cos(radians);
    const sinA = Math.sin(radians);
    const cx = bounds.centerX;
    const cy = bounds.centerY;

    for (const s of selected) {
      const dx = s.vx - cx;
      const dy = s.vy - cy;
      const rotatedX = cx + dx * cosA - dy * sinA;
      const rotatedY = cy + dx * sinA + dy * cosA;
      s.vx = rotatedX;
      s.vy = rotatedY;
      s.centerX = rotatedX;
      s.centerY = rotatedY;
    }
    return true;
  }

  function flipSelection(axis) {
    const selected = getSelectedSeats();
    if (!selected.length) return false;
    const bounds = getSelectionBounds(selected);
    if (!bounds) return false;

    const centerX = bounds.centerX;
    const centerY = bounds.centerY;
    let changed = false;

    if (axis === "horizontal") {
      for (const s of selected) {
        const newX = centerX * 2 - s.vx;
        if (newX !== s.vx) {
          s.vx = newX;
          s.centerX = newX;
          changed = true;
        }
      }
    } else if (axis === "vertical") {
      for (const s of selected) {
        const newY = centerY * 2 - s.vy;
        if (newY !== s.vy) {
          s.vy = newY;
          s.centerY = newY;
          changed = true;
        }
      }
    }
    return changed;
  }

  function readRotationDegrees() {
    const raw = (rotateDegreesInput?.value || "").trim();
    const value = parseFloat(raw);
    if (!Number.isFinite(value)) {
      alert("Enter rotation degrees.");
      return null;
    }
    return value;
  }


  function handleRotate(direction) {
    const value = readRotationDegrees();
    if (!Number.isFinite(value) || value === 0) return;
    const degrees = direction === "ccw" ? -Math.abs(value) : Math.abs(value);
    const didRotate = rotateSelectionByDegrees(degrees);
    if (didRotate) {
      pushHistorySnapshot();
      hasUnsavedChanges = true;
      updateCodeFromSeats();
      updateSaveButton();
      renderCanvas();
    }
  }

  function handleFlip(axis) {
    const didFlip = flipSelection(axis);
    if (didFlip) {
      pushHistorySnapshot();
      hasUnsavedChanges = true;
      updateCodeFromSeats();
      updateSaveButton();
      renderCanvas();
    }
  }

  function handleAlign(mode) {
    const didAlign = alignSelectedSeats(mode);
    if (didAlign) {
      pushHistorySnapshot();
      hasUnsavedChanges = true;
      updateCodeFromSeats();
      updateSaveButton();
      renderCanvas();
    }
  }
  const ALIGN_GROUPING_KEY = "arenaDesignerAlignGrouping";

  function readAlignGroupingMode() {
    try {
      const stored = localStorage.getItem(ALIGN_GROUPING_KEY);
      if (stored === "individual" || stored === "group") return stored;
    } catch (_) {}
    return "group";
  }

  function writeAlignGroupingMode(mode) {
    try {
      localStorage.setItem(ALIGN_GROUPING_KEY, mode);
    } catch (_) {}
  }

  function setAlignGroupingMode(mode, persist = true) {
    alignGroupingMode = mode === "individual" ? "individual" : "group";
    if (alignGroupingSelect) alignGroupingSelect.value = alignGroupingMode;
    if (persist) writeAlignGroupingMode(alignGroupingMode);
  }

  setAlignGroupingMode(readAlignGroupingMode(), false);
  setGoodnessRangeCount(DEFAULT_GOODNESS_RANGE_COUNT, false);

  alignGroupingSelect?.addEventListener("change", (e) => {
    setAlignGroupingMode(e.target.value);
  });
  alignTopBtn.addEventListener("click", () => handleAlign("top"));
  alignBottomBtn.addEventListener("click", () => handleAlign("bottom"));
  alignLeftBtn.addEventListener("click", () => handleAlign("left"));
  alignRightBtn.addEventListener("click", () => handleAlign("right"));
  alignCenterHBtn.addEventListener("click", () => handleAlign("centerH"));
  alignCenterVBtn.addEventListener("click", () => handleAlign("centerV"));
  flipVBtn?.addEventListener("click", () => handleFlip("vertical"));
  flipHBtn?.addEventListener("click", () => handleFlip("horizontal"));
  rotateCcwBtn?.addEventListener("click", () => handleRotate("ccw"));
  rotateCwBtn?.addEventListener("click", () => handleRotate("cw"));

  // --- Sektion: helpers & modal ---
  function newSeat(name = "1") {
    return { id: crypto.randomUUID ? crypto.randomUUID() : String(Math.random()), name };
  }

  function newRow(name = "Row") {
    return { id: crypto.randomUUID ? crypto.randomUUID() : String(Math.random()), name, seats: [newSeat("1"), newSeat("2")] };
  }

  function computeNextSectionId() {
    const ids = new Set();
    sectionNames.forEach((_, key) => ids.add(key));
    seats.forEach(s => { if (s.sectionId) ids.add(s.sectionId); });
    sectionDrafts?.forEach(d => { if (d.sectionId) ids.add(d.sectionId); });
    let maxMajor = 0;
    ids.forEach(id => {
      const parts = String(id).split(".");
      const major = parseInt(parts[0], 10);
      if (Number.isFinite(major) && major > maxMajor) maxMajor = major;
    });
    const nextMajor = maxMajor > 0 ? maxMajor + 1 : 1;
    return `${nextMajor}.1`;
  }

  function getExistingSectionIdsForImport() {
    const ids = new Set();
    sectionNames.forEach((_, key) => ids.add(key));
    seats.forEach((s) => {
      if (s.sectionId) ids.add(s.sectionId);
    });
    return ids;
  }

  function computeNextSectionIdFromIds(ids) {
    let maxMajor = 0;
    ids.forEach((id) => {
      const parts = String(id).split(".");
      const major = parseInt(parts[0], 10);
      if (Number.isFinite(major) && major > maxMajor) maxMajor = major;
    });
    const nextMajor = maxMajor > 0 ? maxMajor + 1 : 1;
    return `${nextMajor}.1`;
  }

  function buildRowDefinitionFromExcelCells(rowName, seatCells, sheetName, rowIndex) {
    const errors = [];
    const blocks = [];
    let parts = [];
    let hasSeat = false;
    let pendingRowBreak = false;
    let run = [];

    const isEmptyCell = (value) => value == null || String(value).trim() === "";
    const isGapCell = (value) => {
      const text = String(value).trim();
      return text === "-";
    };
    const flushRun = () => {
      if (!run.length) return;
      parts.push(`list(${run.join("-")})`);
      hasSeat = true;
      run = [];
    };
    const finishBlock = () => {
      flushRun();
      if (parts.length && hasSeat) blocks.push(parts.join(""));
      parts = [];
      hasSeat = false;
      run = [];
    };

    seatCells.forEach((value) => {
      if (isEmptyCell(value)) {
        flushRun();
        parts.push("-");
        pendingRowBreak = true;
        return;
      }
      if (pendingRowBreak) {
        finishBlock();
        pendingRowBreak = false;
      }
      if (isGapCell(value)) {
        flushRun();
        parts.push("-");
        return;
      }
      const num = Number(value);
      if (!Number.isFinite(num)) {
        errors.push(`Sheet "${sheetName}" row ${rowIndex}: invalid seat value "${value}".`);
        return;
      }
      run.push(num);
    });
    finishBlock();

    const joined = blocks.join("||");
    return {
      text: joined ? `${rowName}: ${joined}` : "",
      errors
    };
  }

  function buildRowTextFromExcelSheet(sheet, sheetName) {
    const errors = [];
    if (!sheet || !sheet["!ref"] || typeof XLSX === "undefined") {
      return { text: "", errors };
    }
    const range = XLSX.utils.decode_range(sheet["!ref"]);
    const lines = [];

    for (let r = range.s.r; r <= range.e.r; r++) {
      const rowValues = [];
      let hasValue = false;
      for (let c = range.s.c; c <= range.e.c; c++) {
        const cellAddress = XLSX.utils.encode_cell({ r, c });
        const cell = sheet[cellAddress];
        const value = cell ? cell.v : null;
        rowValues.push(value);
        if (value != null && String(value).trim() !== "") hasValue = true;
      }
      if (!hasValue) continue;

      const rowLabelValue = rowValues[0];
      const rowName = (rowLabelValue != null && String(rowLabelValue).trim() !== "")
        ? String(rowLabelValue).trim()
        : String(r + 1);

      const seatCells = rowValues.slice(1);
      while (seatCells.length && (seatCells[seatCells.length - 1] == null || String(seatCells[seatCells.length - 1]).trim() === "")) {
        seatCells.pop();
      }
      if (!seatCells.length) continue;

      const rowResult = buildRowDefinitionFromExcelCells(rowName, seatCells, sheetName, r + 1);
      if (rowResult.errors.length) errors.push(...rowResult.errors);
      if (rowResult.text) lines.push(rowResult.text);
    }

    return { text: lines.join("\n"), errors };
  }

  function extractNameListFromExcelSheet(sheet, columnIndex = 0) {
    const names = [];
    if (!sheet || !sheet["!ref"] || typeof XLSX === "undefined") {
      return names;
    }
    const range = XLSX.utils.decode_range(sheet["!ref"]);
    for (let r = range.s.r; r <= range.e.r; r++) {
      const cellAddress = XLSX.utils.encode_cell({ r, c: columnIndex });
      const cell = sheet[cellAddress];
      if (!cell || cell.v == null) continue;
      const name = String(cell.v).trim();
      if (!name) continue;
      names.push(name);
    }
    return names;
  }

  function importEntryPointsFromExcelSheet(sheet) {
    const names = extractNameListFromExcelSheet(sheet, 0);
    if (!names.length) return 0;
    const existing = new Set(entryPoints.map(ep => normalizeEntryPointName(ep.name).toLowerCase()));
    const addedNames = new Set();
    let added = 0;
    names.forEach((raw) => {
      const name = normalizeEntryPointName(raw);
      const key = name.toLowerCase();
      if (!name || name === "-") return;
      if (existing.has(key) || addedNames.has(key)) return;
      entryPoints.push({ id: buildEntryPointId(), name });
      addedNames.add(key);
      added += 1;
    });
    if (added) {
      saveEntryPointsToStorage();
      renderEntryPointList();
      updateEntryPointUi();
    }
    return added;
  }

  function importPriceRegionsFromExcelSheet(sheet) {
    const names = extractNameListFromExcelSheet(sheet, 0);
    if (!names.length) return 0;
    const normalized = names.map(normalizePriceRegionName).filter(Boolean);
    if (!normalized.length) return 0;
    const existingKeys = new Set(priceRegions.map(region => normalizePriceRegionKey(region.name)));
    const { duplicates, tooLong } = getPriceRegionNameIssues(normalized, existingKeys);
    const issueMessage = buildPriceRegionIssueMessage(duplicates, tooLong);
    if (issueMessage) {
      alert(issueMessage);
      return 0;
    }
    const addedNames = new Set();
    let added = 0;
    normalized.forEach((name) => {
      const key = normalizePriceRegionKey(name);
      if (addedNames.has(key)) return;
      const id = `${Date.now()}${Math.floor(Math.random() * 1000)}`;
      const color = generatePriceRegionColor(priceRegions.length);
      priceRegions.push({ id, name, color, sections: [], rows: [], seats: [] });
      addedNames.add(key);
      added += 1;
    });
    if (added) {
      savePriceRegionsToStorage();
      renderPriceRegionList();
      updatePriceRegionUi();
      if (showPriceRegions) renderCanvas();
    }
    return added;
  }

  async function importSectionsFromExcelFile(file) {
    if (!file) return;
    if (typeof XLSX === "undefined") {
      alert("Excel import requires the XLSX library. Check your internet connection and try again.");
      return;
    }
    let workbook;
    try {
      const buffer = await file.arrayBuffer();
      workbook = XLSX.read(buffer, { type: "array" });
    } catch (err) {
      alert("Could not read the Excel file.");
      console.warn("Excel import failed:", err);
      return;
    }
    if (!workbook || !workbook.SheetNames || !workbook.SheetNames.length) {
      alert("No sheets found in the Excel file.");
      return;
    }

    if (sectionDrafts.length && !confirm("Import will replace the current sections in the modal. Continue?")) {
      return;
    }

    const errors = [];
    const drafts = [];
    const usedIds = getExistingSectionIdsForImport();
    let entrySheet = null;
    let priceRegionSheet = null;

    workbook.SheetNames.forEach((sheetName) => {
      const sheet = workbook.Sheets[sheetName];
      if (!sheet) return;
      const sheetKey = String(sheetName || "").trim().toLowerCase();
      if (sheetKey === "entry") {
        entrySheet = sheet;
        return;
      }
      if (sheetKey === "priceregion") {
        priceRegionSheet = sheet;
        return;
      }
      const sectionSheetName = String(sheetName || "").trim();
      if (sectionSheetName.length > SECTION_NAME_MAX) {
        errors.push(`Section name "${sectionSheetName}" exceeds ${SECTION_NAME_MAX} characters.`);
        return;
      }
      const res = buildRowTextFromExcelSheet(sheet, sectionSheetName);
      if (res.errors.length) errors.push(...res.errors);
      if (!res.text.trim()) return;

      const parsed = parseRowsText(res.text);
      if (parsed.errors.length) {
        parsed.errors.forEach((err) => {
          errors.push(`${sectionSheetName}: ${err}`);
        });
      }

      const sectionId = computeNextSectionIdFromIds(usedIds);
      usedIds.add(sectionId);
      drafts.push({
        sectionId,
        sectionName: sectionSheetName,
        color: "#14a0f4",
        rows: parsed.rows,
        rawRowText: res.text,
        continuousStartSeat: 1
      });
    });

    if (errors.length) {
      alert("Excel import failed:\n" + errors.join("\n"));
      return;
    }
    const entryAdded = entrySheet ? importEntryPointsFromExcelSheet(entrySheet) : 0;
    const priceRegionAdded = priceRegionSheet ? importPriceRegionsFromExcelSheet(priceRegionSheet) : 0;
    if (!drafts.length && !entryAdded && !priceRegionAdded) {
      alert("No sections with seat data found in the Excel file.");
      return;
    }
    if (drafts.length) {
      sectionDrafts = drafts;
      sectionRawText.clear();
      sectionDrafts.forEach((draft) => {
        if (draft.sectionId) sectionRawText.set(draft.sectionId, draft.rawRowText || "");
      });
      activeSectionDraftId = sectionDrafts[0].sectionId;
      setSectionDirty(true);
      renderAltSectionCards();
      renderAltSectionDetail();
    }
  }

  // buildSectionDraftsFromSeats borttagen i denna version (endast nya sektioner skapas i modalen)

  function resetSectionDrafts() {
    sectionDrafts = [];
    activeSectionDraftId = null;
    sectionRawText.clear();
    sectionDirty = false;
    altRowLines = [];
    altActiveLineIndex = null;
    altContinuousStartSeat = 1;
  }

  function setSectionDirty(isDirty) {
    sectionDirty = isDirty;
    if (altSectionDirtyFlag) {
      altSectionDirtyFlag.textContent = isDirty ? "Unsaved changes" : "Saved";
      altSectionDirtyFlag.style.color = isDirty ? "#c12e44" : "#5b6673";
    }
    if (altSeatNumberingModeSelect) {
      altSeatNumberingModeSelect.disabled = !getActiveDraft();
    }
  }

  function parseRowsText(text) {
    const lines = text.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
    const parsed = [];
    const errors = [];
    lines.forEach((line, lineIdx) => {
      if (!line.includes(":")) {
        errors.push(`Missing colon (:) in line: "${line}"`);
        return;
      }
      const [rawName, rest] = line.split(":", 2);
      const rowName = rawName.trim() || "Row";
      const restText = rest == null ? "" : String(rest);
      const normalized = restText.replace(/\s+/g, "");
      const expanded = normalized.replace(/\|(-+)\|/g, "$1||");
      const rowBlocks = expanded.split("||"); // double pipe = new RowId; add a gap only when none is explicit.
      let slotCursor = 0; // X-slot over hela textraden
      rowBlocks.forEach((block, blockIdx) => {
        const blockText = block.trim();
        if (!blockText) return;
        const intervals = blockText.split("|").map(s => s.trim()).filter(Boolean);
        const items = [];
        const seatsArr = [];
        intervals.forEach((seg, idx) => {
          const compactSeg = seg.replace(/\s+/g, "");
          if (!compactSeg) return;
          const tokens = compactSeg.match(/list\([^\)]*\)|\d+\s*,\s*\d+|\d+|-+/g) || [];
          if (!tokens.length || tokens.join("") !== compactSeg) {
            errors.push(`Invalid row syntax "${seg}" in row "${rowName}" (line ${lineIdx + 1})`);
            return;
          }
          tokens.forEach((token) => {
            if (token.startsWith("list(") && token.endsWith(")")) {
              const inner = token.slice(5, -1);
              if (!inner || !/^\d+(?:[-,;]\d+)*$/.test(inner)) {
                errors.push(`Invalid list syntax "${token}" in row "${rowName}" (line ${lineIdx + 1})`);
                return;
              }
              const values = inner.split(/[-,;]/).filter(Boolean);
              values.forEach((value) => {
                const n = Number(value);
                if (Number.isFinite(n) && Number.isInteger(n)) {
                  const seatObj = newSeat(String(n));
                  items.push({ ...seatObj, pos: slotCursor });
                  seatsArr.push(seatObj);
                  slotCursor += 1;
                } else {
                  errors.push(`Invalid list value "${value}" in row "${rowName}" (line ${lineIdx + 1})`);
                }
              });
              return;
            }
            if (token.startsWith("-")) {
              for (let g = 0; g < token.length; g++) {
                items.push({
                  id: crypto.randomUUID ? crypto.randomUUID() : String(Math.random()),
                  name: "",
                  isGap: true,
                  pos: slotCursor
                });
                slotCursor += 1;
              }
              return;
            }
            const cleaned = token.replace(/\s+/g, "");
            if (cleaned.includes(",")) {
              const parts = cleaned.split(",").map(x => x.trim()).filter(Boolean);
              const start = Number(parts[0]);
              const end = Number(parts[1]);
              if (!Number.isInteger(start) || !Number.isInteger(end)) {
                errors.push(`Invalid range "${token}" in row "${rowName}" (line ${lineIdx + 1})`);
                return;
              }
              const step = start <= end ? 1 : -1;
              for (let v = start; step === 1 ? v <= end : v >= end; v += step) {
                const seatObj = newSeat(String(v));
                items.push({ ...seatObj, pos: slotCursor });
                seatsArr.push(seatObj);
                slotCursor += 1;
              }
              return;
            }
            const n = Number(cleaned);
            if (Number.isFinite(n) && Number.isInteger(n)) {
              const seatObj = newSeat(String(n));
              items.push({ ...seatObj, pos: slotCursor });
              seatsArr.push(seatObj);
              slotCursor += 1;
            } else {
              errors.push(`Invalid number "${token}" in row "${rowName}" (line ${lineIdx + 1})`);
            }
          });
          if (idx < intervals.length - 1) {
            items.push({ id: crypto.randomUUID ? crypto.randomUUID() : String(Math.random()), name: "", isGap: true, pos: slotCursor });
            slotCursor += 1;
          }
        });
        parsed.push({
          id: crypto.randomUUID ? crypto.randomUUID() : String(Math.random()),
          name: rowName,
          seats: seatsArr.length ? seatsArr : [newSeat("1")],
          items: items.length ? items : [{ ...newSeat("1"), pos: slotCursor }],
          rowLine: lineIdx,
          rawTextLine: `${rowName}: ${restText}`
        });
        const endsWithGap = items.length ? !!items[items.length - 1].isGap : false;
        if (blockIdx < rowBlocks.length - 1 && !endsWithGap) {
          slotCursor += 1;
        }
      });
    });
    return { rows: parsed.length ? parsed : [newRow("Row 1")], errors };
  }

  function getActiveDraft() {
    return sectionDrafts.find((d) => d.sectionId === activeSectionDraftId) || null;
  }

  function createAltId() {
    return crypto.randomUUID ? crypto.randomUUID() : String(Math.random());
  }

  function createAltBlock() {
    return {
      id: createAltId(),
      rowId: createAltId(),
      startSeat: 1,
      direction: 1,
      lastDirection: { x: 1, y: 0 },
      manualStartSeat: false,
      autoStartSeatAssigned: false
    };
  }

  function normalizeAltContinuousStartSeat(value) {
    const parsed = parseInt(value, 10);
    return Number.isFinite(parsed) ? parsed : 1;
  }

  function computeAltContinuousStartFromLines(lines) {
    let maxNext = null;
    (lines || []).forEach((line) => {
      if (!line || !line.blocks) return;
      line.blocks.forEach((block) => {
        const count = getAltSeatCount(line, block.id);
        const start = normalizeAltContinuousStartSeat(block.startSeat);
        const next = start + Math.max(0, count);
        if (maxNext == null || next > maxNext) maxNext = next;
      });
    });
    return maxNext != null ? maxNext : 1;
  }

  function setAltContinuousStartSeat(value, persist = true) {
    altContinuousStartSeat = normalizeAltContinuousStartSeat(value);
    if (altContinuousStartSeatInput) {
      altContinuousStartSeatInput.value = String(altContinuousStartSeat);
    }
    if (persist) {
      const draft = getActiveDraft();
      if (draft) draft.continuousStartSeat = altContinuousStartSeat;
    }
  }

  function updateAltContinuousControls() {
    const hasDraft = !!getActiveDraft();
    const show = hasDraft && altSeatNumberingMode === "continuous";
    if (altContinuousControls) {
      altContinuousControls.hidden = !show;
    }
    if (altContinuousStartSeatInput) {
      altContinuousStartSeatInput.disabled = !show;
      if (show && !altContinuousStartSeatInput.value) {
        setAltContinuousStartSeat(altContinuousStartSeat, false);
      }
    }
    if (altContinuousSkipBtn) altContinuousSkipBtn.disabled = !show;
  }

  function syncAltContinuousStartSeatFromDraft(draft) {
    if (!draft) {
      setAltContinuousStartSeat(1, false);
      return;
    }
    const stored = Number(draft.continuousStartSeat);
    if (Number.isFinite(stored)) {
      setAltContinuousStartSeat(stored, false);
      return;
    }
    const computed = computeAltContinuousStartFromLines(draft.altRowLines || altRowLines);
    setAltContinuousStartSeat(computed, true);
  }

  function recalculateAltRowStartSeats() {
    if (altSeatNumberingMode === "continuous") return;
    let runningSeat = 1;
    altRowLines.forEach((line) => {
      if (!line.blocks.length) return;
      if (altSeatNumberingMode === "row") {
        runningSeat = 1;
      }
      line.blocks.forEach((block) => {
        if (block.manualStartSeat) {
          runningSeat = block.startSeat;
        } else {
          block.startSeat = runningSeat;
        }
        const count = getAltSeatCount(line, block.id);
        runningSeat = block.startSeat + Math.max(0, count);
      });
    });
  }

  function buildAltLines(rowCount) {
    const count = Math.max(1, Math.floor(rowCount || 0));
    const lines = [];
    for (let i = 0; i < count; i++) {
      const block = createAltBlock();
      lines.push({
        lineIndex: i,
        name: `${i + 1}`,
        blocks: [block],
        activeBlockId: block.id,
        slots: []
      });
    }
    return lines;
  }

  function buildAltLinesFromDraft(draft) {
    const rows = draft?.rows || [];
    if (!rows.length) return [];
    const maxLine = rows.reduce((max, row) => {
      const idx = Number.isFinite(row.rowLine) ? row.rowLine : 0;
      return Math.max(max, idx);
    }, 0);
    const lineCount = maxLine + 1;
    const lines = [];
    for (let i = 0; i < lineCount; i++) {
      lines.push({
        lineIndex: i,
        name: `${i + 1}`,
        blocks: [],
        activeBlockId: null,
        slots: []
      });
    }
    rows.forEach((row) => {
      const lineIndex = Number.isFinite(row.rowLine) ? row.rowLine : 0;
      const line = lines[lineIndex];
      if (!line) return;
      if (row.name && line.name !== row.name) line.name = row.name;
      const block = createAltBlock();
      block.rowId = row.id || block.rowId;
      line.blocks.push(block);
      if (!line.activeBlockId) line.activeBlockId = block.id;

      const fallbackSeats = row.seats || [];
      const items = row.items && row.items.length
        ? row.items
        : fallbackSeats.map((seat, idx) => ({ ...seat, pos: idx }));
      items.forEach((item) => {
        const pos = Number.isFinite(item.pos) ? item.pos : 0;
        const slot = item.isGap
          ? { type: "gap", blockId: block.id, pos }
          : { type: "seat", blockId: block.id, name: item.name || "", pos };
        line.slots[pos] = slot;
      });
    });
    return lines;
  }

  function getAltActiveLine() {
    if (!altRowLines.length || altActiveLineIndex == null) return null;
    return altRowLines[altActiveLineIndex] || null;
  }

  function getAltActiveBlock(line) {
    if (!line) return null;
    return line.blocks.find(b => b.id === line.activeBlockId) || line.blocks[0] || null;
  }

  function getAltBlockById(blockId) {
    if (!blockId) return null;
    for (const line of altRowLines) {
      if (!line || !line.blocks) continue;
      const block = line.blocks.find(b => b.id === blockId);
      if (block) return { line, block };
    }
    return null;
  }

  function setAltTool(tool) {
    altSectionTool = tool === "draw" ? "draw" : "select";
    if (altToolSelectBtn) altToolSelectBtn.classList.toggle("c-button--active", altSectionTool === "select");
    if (altToolDrawBtn) altToolDrawBtn.classList.toggle("c-button--active", altSectionTool === "draw");
  }

  function setAltActiveLine(index) {
    if (index == null || index < 0 || index >= altRowLines.length) {
      altActiveLineIndex = null;
      return;
    }
    altActiveLineIndex = index;
    const line = altRowLines[index];
    if (line && !line.activeBlockId && line.blocks[0]) {
      line.activeBlockId = line.blocks[0].id;
    }
  }

  function getAltCanvasMetrics() {
    if (!altSectionCanvas) return null;
    const wrapEl = altSectionCanvasWrap || altSectionCanvas.parentElement;
    const wrapRect = wrapEl?.getBoundingClientRect();
    const rect = altSectionCanvas.getBoundingClientRect();
    const wrapStyle = wrapEl ? getComputedStyle(wrapEl) : null;
    const padX = wrapStyle ? (parseFloat(wrapStyle.paddingLeft) + parseFloat(wrapStyle.paddingRight)) : 0;
    const padY = wrapStyle ? (parseFloat(wrapStyle.paddingTop) + parseFloat(wrapStyle.paddingBottom)) : 0;
    const viewportWidth = Math.max(200, (wrapEl?.clientWidth || wrapRect?.width || rect.width || 900) - padX);
    const viewportHeight = Math.max(200, (wrapEl?.clientHeight || wrapRect?.height || rect.height || 520) - padY);
    const dpr = window.devicePixelRatio || 1;
    const rowCount = Math.max(1, altRowLines.length || 1);
    const padding = 16;
    const labelWidth = 44;
    const rowHeight = ALT_ROW_HEIGHT;
    const rowGap = ALT_ROW_GAP;
    const contentHeight = padding * 2 + rowCount * rowHeight + Math.max(0, rowCount - 1) * rowGap;
    const height = Math.max(viewportHeight, contentHeight);
    const contentWidth = padding * 2 + labelWidth + (ALT_MAX_SLOTS - 1) * ALT_SEAT_SPACING + ALT_SEAT_RADIUS * 2;
    const width = Math.max(viewportWidth, contentWidth);
    altSectionCanvas.width = width * dpr;
    altSectionCanvas.height = height * dpr;
    altSectionCanvas.style.width = `${width}px`;
    altSectionCanvas.style.height = `${height}px`;
    const ctx = altSectionCanvas.getContext("2d");
    if (!ctx) return null;
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    return {
      ctx,
      width,
      height,
      padding,
      labelWidth,
      rowHeight,
      rowGap,
      seatStartX: padding + labelWidth,
      seatEndX: padding + labelWidth + (ALT_MAX_SLOTS - 1) * ALT_SEAT_SPACING
    };
  }

  function getAltLineIndexFromY(y, metrics) {
    if (!metrics) return null;
    const rel = y - metrics.padding;
    if (rel < 0) return null;
    const rowBlock = metrics.rowHeight + metrics.rowGap;
    const idx = Math.floor(rel / rowBlock);
    if (idx < 0 || idx >= altRowLines.length) return null;
    const offset = rel - idx * rowBlock;
    if (offset > metrics.rowHeight) return null;
    return idx;
  }

  function clampAltPointToRowBand(point, lineIndex, metrics) {
    if (!metrics) return point;
    const rowBlock = metrics.rowHeight + metrics.rowGap;
    const top = metrics.padding + lineIndex * rowBlock;
    const bottom = top + metrics.rowHeight;
    const x = Math.min(metrics.seatEndX, Math.max(metrics.seatStartX, point.x));
    const y = Math.min(bottom - ALT_SEAT_RADIUS, Math.max(top + ALT_SEAT_RADIUS, point.y));
    return { x, y };
  }

  function getAltSlotPosition(slot, lineIndex, slotIndex, metrics) {
    const rowBlock = metrics.rowHeight + (metrics.rowGap || 0);
    const centerY = metrics.padding + lineIndex * rowBlock + metrics.rowHeight / 2;
    const x = metrics.seatStartX + slotIndex * ALT_SEAT_SPACING;
    return { x, y: centerY };
  }

  function buildAltSeatPoints(start, end) {
    const dx = end.x - start.x;
    const dy = 0;
    const len = Math.hypot(dx, dy);
    const count = Math.max(1, Math.floor(len / ALT_SEAT_SPACING) + 1);
    const points = [];
    if (count === 1) {
      points.push({ x: start.x, y: start.y });
      return points;
    }
    for (let i = 0; i < count; i++) {
      const t = i / (count - 1);
      points.push({ x: start.x + dx * t, y: start.y + dy * t });
    }
    return points;
  }

  function renumberAltBlockSeats(line, block) {
    const seats = [];
    line.slots.forEach((slot, idx) => {
      if (slot && slot.type === "seat" && slot.blockId === block.id) {
        seats.push({ slot, idx });
      }
    });
    if (!seats.length) return;
    const direction = block.direction === -1 ? -1 : 1;
    seats.sort((a, b) => direction === -1 ? b.idx - a.idx : a.idx - b.idx);
    seats.forEach((entry, idx) => {
      entry.slot.name = String(block.startSeat + idx);
    });
  }

  function syncAltDraftFromLines(draft) {
    if (!draft || !draft.altRowLines) return;
    const rows = [];
    draft.altRowLines.forEach((line) => {
      line.blocks.forEach((block) => {
        const rowId = block.rowId || createAltId();
        block.rowId = rowId;
        const row = {
          id: rowId,
          name: line.name,
          rowLine: line.lineIndex,
          seats: [],
          items: []
        };
        line.slots.forEach((slot, idx) => {
          if (!slot) return;
          if (slot.type === "seat" && slot.blockId === block.id) {
            const seatObj = newSeat(slot.name || "");
            row.seats.push(seatObj);
            row.items.push({ ...seatObj, pos: idx });
          }
          if (slot.type === "gap" && slot.blockId === block.id) {
            row.items.push({
              id: createAltId(),
              name: "",
              isGap: true,
              pos: idx
            });
          }
        });
        rows.push(row);
      });
    });
    draft.rows = rows;
    draft.rawRowText = "";
    if (draft.sectionId) sectionRawText.set(draft.sectionId, "");
  }

  function renderAltSectionCards() {
    if (!altSectionCardsEl) return;
    altSectionCardsEl.innerHTML = "";
    sectionDrafts.forEach((draft) => {
      const card = document.createElement("div");
      card.className = "section-card" + (draft.sectionId === activeSectionDraftId ? " section-card--active" : "");
      card.dataset.sectionId = draft.sectionId;

      const colorDot = document.createElement("div");
      colorDot.className = "section-card__color";
      colorDot.style.background = draft.color || "#14a0f4";

      const body = document.createElement("div");
      body.className = "section-card__body";

      const header = document.createElement("div");
      header.className = "section-card__header";

      const title = document.createElement("div");
      title.className = "section-card__name";
      const name = (draft.sectionName || "").trim();
      const id = (draft.sectionId || "").trim();
      if (name && id) {
        title.textContent = `${name} (${id})`;
      } else {
        title.textContent = name || id || "Unnamed section";
      }
      title.title = "Section name";

      const renameBtn = document.createElement("button");
      renameBtn.className = "section-card__rename";
      renameBtn.type = "button";
      renameBtn.title = "Rename section";
      renameBtn.setAttribute("aria-label", "Rename section");
      renameBtn.textContent = "✎";

      const meta = document.createElement("div");
      meta.className = "section-card__meta";
      const rowCount = draft.rows.length;
      const seatCount = draft.rows.reduce((sum, r) => sum + (r.seats?.length || 0), 0);
      meta.innerHTML = `<span>${rowCount} rows</span><span>${seatCount} seats</span>`;

      header.appendChild(title);
      header.appendChild(renameBtn);
      body.appendChild(header);
      body.appendChild(meta);

      card.appendChild(colorDot);
      card.appendChild(body);
      altSectionCardsEl.appendChild(card);
    });
  }

  function clearAltSectionDetail() {
    altRowLines = [];
    altActiveLineIndex = null;
    if (!altSectionCanvas) return;
    const ctx = altSectionCanvas.getContext("2d");
    if (ctx) ctx.clearRect(0, 0, altSectionCanvas.width, altSectionCanvas.height);
    setAltTooltip("", 0, 0, false);
  }

  function renderAltSectionCanvas() {
    if (!altSectionCanvas) return;
    const metrics = getAltCanvasMetrics();
    if (!metrics) return;
    const { ctx, width, height, padding, rowHeight, labelWidth } = metrics;
    ctx.clearRect(0, 0, width, height);
    ctx.fillStyle = "#f7faff";
    ctx.fillRect(0, 0, width, height);

    const lineCount = Math.max(1, altRowLines.length || 1);
    const rowBlock = rowHeight + metrics.rowGap;
    const maxSlots = ALT_MAX_SLOTS;
    for (let i = 0; i < lineCount; i++) {
      const top = padding + i * rowBlock;
      const bottom = top + rowHeight;
      const isActive = altActiveLineIndex === i;
      drawAltRowBox(ctx, padding, top, width - padding * 2, rowHeight, 8, isActive);
      ctx.fillStyle = "#2e3c47";
      ctx.font = "12px 'Ubuntu', sans-serif";
      ctx.textAlign = "left";
      ctx.textBaseline = "middle";
      const line = altRowLines[i];
      const rawLabel = line ? (line.name || `${i + 1}`) : `${i + 1}`;
      const label = rawLabel.replace(/^(Row|Rad)\s*/i, "") || `${i + 1}`;
      ctx.fillText(label, padding + 4, top + rowHeight / 2);

      if (line) {
        const activeBlock = getAltActiveBlock(line);
        for (let idx = 0; idx < maxSlots; idx++) {
          const slot = line.slots[idx] ?? null;
          const pos = getAltSlotPosition(slot, i, idx, metrics);
          if (slot) {
            slot.renderX = pos.x;
            slot.renderY = pos.y;
          }
          if (slot && slot.type === "seat") {
            const isActiveSeat = activeBlock && slot.blockId === activeBlock.id;
            ctx.fillStyle = isActiveSeat ? "#14a0f4" : "#ffffff";
            ctx.strokeStyle = isActiveSeat ? "#0c6ba5" : "#9fb0c4";
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, ALT_SEAT_RADIUS, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            ctx.fillStyle = isActiveSeat ? "#ffffff" : "#2e3c47";
            ctx.font = "9px 'Ubuntu', sans-serif";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(slot.name || "", pos.x, pos.y + 0.5);
          } else {
            ctx.strokeStyle = "#aeb9c8";
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, ALT_SEAT_RADIUS - 1, 0, Math.PI * 2);
            ctx.stroke();
          }
        }
      }
    }

    if (altIsDrawing && altDrawStart && altDrawEnd && altDrawLineIndex != null) {
      const points = buildAltSeatPoints(altDrawStart, altDrawEnd);
      ctx.strokeStyle = "#14a0f4";
      ctx.setLineDash([4, 4]);
      ctx.beginPath();
      ctx.moveTo(altDrawStart.x, altDrawStart.y);
      ctx.lineTo(altDrawEnd.x, altDrawStart.y);
      ctx.stroke();
      ctx.setLineDash([]);
      points.forEach((pt) => {
        ctx.fillStyle = "#14a0f4";
        ctx.beginPath();
        ctx.arc(pt.x, pt.y, ALT_SEAT_RADIUS - 1, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    updateAltControls();
  }

  function renderAltSectionDetail() {
    const draft = getActiveDraft();
    if (!draft) {
      clearAltSectionDetail();
      updateAltControls();
      return;
    }
    if (!draft.altRowLines) {
      draft.altRowLines = buildAltLinesFromDraft(draft);
      if (!draft.altRowLines.length) {
        draft.altRowLines = buildAltLines(1);
      }
    }
    altRowLines = draft.altRowLines;
    if (altActiveLineIndex == null || altActiveLineIndex >= altRowLines.length) {
      altActiveLineIndex = altRowLines.length ? 0 : null;
    }
    syncAltContinuousStartSeatFromDraft(draft);
    renderAltSectionCanvas();
  }

  function openAltSectionManager() {
    resetSectionDrafts();
    altRowLines = [];
    altActiveLineIndex = null;
    altIsDrawing = false;
    altDrawStart = null;
    altDrawEnd = null;
    altDrawLineIndex = null;
    setAltTooltip("", 0, 0, false);
    setAltTool("select");
    altSeatNumberingMode = altSeatNumberingModeSelect?.value === "continuous" ? "continuous" : "row";
    renderAltSectionCards();
    renderAltSectionDetail();
    setSectionDirty(false);
    if (altSectionManagerOverlay) altSectionManagerOverlay.style.display = "flex";
  }

  function closeAltSectionManager() {
    if (altSectionManagerOverlay) altSectionManagerOverlay.style.display = "none";
    setAltTooltip("", 0, 0, false);
  }

  function promptForRowCount(defaultValue = "10") {
    const raw = prompt("How many rows should the section have?", defaultValue);
    if (raw == null) return null;
    const count = parseInt(raw, 10);
    if (!Number.isFinite(count) || count <= 0) {
      alert("Row count must be a positive number.");
      return null;
    }
    return count;
  }

  function promptForSectionName(defaultValue = "") {
    const raw = prompt("Section name:", defaultValue);
    if (raw == null) return null;
    const name = raw.trim();
    if (!name) {
      alert("Section name is required.");
      return null;
    }
    if (name.length > SECTION_NAME_MAX) {
      alert(`Section name must be ${SECTION_NAME_MAX} characters or fewer.`);
      return null;
    }
    return name;
  }

  function renameDraftSection(draft) {
    if (!draft) return;
    const current = (draft.sectionName || draft.sectionId || "").trim();
    const nextName = promptForSectionName(current);
    if (nextName == null) return;
    if (nextName === current) return;
    draft.sectionName = nextName;
    setSectionDirty(true);
  }

  function addNewAltDraft(sectionName, rowCount) {
    const name = (sectionName || "").trim();
    if (!name) return;
    const newDraft = {
      sectionId: computeNextSectionId(),
      sectionName: name,
      color: "#14a0f4",
      rows: [],
      rawRowText: "",
      continuousStartSeat: 1
    };
    newDraft.altRowLines = buildAltLines(rowCount);
    syncAltDraftFromLines(newDraft);
    sectionDrafts.push(newDraft);
    activeSectionDraftId = newDraft.sectionId;
    altRowLines = newDraft.altRowLines;
    altActiveLineIndex = altRowLines.length ? 0 : null;
    setSectionDirty(true);
    renderAltSectionCards();
    renderAltSectionDetail();
  }

  function updateAltControls() {
    const hasDraft = !!getActiveDraft();
    const hasLine = hasDraft && altRowLines.length && altActiveLineIndex != null;
    const line = hasLine ? altRowLines[altActiveLineIndex] : null;
    const block = getAltActiveBlock(line);
    const hasBlock = !!block;
    if (altToolSelectBtn) altToolSelectBtn.disabled = !hasDraft;
    if (altToolDrawBtn) altToolDrawBtn.disabled = !hasDraft;
    if (altGapNewBtn) altGapNewBtn.disabled = !hasBlock;
    if (altReverseSeatOrderBtn) altReverseSeatOrderBtn.disabled = !hasBlock;
    if (altSetStartSeatBtn) altSetStartSeatBtn.disabled = !hasBlock;
    if (altAddSeatBtn) altAddSeatBtn.disabled = !hasBlock;
    if (altRemoveSeatBtn) altRemoveSeatBtn.disabled = !hasBlock;
    if (altSetStartRowBtn) altSetStartRowBtn.disabled = !hasDraft;
    if (altReverseRowOrderBtn) altReverseRowOrderBtn.disabled = !hasDraft;
    if (altSetRowsManualBtn) altSetRowsManualBtn.disabled = !hasDraft;
    if (altDuplicateRowBtn) altDuplicateRowBtn.disabled = !hasLine;
    if (altAddRowBtn) altAddRowBtn.disabled = !hasDraft;
    if (altClearRowBtn) altClearRowBtn.disabled = !hasLine;
    if (altClearAllRowsBtn) altClearAllRowsBtn.disabled = !hasDraft;
    if (altSeatNumberingModeSelect) altSeatNumberingModeSelect.disabled = !hasDraft;
    updateAltContinuousControls();
  }

  function getAltCanvasPoint(e) {
    if (!altSectionCanvas) return { x: 0, y: 0 };
    const rect = altSectionCanvas.getBoundingClientRect();
    return {
      x: e.clientX - rect.left,
      y: e.clientY - rect.top
    };
  }

  function getAltRowCenterY(lineIndex, metrics) {
    if (!metrics) return 0;
    const rowBlock = metrics.rowHeight + metrics.rowGap;
    return metrics.padding + lineIndex * rowBlock + metrics.rowHeight / 2;
  }

  function getAltSlotIndexFromX(x, metrics) {
    if (!metrics) return 0;
    const raw = (x - metrics.seatStartX) / ALT_SEAT_SPACING;
    const idx = Math.round(raw);
    return Math.max(0, Math.min(ALT_MAX_SLOTS - 1, idx));
  }

  function getAltLastSlotIndex(line, blockId = null) {
    if (!line || !line.slots) return -1;
    let last = -1;
    for (let i = 0; i < line.slots.length; i++) {
      const slot = line.slots[i];
      if (!slot) continue;
      if (blockId && slot.blockId !== blockId) continue;
      last = i;
    }
    return last;
  }

  function getAltSeatCount(line, blockId) {
    if (!line || !line.slots) return 0;
    let count = 0;
    for (let i = 0; i < line.slots.length; i++) {
      const slot = line.slots[i];
      if (slot && slot.type === "seat" && slot.blockId === blockId) count += 1;
    }
    return count;
  }

  function setAltTooltip(text, x, y, show) {
    if (!altSeatTooltip) return;
    if (!show) {
      altSeatTooltip.style.opacity = "0";
      return;
    }
    altSeatTooltip.textContent = text;
    altSeatTooltip.style.left = `${x + 12}px`;
    altSeatTooltip.style.top = `${y + 12}px`;
    altSeatTooltip.style.opacity = "1";
  }

  function drawAltRowBox(ctx, x, y, width, height, radius, active) {
    const r = Math.min(radius, height / 2, width / 2);
    ctx.save();
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + width - r, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + r);
    ctx.lineTo(x + width, y + height - r);
    ctx.quadraticCurveTo(x + width, y + height, x + width - r, y + height);
    ctx.lineTo(x + r, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
    ctx.closePath();
    ctx.strokeStyle = active ? "#6ba9d6" : "#d6dee8";
    ctx.lineWidth = active ? 1.4 : 1;
    ctx.setLineDash(active ? [] : [4, 4]);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.restore();
  }

  function findAltSeatHit(x, y, metrics) {
    for (let lineIndex = 0; lineIndex < altRowLines.length; lineIndex++) {
      const line = altRowLines[lineIndex];
      if (!line) continue;
      for (let idx = 0; idx < line.slots.length; idx++) {
        const slot = line.slots[idx];
        if (!slot || slot.type !== "seat") continue;
        const pos = getAltSlotPosition(slot, lineIndex, idx, metrics);
        const dist = Math.hypot(pos.x - x, pos.y - y);
        if (dist <= ALT_SEAT_RADIUS + 3) {
          return { lineIndex, blockId: slot.blockId };
        }
      }
    }
    return null;
  }

  function commitAltChange() {
    const draft = getActiveDraft();
    if (!draft) return;
    draft.altRowLines = altRowLines;
    if (altSeatNumberingModeSelect) {
      altSeatNumberingModeSelect.value = altSeatNumberingMode;
    }
    if (altSeatNumberingMode === "continuous") {
      altRowLines.forEach((line) => {
        line.blocks.forEach((block) => {
          if (getAltSeatCount(line, block.id) === 0) {
            block.autoStartSeatAssigned = false;
          }
        });
      });
    } else {
      recalculateAltRowStartSeats();
      altRowLines.forEach((line) => {
        line.blocks.forEach((block) => renumberAltBlockSeats(line, block));
      });
    }
    syncAltDraftFromLines(draft);
    setSectionDirty(true);
    renderAltSectionCards();
    renderAltSectionDetail();
  }

  function applyAltGap(sameBlock) {
    const line = getAltActiveLine();
    const block = getAltActiveBlock(line);
    if (!line || !block) return;
    const hasSeats = line.slots.some(slot => slot && slot.type === "seat" && slot.blockId === block.id);
    if (!hasSeats) {
      alert("Draw seats on the row before adding gaps.");
      return;
    }
    const seatCount = getAltSeatCount(line, block.id);
    if (sameBlock) {
      let insertIndex = getAltLastSlotIndex(line, block.id);
      insertIndex = insertIndex < 0 ? line.slots.length : insertIndex + 1;
      while (line.slots[insertIndex]) insertIndex += 1;
      line.slots[insertIndex] = { type: "gap", blockId: block.id };
    } else {
      const nextBlock = createAltBlock();
      nextBlock.direction = block.direction;
      nextBlock.startSeat = block.startSeat + seatCount;
      nextBlock.lastDirection = block.lastDirection;
      line.blocks.push(nextBlock);
      line.activeBlockId = nextBlock.id;
    }
    commitAltChange();
  }

  function applyAltReverseSeatOrder() {
    const line = getAltActiveLine();
    const block = getAltActiveBlock(line);
    if (!line || !block) return;
    block.direction *= -1;
    renumberAltBlockSeats(line, block);
    commitAltChange();
  }

  function applyAltSetStartSeat() {
    const line = getAltActiveLine();
    const block = getAltActiveBlock(line);
    if (!line || !block) return;
    const input = prompt("Start seat number:", String(block.startSeat));
    if (input == null) return;
    const next = parseInt(input, 10);
    if (!Number.isFinite(next)) {
      alert("Start seat must be a valid number.");
      return;
    }
    if (altSeatNumberingMode === "continuous") {
      setAltContinuousStartSeat(next, true);
      const hasSeats = line.slots.some(slot => slot && slot.type === "seat" && slot.blockId === block.id);
      if (!hasSeats) {
        block.startSeat = next;
        block.autoStartSeatAssigned = true;
      }
      block.manualStartSeat = false;
      commitAltChange();
      return;
    }
    block.startSeat = next;
    block.manualStartSeat = true;
    renumberAltBlockSeats(line, block);
    commitAltChange();
  }

  function applyAltSetStartRow() {
    if (!altRowLines.length) return;
    const current = altRowLines[0]?.name || "1";
    const input = prompt("Start row number:", current);
    if (input == null) return;
    const start = parseInt(input, 10);
    if (!Number.isFinite(start)) {
      alert("Row start must be a valid number.");
      return;
    }
    altRowLines.forEach((line, idx) => {
      line.name = String(start + idx);
    });
    commitAltChange();
  }

  function applyAltReverseRowOrder() {
    if (!altRowLines.length) return;
    const names = altRowLines.map((line, idx) => line.name || String(idx + 1)).reverse();
    altRowLines.forEach((line, idx) => {
      line.name = names[idx] || String(idx + 1);
    });
    commitAltChange();
  }

  function applyAltSetRowsManually() {
    if (!altRowLines.length) return;
    const current = altRowLines.map((line, idx) => line.name || String(idx + 1)).join(", ");
    const input = prompt("Enter row names separated by comma or new line:", current);
    if (input == null) return;
    const names = input.split(/[\n,]+/).map(s => s.trim()).filter(Boolean);
    if (!names.length) {
      alert("You must enter at least one row name.");
      return;
    }
    if (names.length !== altRowLines.length) {
      const diff = names.length - altRowLines.length;
      const action = diff > 0 ? `add ${diff} row${diff === 1 ? "" : "s"}` : `remove ${Math.abs(diff)} row${diff === -1 ? "" : "s"}`;
      if (!confirm(`You entered ${names.length} names but there are ${altRowLines.length} rows. This will ${action}. Continue?`)) {
        return;
      }
      if (diff > 0) {
        const baseIndex = altRowLines.length;
        for (let i = 0; i < diff; i++) {
          const block = createAltBlock();
          altRowLines.push({
            lineIndex: baseIndex + i,
            name: "",
            blocks: [block],
            activeBlockId: block.id,
            slots: []
          });
        }
      } else if (diff < 0) {
        altRowLines = altRowLines.slice(0, names.length);
        if (altActiveLineIndex != null && altActiveLineIndex >= altRowLines.length) {
          altActiveLineIndex = altRowLines.length ? altRowLines.length - 1 : null;
        }
      }
    }
    altRowLines.forEach((line, idx) => {
      line.lineIndex = idx;
      line.name = names[idx] || line.name || String(idx + 1);
    });
    commitAltChange();
  }

  function applyAltDuplicateRow() {
    if (altActiveLineIndex == null || !altRowLines.length) return;
    const source = altRowLines[altActiveLineIndex];
    if (!source) return;
    const isLineEmpty = (line) => !line || !line.slots.some(slot => slot);
    let targetIndex = -1;
    for (let i = altActiveLineIndex + 1; i < altRowLines.length; i++) {
      if (isLineEmpty(altRowLines[i])) {
        targetIndex = i;
        break;
      }
    }
    if (targetIndex < 0) {
      alert("No empty row available below to duplicate into.");
      return;
    }
    const target = altRowLines[targetIndex];
    const blockMap = new Map();
    const newBlocks = source.blocks.map((block) => {
      const clone = createAltBlock();
      clone.direction = block.direction;
      clone.startSeat = block.startSeat;
      clone.manualStartSeat = block.manualStartSeat;
      clone.lastDirection = { x: block.lastDirection?.x ?? 1, y: block.lastDirection?.y ?? 0 };
      blockMap.set(block.id, clone.id);
      return clone;
    });
    const newSlots = [];
    source.slots.forEach((slot, idx) => {
      if (!slot) return;
      const nextSlot = {
        type: slot.type,
        blockId: blockMap.get(slot.blockId) || newBlocks[0]?.id,
        name: slot.name || ""
      };
      newSlots[idx] = nextSlot;
    });
    target.blocks = newBlocks.length ? newBlocks : [createAltBlock()];
    target.activeBlockId = target.blocks[0].id;
    target.slots = newSlots;
    setAltActiveLine(targetIndex);
    commitAltChange();
  }

  function resetAltLine(line) {
    if (!line) return;
    const block = createAltBlock();
    line.blocks = [block];
    line.activeBlockId = block.id;
    line.slots = [];
  }

  function applyAltClearCurrentRow() {
    if (altActiveLineIndex == null || !altRowLines.length) return;
    const line = altRowLines[altActiveLineIndex];
    if (!line) return;
    resetAltLine(line);
    if (altSeatNumberingMode === "continuous") {
      const nextStart = computeAltContinuousStartFromLines(altRowLines);
      setAltContinuousStartSeat(nextStart, true);
    }
    commitAltChange();
  }

  function applyAltClearAllRows() {
    if (!altRowLines.length) return;
    if (!confirm("Clear all rows? This will remove all seats and gaps.")) return;
    altRowLines.forEach((line) => resetAltLine(line));
    if (altSeatNumberingMode === "continuous") {
      const nextStart = computeAltContinuousStartFromLines(altRowLines);
      setAltContinuousStartSeat(nextStart, true);
    }
    commitAltChange();
  }

  function getAltNextRowName() {
    const fallback = String(altRowLines.length + 1);
    if (!altRowLines.length) return fallback;
    const lastName = String(altRowLines[altRowLines.length - 1]?.name || "").trim();
    const numeric = Number(lastName);
    if (Number.isFinite(numeric) && String(numeric) === lastName) {
      return String(numeric + 1);
    }
    return fallback;
  }

  function applyAltAddRow() {
    if (!altRowLines.length) return;
    const block = createAltBlock();
    const nextIndex = altRowLines.length;
    altRowLines.push({
      lineIndex: nextIndex,
      name: getAltNextRowName(),
      blocks: [block],
      activeBlockId: block.id,
      slots: []
    });
    altRowLines.forEach((line, idx) => {
      line.lineIndex = idx;
    });
    setAltActiveLine(nextIndex);
    commitAltChange();
  }

  function applyAltAddSeat() {
    const line = getAltActiveLine();
    const block = getAltActiveBlock(line);
    if (!line || !block) return;
    const metrics = getAltCanvasMetrics();
    if (!metrics) return;
    const hadSeats = line.slots.some(slot => slot && slot.type === "seat" && slot.blockId === block.id);
    const lineIndex = line.lineIndex ?? altActiveLineIndex ?? 0;
    const centerY = getAltRowCenterY(lineIndex, metrics);
    let insertIndex = getAltLastSlotIndex(line, block.id);
    insertIndex = insertIndex < 0 ? 0 : insertIndex + 1;
    while (line.slots[insertIndex] && insertIndex < ALT_MAX_SLOTS) insertIndex += 1;
    if (insertIndex >= ALT_MAX_SLOTS) {
      alert(`Row is full (max ${ALT_MAX_SLOTS} seats).`);
      return;
    }
    const slotX = metrics.seatStartX + insertIndex * ALT_SEAT_SPACING;
    const clamped = clampAltPointToRowBand({ x: slotX, y: centerY }, lineIndex, metrics);
    let seatName = "";
    if (altSeatNumberingMode === "continuous") {
      const startValue = altContinuousStartSeat;
      if (!hadSeats) {
        block.startSeat = startValue;
        block.autoStartSeatAssigned = true;
      }
      seatName = String(startValue);
      setAltContinuousStartSeat(startValue + 1, true);
    }
    line.slots[insertIndex] = {
      type: "seat",
      blockId: block.id,
      name: seatName,
      x: clamped.x,
      y: clamped.y
    };
    if (altSeatNumberingMode !== "continuous") {
      renumberAltBlockSeats(line, block);
    }
    commitAltChange();
  }

  function applyAltRemoveSeat() {
    const line = getAltActiveLine();
    const block = getAltActiveBlock(line);
    if (!line || !block) return;
    for (let i = line.slots.length - 1; i >= 0; i--) {
      const slot = line.slots[i];
      if (slot && slot.type === "seat" && slot.blockId === block.id) {
        line.slots[i] = null;
        if (altSeatNumberingMode !== "continuous") {
          renumberAltBlockSeats(line, block);
        }
        commitAltChange();
        return;
      }
    }
  }

  function finalizeAltDraw() {
    if (!altIsDrawing) return;
    const lineIndex = altDrawLineIndex;
    const line = lineIndex != null ? altRowLines[lineIndex] : null;
    const block = getAltActiveBlock(line);
    const metrics = getAltCanvasMetrics();
    if (!line || !block || !metrics) {
      altIsDrawing = false;
      altDrawStart = null;
      altDrawEnd = null;
      altDrawLineIndex = null;
      setAltTooltip("", 0, 0, false);
      return;
    }
    const start = clampAltPointToRowBand(altDrawStart, lineIndex, metrics);
    const end = clampAltPointToRowBand(altDrawEnd, lineIndex, metrics);
    const centerY = getAltRowCenterY(lineIndex, metrics);
    start.y = centerY;
    end.y = centerY;
    const hadSeats = line.slots.some(slot => slot && slot.type === "seat" && slot.blockId === block.id);
    const points = buildAltSeatPoints(start, end);
    const leftX = Math.min(start.x, end.x);
    let startIndex = getAltSlotIndexFromX(leftX, metrics);
    const createdSlots = [];
    points.forEach((pt, idx) => {
      let slotIndex = startIndex + idx;
      if (slotIndex >= ALT_MAX_SLOTS) return;
      while (line.slots[slotIndex] && slotIndex < ALT_MAX_SLOTS) slotIndex += 1;
      if (slotIndex >= ALT_MAX_SLOTS) return;
      const slotX = metrics.seatStartX + slotIndex * ALT_SEAT_SPACING;
      const slot = {
        type: "seat",
        blockId: block.id,
        name: "",
        x: slotX,
        y: centerY
      };
      line.slots[slotIndex] = slot;
      createdSlots.push({ slotIndex, slot });
    });
    const dx = end.x - start.x;
    const dy = 0;
    const len = Math.hypot(dx, dy);
    if (len > 1e-6) {
      block.direction = dx < 0 ? -1 : 1;
      block.lastDirection = { x: dx / len, y: dy / len };
    } else {
      const hasExistingSeats = line.slots.some(slot => slot && slot.type === "seat" && slot.blockId === block.id);
      if (!hasExistingSeats && block.lastDirection) {
        block.direction = block.lastDirection.x < 0 ? -1 : 1;
      }
    }
    if (altSeatNumberingMode === "continuous") {
      if (createdSlots.length) {
        const startValue = altContinuousStartSeat;
        if (!hadSeats) {
          block.startSeat = startValue;
          block.autoStartSeatAssigned = true;
        }
        const ordered = createdSlots.sort((a, b) => {
          return block.direction === -1 ? b.slotIndex - a.slotIndex : a.slotIndex - b.slotIndex;
        });
        let current = startValue;
        ordered.forEach(({ slot }) => {
          slot.name = String(current);
          current += 1;
        });
        setAltContinuousStartSeat(current, true);
      }
    } else {
      renumberAltBlockSeats(line, block);
    }
    altIsDrawing = false;
    altDrawStart = null;
    altDrawEnd = null;
    altDrawLineIndex = null;
    setAltTooltip("", 0, 0, false);
    commitAltChange();
  }

  function materializeNewSection(draft) {
    computeSectionOutlinesFromSeats(0);
    const baseX = layoutBounds ? layoutBounds.maxX + 200 : 0;
    const baseY = layoutBounds ? layoutBounds.minY : 0;
    const seatSpacing = 120;
    const rowSpacing = 180;
    const timestamp = buildTimestamp();

    const sectionId = (draft.sectionId || computeNextSectionId()).trim();
    const sectionName = (draft.sectionName || sectionId).trim();
    sectionNames.set(sectionId, sectionName);

    originalLines.push(`${timestamp}|SectionAdd|SectionId=${sectionId}|Name=${sectionName}`);

    let rowCounter = 1;
    draft.rows.forEach((row, rowIdx) => {
      const yIndex = Number.isFinite(row.rowLine) ? row.rowLine : rowIdx;
      const items = row.items && row.items.length ? row.items : row.seats.map((s, i) => ({ ...s, pos: i }));
      const hasSeats = items.some((item) => !item.isGap);
      if (!hasSeats) {
        rowCounter += 1;
        return;
      }
      const rowName = (row.name || `Row ${rowCounter}`).trim();
      const rowId = `${sectionId}.${rowCounter}`;
      originalLines.push(`${timestamp}|RowAdd|RowId=${rowId}|Name=${rowName}`);
      let seatOrdinal = 1;
      items.forEach((seat) => {
        if (seat.isGap) return;
        const seatName = (seat.name || `${seatOrdinal}`).trim();
        const seatId = `${sectionId}.${rowCounter}.${seatOrdinal}`;
        const centerX = baseX + (seat.pos ?? (seatOrdinal - 1)) * seatSpacing;
        const centerY = baseY + yIndex * rowSpacing;
        const seatObj = {
          seatId,
          name: seatName,
          sectionId,
          rowId,
          sectionName,
          rowName,
          centerX,
          centerY,
          vx: centerX,
          vy: centerY,
          radius: 10,
          rotation: 0,
          width: 100,
          entryVia: "-",
          goodness: 0,
          attributes: [],
          timestamp,
          selected: false,
          lineIndex: originalLines.length
        };
        originalLines.push(buildSeatLine(seatObj));
        seats.push(seatObj);
        seatIdToLineIndex.set(seatId, seatObj.lineIndex);
        seatOrdinal += 1;
      });
      rowCounter += 1;
    });
  }

  function removeSectionData(sectionId) {
    // Ta bort seats för sektionen
    seats = seats.filter(s => s.sectionId !== sectionId);

    // Filtrera originalLines från Section/Row/Seat/Outline som tillhör sektionen
    const matchSection = (line) => {
      if (!line) return false;
      const outlineCode = sectionIdToOutlineCode(sectionId);
      return line.includes(`SectionId=${sectionId}`) ||
             line.includes(`RowId=${sectionId}.`) ||
             line.includes(`SeatId=${sectionId}.`) ||
             line.includes(`<Outline|${outlineCode}|`);
    };
    const removedIndexes = [];
    originalLines = originalLines.filter((line, idx) => {
      if (matchSection(line)) {
        removedIndexes.push(idx);
        return false;
      }
      return true;
    });
    outlines = outlines.filter(o => o.sectionId !== sectionId);
    shiftOutlineLineIndexesAfterRemoval(removedIndexes);

    // Bygg om index-map
    seatIdToLineIndex = new Map();
    originalLines.forEach((line, idx) => {
      if (line.includes("|SeatAdd|")) {
        const seatIdMatch = line.match(/SeatId=([^|]+)/);
        if (seatIdMatch) {
          seatIdToLineIndex.set(seatIdMatch[1], idx);
        }
      }
    });
  }

  function applyDraftToExisting(draft) {
    const sectionId = draft.sectionId;
    const draftRows = draft.rows || [];
    sectionNames.set(sectionId, draft.sectionName || sectionId);
    const grouped = new Map();
    seats.forEach((s) => {
      if (s.sectionId === sectionId) {
        if (!grouped.has(s.rowId)) grouped.set(s.rowId, []);
        grouped.get(s.rowId).push(s);
      }
    });
    const compareIdSegments = (idA, idB) => {
      const aParts = String(idA).split(".").map((p) => parseInt(p, 10));
      const bParts = String(idB).split(".").map((p) => parseInt(p, 10));
      const len = Math.max(aParts.length, bParts.length);
      for (let i = 0; i < len; i++) {
        const av = aParts[i] ?? 0;
        const bv = bParts[i] ?? 0;
        if (av !== bv) return av - bv;
      }
      return 0;
    };

    draftRows.forEach((row) => {
      const rowSeats = grouped.get(row.id);
      if (!rowSeats) return;
      rowSeats.sort((a, b) => compareIdSegments(a.seatId, b.seatId));
      rowSeats.forEach((seatObj, idx) => {
        seatObj.rowName = row.name || seatObj.rowName;
        seatObj.sectionName = draft.sectionName || seatObj.sectionName;
        if (row.seats[idx]) {
          seatObj.name = row.seats[idx].name || seatObj.name;
        }
      });
    });
  }

  function saveActiveSection() {
    const missingNames = sectionDrafts.filter(d => !d.sectionName || !d.sectionName.trim());
    if (missingNames.length) {
      alert("All sections must have names before you can save.");
      return false;
    }
    const duplicateNames = getDuplicateDraftSectionNames(sectionDrafts);
    if (duplicateNames.length) {
      alert("Section names must be unique. Duplicates: " + duplicateNames.join(", "));
      return false;
    }
    const tooLongNames = sectionDrafts
      .map(d => (d.sectionName || "").trim())
      .filter(name => name.length > SECTION_NAME_MAX);
    if (tooLongNames.length) {
      const uniqueTooLong = Array.from(new Set(tooLongNames));
      alert(`Section names must be ${SECTION_NAME_MAX} characters or fewer. Too long: ${uniqueTooLong.join(", ")}`);
      return false;
    }

    let addedNew = false;
    let anyChanged = false;
    sectionDrafts.forEach((draft) => {
      if (!draft.sectionId) return;
      const exists = seats.some((s) => s.sectionId === draft.sectionId);
      if (exists) {
        removeSectionData(draft.sectionId);
        materializeNewSection(draft);
        anyChanged = true;
      } else {
        materializeNewSection(draft);
        addedNew = true;
        anyChanged = true;
      }
      sectionColors.set(draft.sectionId, draft.color || "#14a0f4");
    });

    if (anyChanged) {
      // Säkerställ att varje rad har en RowAdd-rad (om något fallit bort)
      const existingRowIds = new Set(
        originalLines
          .filter(l => l.includes("|RowAdd|"))
          .map(l => {
            const m = l.match(/RowId=([^|]+)/);
            return m ? m[1] : null;
          })
          .filter(Boolean)
      );
      const rowsToAdd = new Map();
      seats.forEach((s) => {
        if (!s.rowId || existingRowIds.has(s.rowId)) return;
        if (!rowsToAdd.has(s.rowId)) {
          rowsToAdd.set(s.rowId, { rowId: s.rowId, rowName: s.rowName || s.rowId, ts: s.timestamp || buildTimestamp() });
        }
      });
      rowsToAdd.forEach((row) => {
        originalLines.push(`${row.ts}|RowAdd|RowId=${row.rowId}|Name=${row.rowName}`);
        existingRowIds.add(row.rowId);
      });

      rebuildSectionColors();
      const uniqueSections = new Set(seats.map(s => s.sectionId).filter(Boolean));
      seatCountEl.textContent = seats.length.toString();
      sectionCountEl.textContent = uniqueSections.size.toString();

      updateCodeFromSeats();
      hasUnsavedChanges = true;
      updateSaveButton();
      pushHistorySnapshot();
      renderCanvas();
      zoomToFitAllSeats();
    }

    setSectionDirty(false);
    renderAltSectionCards();
    renderAltSectionDetail();
    return true;
  }

// --- Kod-modal ---
  let codeModalOriginal = "";
  function openCodeModal() {
    codeModalOriginal = codePane.value || "";
    codeModalTextarea.value = codeModalOriginal;
    codeModalApply.disabled = true;
    codeModalOverlay.style.display = "flex";
  }
  function closeCodeModal() {
    codeModalOverlay.style.display = "none";
  }
  openCodeModalBtn?.addEventListener("click", openCodeModal);
  codeModalClose?.addEventListener("click", closeCodeModal);
  codeModalTextarea?.addEventListener("input", () => {
    codeModalApply.disabled = codeModalTextarea.value === codeModalOriginal;
  });
  codeModalApply?.addEventListener("click", () => {
    const newText = codeModalTextarea.value;
    codePane.value = newText;
    parseTlt(newText);
    hasUnsavedChanges = true;
    updateSaveButton();
    closeCodeModal();
  });

  // --- Right panel collapse ---
  function toggleRightPanel(toggle) {
    const card = toggle?.closest(".c-card");
    const body = card?.querySelector(".c-card__body");
    if (!card || !body) return;
    const collapsed = card.classList.toggle("c-card--collapsed");
    body.hidden = collapsed;
    toggle.setAttribute("aria-expanded", collapsed ? "false" : "true");
  }

  const rightPanels = document.getElementById("right-panels");
  rightPanels?.querySelectorAll(".c-card[data-collapsible='true']").forEach((card) => {
    const toggle = card.querySelector(".c-card__toggle");
    const body = card.querySelector(".c-card__body");
    if (!toggle || !body) return;
    const startCollapsed = card.getAttribute("data-collapsed") === "true";
    card.classList.toggle("c-card--collapsed", startCollapsed);
    body.hidden = startCollapsed;
    toggle.setAttribute("aria-expanded", startCollapsed ? "false" : "true");
  });

  // --- Section manager events ---
  openSectionManagerBtn?.addEventListener("click", openAltSectionManager);
  altSectionManagerClose?.addEventListener("click", () => {
    requestCloseAltSectionManager("Close without saving?");
  });
  altSectionImportExcelBtn?.addEventListener("click", () => {
    if (altSectionImportExcelInput) altSectionImportExcelInput.click();
  });
  altSectionImportExcelInput?.addEventListener("change", async (e) => {
    const file = e.target.files && e.target.files[0];
    if (!file) return;
    await importSectionsFromExcelFile(file);
    altSectionImportExcelInput.value = "";
    renderAltSectionCards();
    renderAltSectionDetail();
  });
  altSectionCreateBtn?.addEventListener("click", () => {
    const name = promptForSectionName("");
    if (!name) return;
    const rowCount = promptForRowCount("10");
    if (!rowCount) return;
    addNewAltDraft(name, rowCount);
  });
  altSectionCardsEl?.addEventListener("click", (e) => {
    const card = e.target.closest(".section-card");
    if (!card) return;
    const draft = sectionDrafts.find((d) => d.sectionId === card.dataset.sectionId);
    if (!draft) return;
    const renameRequested = !!e.target.closest(".section-card__rename");
    activeSectionDraftId = draft.sectionId;
    if (renameRequested) {
      renameDraftSection(draft);
    }
    renderAltSectionCards();
    renderAltSectionDetail();
  });
  altSectionSaveBtn?.addEventListener("click", () => {
    const draft = getActiveDraft();
    if (draft) syncAltDraftFromLines(draft);
    saveActiveSection();
  });
  altSectionSaveCloseBtn?.addEventListener("click", () => {
    const draft = getActiveDraft();
    if (draft) syncAltDraftFromLines(draft);
    const ok = saveActiveSection();
    if (ok) closeAltSectionManager();
  });

  altToolSelectBtn?.addEventListener("click", () => setAltTool("select"));
  altToolDrawBtn?.addEventListener("click", () => setAltTool("draw"));
  altGapNewBtn?.addEventListener("click", () => applyAltGap(false));
  altReverseSeatOrderBtn?.addEventListener("click", applyAltReverseSeatOrder);
  altSetStartSeatBtn?.addEventListener("click", applyAltSetStartSeat);
  altAddSeatBtn?.addEventListener("click", applyAltAddSeat);
  altRemoveSeatBtn?.addEventListener("click", applyAltRemoveSeat);
  altSetStartRowBtn?.addEventListener("click", applyAltSetStartRow);
  altReverseRowOrderBtn?.addEventListener("click", applyAltReverseRowOrder);
  altSetRowsManualBtn?.addEventListener("click", applyAltSetRowsManually);
  altDuplicateRowBtn?.addEventListener("click", applyAltDuplicateRow);
  altAddRowBtn?.addEventListener("click", applyAltAddRow);
  altClearRowBtn?.addEventListener("click", applyAltClearCurrentRow);
  altClearAllRowsBtn?.addEventListener("click", applyAltClearAllRows);
  altSeatNumberingModeSelect?.addEventListener("change", (e) => {
    altSeatNumberingMode = e.target.value === "continuous" ? "continuous" : "row";
    if (altSeatNumberingMode === "continuous") {
      syncAltContinuousStartSeatFromDraft(getActiveDraft());
    }
    updateAltContinuousControls();
    commitAltChange();
  });
  altContinuousSkipBtn?.addEventListener("click", () => {
    setAltContinuousStartSeat(altContinuousStartSeat + 1, true);
    updateAltContinuousControls();
  });

  altSectionCanvas?.addEventListener("mousedown", (e) => {
    const draft = getActiveDraft();
    if (!draft) return;
    const metrics = getAltCanvasMetrics();
    if (!metrics) return;
    const point = getAltCanvasPoint(e);
    if (altSectionTool === "draw") {
      const lineIndex = getAltLineIndexFromY(point.y, metrics);
      if (lineIndex == null) {
        renderAltSectionCanvas();
        return;
      }
      setAltActiveLine(lineIndex);
      const clamped = clampAltPointToRowBand(point, lineIndex, metrics);
      clamped.y = getAltRowCenterY(lineIndex, metrics);
      altIsDrawing = true;
      altDrawStart = clamped;
      altDrawEnd = clamped;
      altDrawLineIndex = lineIndex;
      renderAltSectionCanvas();
      return;
    }
    if (altSectionTool === "select") {
      const hit = findAltSeatHit(point.x, point.y, metrics);
      if (hit) {
        setAltActiveLine(hit.lineIndex);
        const line = altRowLines[hit.lineIndex];
        if (line) line.activeBlockId = hit.blockId;
      } else {
        const lineIndex = getAltLineIndexFromY(point.y, metrics);
        if (lineIndex != null) setAltActiveLine(lineIndex);
      }
      renderAltSectionCanvas();
    }
  });
  altSectionCanvas?.addEventListener("mousemove", (e) => {
    if (!altIsDrawing) return;
    const metrics = getAltCanvasMetrics();
    if (!metrics) return;
    const point = getAltCanvasPoint(e);
    if (altDrawLineIndex == null) return;
    const clamped = clampAltPointToRowBand(point, altDrawLineIndex, metrics);
    clamped.y = getAltRowCenterY(altDrawLineIndex, metrics);
    altDrawEnd = clamped;
    const line = altRowLines[altDrawLineIndex];
    const block = getAltActiveBlock(line);
    if (line && block) {
      const existingSeats = line.slots.filter(slot => slot && slot.type === "seat" && slot.blockId === block.id).length;
      const previewPoints = buildAltSeatPoints(altDrawStart, altDrawEnd);
      const newCount = previewPoints.length;
      const total = existingSeats + newCount;
      const startSeat = altSeatNumberingMode === "continuous" ? altContinuousStartSeat : block.startSeat;
      const lastSeat = normalizeAltContinuousStartSeat(startSeat) + Math.max(0, (altSeatNumberingMode === "continuous" ? newCount : total) - 1);
      setAltTooltip(`No. of seats: ${newCount} · Last seat name: ${lastSeat}`, e.clientX, e.clientY, true);
    }
    renderAltSectionCanvas();
  });
  altSectionCanvas?.addEventListener("mouseleave", () => {
    if (altIsDrawing) renderAltSectionCanvas();
    setAltTooltip("", 0, 0, false);
  });
  window.addEventListener("mouseup", () => {
    finalizeAltDraw();
  });
  window.addEventListener("keydown", (e) => {
    if (!altSectionManagerOverlay || altSectionManagerOverlay.style.display !== "flex") return;
    const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : "";
    if (tag === "input" || tag === "textarea" || tag === "select" || e.isComposing) return;
    if (e.key === "s" || e.key === "S") {
      e.preventDefault();
      setAltTool("select");
    }
    if (e.key === "d" || e.key === "D") {
      e.preventDefault();
      setAltTool("draw");
    }
    if (e.key === "n" || e.key === "N") {
      e.preventDefault();
      applyAltGap(false);
    }
  });

  const THEME_STORAGE_KEY = "arenaDesignerTheme";
  function applyTheme(theme) {
    const root = document.documentElement;
    if (theme === "dark") root.setAttribute("data-theme", "dark");
    else root.removeAttribute("data-theme");
    if (themeToggleBtn) {
      themeToggleBtn.textContent = theme === "dark" ? "GO LIGHT" : "GO DARK";
    }
  }

  function readStoredTheme() {
    try {
      return localStorage.getItem(THEME_STORAGE_KEY);
    } catch {
      return null;
    }
  }

  function writeStoredTheme(theme) {
    try {
      localStorage.setItem(THEME_STORAGE_KEY, theme);
    } catch {
      // Ignore storage failures (e.g., private mode).
    }
  }

  function getPreferredTheme() {
    const stored = readStoredTheme();
    if (stored === "dark" || stored === "light") return stored;
    if (window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches) {
      return "dark";
    }
    return "light";
  }

  themeToggleBtn?.addEventListener("click", () => {
    const isDark = document.documentElement.getAttribute("data-theme") === "dark";
    const nextTheme = isDark ? "light" : "dark";
    applyTheme(nextTheme);
    writeStoredTheme(nextTheme);
  });

  applyTheme(getPreferredTheme());


  // --- Init ---

  window.addEventListener("load", async () => {
    // Försök återställa en tidigare session (om det finns)
    await tryRestoreSessionFromLocalStorage();
    setLayoutActive(restoredSession);

    setBackgroundEnabled(!!backgroundState.enabled);
    if (!restoredSession) {
      renderGrayscale = false;
      showHoverInfo = viewHoverToggle?.checked ?? true;
      showSectionNames = viewSectionNamesToggle?.checked ?? false;
      if (viewSeatLabelRow?.checked) seatLabelMode = "row";
      else if (viewSeatLabelSeat?.checked) seatLabelMode = "seat";
      else if (viewSeatLabelSeatId?.checked) seatLabelMode = "seatId";
      else seatLabelMode = "none";
      const initialOverlay = viewOverlayGoodness?.checked
        ? "goodness"
        : (viewOverlayPrice?.checked ? "price" : "none");
      setOverlayMode(initialOverlay, true, false);
    }

    setTool("select");
    setSelectionMode("seat");
    updateMoveButtonState();
    updateSaveButton();
    loadPriceRegionsFromStorage();
    loadEntryPointsFromStorage();
    renderCanvas();

    // Om det finns sparad vyinfo i localStorage som Бnnu inte applicerats (t.ex. ingen session vald)
    // se till att UI-speglas
    if (viewHoverToggle) viewHoverToggle.checked = showHoverInfo;
    if (viewSectionNamesToggle) viewSectionNamesToggle.checked = showSectionNames;
    if (viewOverlayNone) viewOverlayNone.checked = overlayMode === "none";
    if (viewOverlayPrice) viewOverlayPrice.checked = overlayMode === "price";
    if (viewOverlayGoodness) viewOverlayGoodness.checked = overlayMode === "goodness";
  });

  window.addEventListener("beforeunload", (e) => {
    saveSessionToLocalStorage();
    if (!hasUnsavedChanges) return;

    // Detta magiska returnValue krävs för att vissa browsers ska visa varningen
    e.preventDefault();
    e.returnValue = "";
  });
  
  </script>

  </body>
  </html>
